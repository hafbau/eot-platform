
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model DelayEvent
 * 
 */
export type DelayEvent = $Result.DefaultSelection<Prisma.$DelayEventPayload>
/**
 * Model Claim
 * 
 */
export type Claim = $Result.DefaultSelection<Prisma.$ClaimPayload>
/**
 * Model Evidence
 * 
 */
export type Evidence = $Result.DefaultSelection<Prisma.$EvidencePayload>
/**
 * Model Schedule
 * 
 */
export type Schedule = $Result.DefaultSelection<Prisma.$SchedulePayload>
/**
 * Model ActionItem
 * 
 */
export type ActionItem = $Result.DefaultSelection<Prisma.$ActionItemPayload>
/**
 * Model FileMetadata
 * 
 */
export type FileMetadata = $Result.DefaultSelection<Prisma.$FileMetadataPayload>
/**
 * Model StorageQuota
 * 
 */
export type StorageQuota = $Result.DefaultSelection<Prisma.$StorageQuotaPayload>
/**
 * Model SessionData
 * 
 */
export type SessionData = $Result.DefaultSelection<Prisma.$SessionDataPayload>
/**
 * Model MfaSettings
 * 
 */
export type MfaSettings = $Result.DefaultSelection<Prisma.$MfaSettingsPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model AnalyticsEvent
 * 
 */
export type AnalyticsEvent = $Result.DefaultSelection<Prisma.$AnalyticsEventPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  DIRECTOR: 'DIRECTOR',
  PROJECT_MANAGER: 'PROJECT_MANAGER',
  SCHEDULER: 'SCHEDULER',
  ADMIN: 'ADMIN',
  USER: 'USER',
  VIEWER: 'VIEWER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ProjectStatus: {
  PLANNING: 'PLANNING',
  ACTIVE: 'ACTIVE',
  ON_HOLD: 'ON_HOLD',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus]


export const ContractType: {
  FIDIC_RED: 'FIDIC_RED',
  FIDIC_YELLOW: 'FIDIC_YELLOW',
  FIDIC_SILVER: 'FIDIC_SILVER',
  NEC3: 'NEC3',
  NEC4: 'NEC4',
  CUSTOM: 'CUSTOM'
};

export type ContractType = (typeof ContractType)[keyof typeof ContractType]


export const DelayType: {
  CLIENT_DELAY: 'CLIENT_DELAY',
  CONTRACTOR_DELAY: 'CONTRACTOR_DELAY',
  WEATHER: 'WEATHER',
  THIRD_PARTY: 'THIRD_PARTY',
  FORCE_MAJEURE: 'FORCE_MAJEURE'
};

export type DelayType = (typeof DelayType)[keyof typeof DelayType]


export const DelayStatus: {
  DETECTED: 'DETECTED',
  UNDER_REVIEW: 'UNDER_REVIEW',
  CLAIM_PREPARED: 'CLAIM_PREPARED',
  CLAIM_SUBMITTED: 'CLAIM_SUBMITTED',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type DelayStatus = (typeof DelayStatus)[keyof typeof DelayStatus]


export const ClaimStatus: {
  DRAFT: 'DRAFT',
  UNDER_REVIEW: 'UNDER_REVIEW',
  SUBMITTED: 'SUBMITTED',
  UNDER_EVALUATION: 'UNDER_EVALUATION',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  SETTLED: 'SETTLED'
};

export type ClaimStatus = (typeof ClaimStatus)[keyof typeof ClaimStatus]


export const EvidenceType: {
  EMAIL: 'EMAIL',
  DOCUMENT: 'DOCUMENT',
  PHOTO: 'PHOTO',
  MEETING_MINUTES: 'MEETING_MINUTES',
  SITE_REPORT: 'SITE_REPORT',
  WEATHER_DATA: 'WEATHER_DATA',
  SCHEDULE: 'SCHEDULE',
  RFI: 'RFI',
  CHANGE_ORDER: 'CHANGE_ORDER'
};

export type EvidenceType = (typeof EvidenceType)[keyof typeof EvidenceType]


export const ScheduleFormat: {
  PRIMAVERA_P6: 'PRIMAVERA_P6',
  MS_PROJECT: 'MS_PROJECT',
  ASTA: 'ASTA',
  CSV: 'CSV',
  EXCEL: 'EXCEL'
};

export type ScheduleFormat = (typeof ScheduleFormat)[keyof typeof ScheduleFormat]


export const ExportFormat: {
  PDF: 'PDF',
  WORD: 'WORD',
  HTML: 'HTML',
  EXCEL: 'EXCEL'
};

export type ExportFormat = (typeof ExportFormat)[keyof typeof ExportFormat]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const ActionItemStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type ActionItemStatus = (typeof ActionItemStatus)[keyof typeof ActionItemStatus]


export const MfaMethod: {
  TOTP: 'TOTP',
  SMS: 'SMS',
  EMAIL: 'EMAIL'
};

export type MfaMethod = (typeof MfaMethod)[keyof typeof MfaMethod]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ProjectStatus = $Enums.ProjectStatus

export const ProjectStatus: typeof $Enums.ProjectStatus

export type ContractType = $Enums.ContractType

export const ContractType: typeof $Enums.ContractType

export type DelayType = $Enums.DelayType

export const DelayType: typeof $Enums.DelayType

export type DelayStatus = $Enums.DelayStatus

export const DelayStatus: typeof $Enums.DelayStatus

export type ClaimStatus = $Enums.ClaimStatus

export const ClaimStatus: typeof $Enums.ClaimStatus

export type EvidenceType = $Enums.EvidenceType

export const EvidenceType: typeof $Enums.EvidenceType

export type ScheduleFormat = $Enums.ScheduleFormat

export const ScheduleFormat: typeof $Enums.ScheduleFormat

export type ExportFormat = $Enums.ExportFormat

export const ExportFormat: typeof $Enums.ExportFormat

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type ActionItemStatus = $Enums.ActionItemStatus

export const ActionItemStatus: typeof $Enums.ActionItemStatus

export type MfaMethod = $Enums.MfaMethod

export const MfaMethod: typeof $Enums.MfaMethod

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Organizations
 * const organizations = await prisma.organization.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Organizations
   * const organizations = await prisma.organization.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.delayEvent`: Exposes CRUD operations for the **DelayEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DelayEvents
    * const delayEvents = await prisma.delayEvent.findMany()
    * ```
    */
  get delayEvent(): Prisma.DelayEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.claim`: Exposes CRUD operations for the **Claim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Claims
    * const claims = await prisma.claim.findMany()
    * ```
    */
  get claim(): Prisma.ClaimDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evidence`: Exposes CRUD operations for the **Evidence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evidences
    * const evidences = await prisma.evidence.findMany()
    * ```
    */
  get evidence(): Prisma.EvidenceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schedule`: Exposes CRUD operations for the **Schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedule.findMany()
    * ```
    */
  get schedule(): Prisma.ScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.actionItem`: Exposes CRUD operations for the **ActionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActionItems
    * const actionItems = await prisma.actionItem.findMany()
    * ```
    */
  get actionItem(): Prisma.ActionItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fileMetadata`: Exposes CRUD operations for the **FileMetadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileMetadata
    * const fileMetadata = await prisma.fileMetadata.findMany()
    * ```
    */
  get fileMetadata(): Prisma.FileMetadataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.storageQuota`: Exposes CRUD operations for the **StorageQuota** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StorageQuotas
    * const storageQuotas = await prisma.storageQuota.findMany()
    * ```
    */
  get storageQuota(): Prisma.StorageQuotaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessionData`: Exposes CRUD operations for the **SessionData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionData
    * const sessionData = await prisma.sessionData.findMany()
    * ```
    */
  get sessionData(): Prisma.SessionDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mfaSettings`: Exposes CRUD operations for the **MfaSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MfaSettings
    * const mfaSettings = await prisma.mfaSettings.findMany()
    * ```
    */
  get mfaSettings(): Prisma.MfaSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analyticsEvent`: Exposes CRUD operations for the **AnalyticsEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsEvents
    * const analyticsEvents = await prisma.analyticsEvent.findMany()
    * ```
    */
  get analyticsEvent(): Prisma.AnalyticsEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Organization: 'Organization',
    User: 'User',
    Project: 'Project',
    DelayEvent: 'DelayEvent',
    Claim: 'Claim',
    Evidence: 'Evidence',
    Schedule: 'Schedule',
    ActionItem: 'ActionItem',
    FileMetadata: 'FileMetadata',
    StorageQuota: 'StorageQuota',
    SessionData: 'SessionData',
    MfaSettings: 'MfaSettings',
    PasswordResetToken: 'PasswordResetToken',
    AnalyticsEvent: 'AnalyticsEvent',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "organization" | "user" | "project" | "delayEvent" | "claim" | "evidence" | "schedule" | "actionItem" | "fileMetadata" | "storageQuota" | "sessionData" | "mfaSettings" | "passwordResetToken" | "analyticsEvent" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      DelayEvent: {
        payload: Prisma.$DelayEventPayload<ExtArgs>
        fields: Prisma.DelayEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DelayEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelayEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DelayEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelayEventPayload>
          }
          findFirst: {
            args: Prisma.DelayEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelayEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DelayEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelayEventPayload>
          }
          findMany: {
            args: Prisma.DelayEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelayEventPayload>[]
          }
          create: {
            args: Prisma.DelayEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelayEventPayload>
          }
          createMany: {
            args: Prisma.DelayEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DelayEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelayEventPayload>[]
          }
          delete: {
            args: Prisma.DelayEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelayEventPayload>
          }
          update: {
            args: Prisma.DelayEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelayEventPayload>
          }
          deleteMany: {
            args: Prisma.DelayEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DelayEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DelayEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelayEventPayload>[]
          }
          upsert: {
            args: Prisma.DelayEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DelayEventPayload>
          }
          aggregate: {
            args: Prisma.DelayEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDelayEvent>
          }
          groupBy: {
            args: Prisma.DelayEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<DelayEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.DelayEventCountArgs<ExtArgs>
            result: $Utils.Optional<DelayEventCountAggregateOutputType> | number
          }
        }
      }
      Claim: {
        payload: Prisma.$ClaimPayload<ExtArgs>
        fields: Prisma.ClaimFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClaimFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClaimFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          findFirst: {
            args: Prisma.ClaimFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClaimFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          findMany: {
            args: Prisma.ClaimFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>[]
          }
          create: {
            args: Prisma.ClaimCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          createMany: {
            args: Prisma.ClaimCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClaimCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>[]
          }
          delete: {
            args: Prisma.ClaimDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          update: {
            args: Prisma.ClaimUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          deleteMany: {
            args: Prisma.ClaimDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClaimUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClaimUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>[]
          }
          upsert: {
            args: Prisma.ClaimUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          aggregate: {
            args: Prisma.ClaimAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClaim>
          }
          groupBy: {
            args: Prisma.ClaimGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClaimGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClaimCountArgs<ExtArgs>
            result: $Utils.Optional<ClaimCountAggregateOutputType> | number
          }
        }
      }
      Evidence: {
        payload: Prisma.$EvidencePayload<ExtArgs>
        fields: Prisma.EvidenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvidenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvidenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          findFirst: {
            args: Prisma.EvidenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvidenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          findMany: {
            args: Prisma.EvidenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>[]
          }
          create: {
            args: Prisma.EvidenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          createMany: {
            args: Prisma.EvidenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvidenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>[]
          }
          delete: {
            args: Prisma.EvidenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          update: {
            args: Prisma.EvidenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          deleteMany: {
            args: Prisma.EvidenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvidenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EvidenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>[]
          }
          upsert: {
            args: Prisma.EvidenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidencePayload>
          }
          aggregate: {
            args: Prisma.EvidenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvidence>
          }
          groupBy: {
            args: Prisma.EvidenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvidenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvidenceCountArgs<ExtArgs>
            result: $Utils.Optional<EvidenceCountAggregateOutputType> | number
          }
        }
      }
      Schedule: {
        payload: Prisma.$SchedulePayload<ExtArgs>
        fields: Prisma.ScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findFirst: {
            args: Prisma.ScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findMany: {
            args: Prisma.ScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          create: {
            args: Prisma.ScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          createMany: {
            args: Prisma.ScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          delete: {
            args: Prisma.ScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          update: {
            args: Prisma.ScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          deleteMany: {
            args: Prisma.ScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          upsert: {
            args: Prisma.ScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          aggregate: {
            args: Prisma.ScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchedule>
          }
          groupBy: {
            args: Prisma.ScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleCountAggregateOutputType> | number
          }
        }
      }
      ActionItem: {
        payload: Prisma.$ActionItemPayload<ExtArgs>
        fields: Prisma.ActionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>
          }
          findFirst: {
            args: Prisma.ActionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>
          }
          findMany: {
            args: Prisma.ActionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>[]
          }
          create: {
            args: Prisma.ActionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>
          }
          createMany: {
            args: Prisma.ActionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActionItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>[]
          }
          delete: {
            args: Prisma.ActionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>
          }
          update: {
            args: Prisma.ActionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>
          }
          deleteMany: {
            args: Prisma.ActionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActionItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>[]
          }
          upsert: {
            args: Prisma.ActionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActionItemPayload>
          }
          aggregate: {
            args: Prisma.ActionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActionItem>
          }
          groupBy: {
            args: Prisma.ActionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActionItemCountArgs<ExtArgs>
            result: $Utils.Optional<ActionItemCountAggregateOutputType> | number
          }
        }
      }
      FileMetadata: {
        payload: Prisma.$FileMetadataPayload<ExtArgs>
        fields: Prisma.FileMetadataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileMetadataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileMetadataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload>
          }
          findFirst: {
            args: Prisma.FileMetadataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileMetadataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload>
          }
          findMany: {
            args: Prisma.FileMetadataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload>[]
          }
          create: {
            args: Prisma.FileMetadataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload>
          }
          createMany: {
            args: Prisma.FileMetadataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileMetadataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload>[]
          }
          delete: {
            args: Prisma.FileMetadataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload>
          }
          update: {
            args: Prisma.FileMetadataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload>
          }
          deleteMany: {
            args: Prisma.FileMetadataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileMetadataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileMetadataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload>[]
          }
          upsert: {
            args: Prisma.FileMetadataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileMetadataPayload>
          }
          aggregate: {
            args: Prisma.FileMetadataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileMetadata>
          }
          groupBy: {
            args: Prisma.FileMetadataGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileMetadataGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileMetadataCountArgs<ExtArgs>
            result: $Utils.Optional<FileMetadataCountAggregateOutputType> | number
          }
        }
      }
      StorageQuota: {
        payload: Prisma.$StorageQuotaPayload<ExtArgs>
        fields: Prisma.StorageQuotaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StorageQuotaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StorageQuotaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>
          }
          findFirst: {
            args: Prisma.StorageQuotaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StorageQuotaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>
          }
          findMany: {
            args: Prisma.StorageQuotaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>[]
          }
          create: {
            args: Prisma.StorageQuotaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>
          }
          createMany: {
            args: Prisma.StorageQuotaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StorageQuotaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>[]
          }
          delete: {
            args: Prisma.StorageQuotaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>
          }
          update: {
            args: Prisma.StorageQuotaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>
          }
          deleteMany: {
            args: Prisma.StorageQuotaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StorageQuotaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StorageQuotaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>[]
          }
          upsert: {
            args: Prisma.StorageQuotaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StorageQuotaPayload>
          }
          aggregate: {
            args: Prisma.StorageQuotaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStorageQuota>
          }
          groupBy: {
            args: Prisma.StorageQuotaGroupByArgs<ExtArgs>
            result: $Utils.Optional<StorageQuotaGroupByOutputType>[]
          }
          count: {
            args: Prisma.StorageQuotaCountArgs<ExtArgs>
            result: $Utils.Optional<StorageQuotaCountAggregateOutputType> | number
          }
        }
      }
      SessionData: {
        payload: Prisma.$SessionDataPayload<ExtArgs>
        fields: Prisma.SessionDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDataPayload>
          }
          findFirst: {
            args: Prisma.SessionDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDataPayload>
          }
          findMany: {
            args: Prisma.SessionDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDataPayload>[]
          }
          create: {
            args: Prisma.SessionDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDataPayload>
          }
          createMany: {
            args: Prisma.SessionDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDataPayload>[]
          }
          delete: {
            args: Prisma.SessionDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDataPayload>
          }
          update: {
            args: Prisma.SessionDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDataPayload>
          }
          deleteMany: {
            args: Prisma.SessionDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDataPayload>[]
          }
          upsert: {
            args: Prisma.SessionDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDataPayload>
          }
          aggregate: {
            args: Prisma.SessionDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionData>
          }
          groupBy: {
            args: Prisma.SessionDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionDataCountArgs<ExtArgs>
            result: $Utils.Optional<SessionDataCountAggregateOutputType> | number
          }
        }
      }
      MfaSettings: {
        payload: Prisma.$MfaSettingsPayload<ExtArgs>
        fields: Prisma.MfaSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MfaSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MfaSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaSettingsPayload>
          }
          findFirst: {
            args: Prisma.MfaSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MfaSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaSettingsPayload>
          }
          findMany: {
            args: Prisma.MfaSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaSettingsPayload>[]
          }
          create: {
            args: Prisma.MfaSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaSettingsPayload>
          }
          createMany: {
            args: Prisma.MfaSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MfaSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaSettingsPayload>[]
          }
          delete: {
            args: Prisma.MfaSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaSettingsPayload>
          }
          update: {
            args: Prisma.MfaSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaSettingsPayload>
          }
          deleteMany: {
            args: Prisma.MfaSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MfaSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MfaSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaSettingsPayload>[]
          }
          upsert: {
            args: Prisma.MfaSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MfaSettingsPayload>
          }
          aggregate: {
            args: Prisma.MfaSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMfaSettings>
          }
          groupBy: {
            args: Prisma.MfaSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MfaSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.MfaSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<MfaSettingsCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsEvent: {
        payload: Prisma.$AnalyticsEventPayload<ExtArgs>
        fields: Prisma.AnalyticsEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          findMany: {
            args: Prisma.AnalyticsEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          create: {
            args: Prisma.AnalyticsEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          createMany: {
            args: Prisma.AnalyticsEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          update: {
            args: Prisma.AnalyticsEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalyticsEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>[]
          }
          upsert: {
            args: Prisma.AnalyticsEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsEventPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsEvent>
          }
          groupBy: {
            args: Prisma.AnalyticsEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsEventCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsEventCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    organization?: OrganizationOmit
    user?: UserOmit
    project?: ProjectOmit
    delayEvent?: DelayEventOmit
    claim?: ClaimOmit
    evidence?: EvidenceOmit
    schedule?: ScheduleOmit
    actionItem?: ActionItemOmit
    fileMetadata?: FileMetadataOmit
    storageQuota?: StorageQuotaOmit
    sessionData?: SessionDataOmit
    mfaSettings?: MfaSettingsOmit
    passwordResetToken?: PasswordResetTokenOmit
    analyticsEvent?: AnalyticsEventOmit
    auditLog?: AuditLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    users: number
    projects: number
    files: number
    auditLogs: number
    events: number
    quotas: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | OrganizationCountOutputTypeCountUsersArgs
    projects?: boolean | OrganizationCountOutputTypeCountProjectsArgs
    files?: boolean | OrganizationCountOutputTypeCountFilesArgs
    auditLogs?: boolean | OrganizationCountOutputTypeCountAuditLogsArgs
    events?: boolean | OrganizationCountOutputTypeCountEventsArgs
    quotas?: boolean | OrganizationCountOutputTypeCountQuotasArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileMetadataWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsEventWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountQuotasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageQuotaWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    assignedProjects: number
    delayEvents: number
    claims: number
    evidence: number
    actionItems: number
    filesUploaded: number
    sessions: number
    passwordResets: number
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedProjects?: boolean | UserCountOutputTypeCountAssignedProjectsArgs
    delayEvents?: boolean | UserCountOutputTypeCountDelayEventsArgs
    claims?: boolean | UserCountOutputTypeCountClaimsArgs
    evidence?: boolean | UserCountOutputTypeCountEvidenceArgs
    actionItems?: boolean | UserCountOutputTypeCountActionItemsArgs
    filesUploaded?: boolean | UserCountOutputTypeCountFilesUploadedArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    passwordResets?: boolean | UserCountOutputTypeCountPasswordResetsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDelayEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DelayEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEvidenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionItemWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFilesUploadedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileMetadataWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionDataWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    delayEvents: number
    claims: number
    actionItems: number
    schedules: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delayEvents?: boolean | ProjectCountOutputTypeCountDelayEventsArgs
    claims?: boolean | ProjectCountOutputTypeCountClaimsArgs
    actionItems?: boolean | ProjectCountOutputTypeCountActionItemsArgs
    schedules?: boolean | ProjectCountOutputTypeCountSchedulesArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountDelayEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DelayEventWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountActionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionItemWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }


  /**
   * Count Type DelayEventCountOutputType
   */

  export type DelayEventCountOutputType = {
    claims: number
    evidence: number
  }

  export type DelayEventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claims?: boolean | DelayEventCountOutputTypeCountClaimsArgs
    evidence?: boolean | DelayEventCountOutputTypeCountEvidenceArgs
  }

  // Custom InputTypes
  /**
   * DelayEventCountOutputType without action
   */
  export type DelayEventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DelayEventCountOutputType
     */
    select?: DelayEventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DelayEventCountOutputType without action
   */
  export type DelayEventCountOutputTypeCountClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }

  /**
   * DelayEventCountOutputType without action
   */
  export type DelayEventCountOutputTypeCountEvidenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenceWhereInput
  }


  /**
   * Count Type ClaimCountOutputType
   */

  export type ClaimCountOutputType = {
    evidence: number
  }

  export type ClaimCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evidence?: boolean | ClaimCountOutputTypeCountEvidenceArgs
  }

  // Custom InputTypes
  /**
   * ClaimCountOutputType without action
   */
  export type ClaimCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClaimCountOutputType
     */
    select?: ClaimCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClaimCountOutputType without action
   */
  export type ClaimCountOutputTypeCountEvidenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenceWhereInput
  }


  /**
   * Count Type FileMetadataCountOutputType
   */

  export type FileMetadataCountOutputType = {
    evidence: number
    schedules: number
  }

  export type FileMetadataCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evidence?: boolean | FileMetadataCountOutputTypeCountEvidenceArgs
    schedules?: boolean | FileMetadataCountOutputTypeCountSchedulesArgs
  }

  // Custom InputTypes
  /**
   * FileMetadataCountOutputType without action
   */
  export type FileMetadataCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadataCountOutputType
     */
    select?: FileMetadataCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FileMetadataCountOutputType without action
   */
  export type FileMetadataCountOutputTypeCountEvidenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenceWhereInput
  }

  /**
   * FileMetadataCountOutputType without action
   */
  export type FileMetadataCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    domain: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    domain: number
    isActive: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    domain?: true
    isActive?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    name: string
    domain: string
    isActive: boolean
    settings: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    isActive?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Organization$usersArgs<ExtArgs>
    projects?: boolean | Organization$projectsArgs<ExtArgs>
    files?: boolean | Organization$filesArgs<ExtArgs>
    auditLogs?: boolean | Organization$auditLogsArgs<ExtArgs>
    events?: boolean | Organization$eventsArgs<ExtArgs>
    quotas?: boolean | Organization$quotasArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    isActive?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    domain?: boolean
    isActive?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    domain?: boolean
    isActive?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "domain" | "isActive" | "settings" | "createdAt" | "updatedAt", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Organization$usersArgs<ExtArgs>
    projects?: boolean | Organization$projectsArgs<ExtArgs>
    files?: boolean | Organization$filesArgs<ExtArgs>
    auditLogs?: boolean | Organization$auditLogsArgs<ExtArgs>
    events?: boolean | Organization$eventsArgs<ExtArgs>
    quotas?: boolean | Organization$quotasArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      files: Prisma.$FileMetadataPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      events: Prisma.$AnalyticsEventPayload<ExtArgs>[]
      quotas: Prisma.$StorageQuotaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      domain: string
      isActive: boolean
      settings: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Organization$usersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projects<T extends Organization$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    files<T extends Organization$filesArgs<ExtArgs> = {}>(args?: Subset<T, Organization$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Organization$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    events<T extends Organization$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quotas<T extends Organization$quotasArgs<ExtArgs> = {}>(args?: Subset<T, Organization$quotasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly domain: FieldRef<"Organization", 'String'>
    readonly isActive: FieldRef<"Organization", 'Boolean'>
    readonly settings: FieldRef<"Organization", 'Json'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization.users
   */
  export type Organization$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Organization.projects
   */
  export type Organization$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Organization.files
   */
  export type Organization$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    where?: FileMetadataWhereInput
    orderBy?: FileMetadataOrderByWithRelationInput | FileMetadataOrderByWithRelationInput[]
    cursor?: FileMetadataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileMetadataScalarFieldEnum | FileMetadataScalarFieldEnum[]
  }

  /**
   * Organization.auditLogs
   */
  export type Organization$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Organization.events
   */
  export type Organization$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    where?: AnalyticsEventWhereInput
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    cursor?: AnalyticsEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * Organization.quotas
   */
  export type Organization$quotasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageQuota
     */
    omit?: StorageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    where?: StorageQuotaWhereInput
    orderBy?: StorageQuotaOrderByWithRelationInput | StorageQuotaOrderByWithRelationInput[]
    cursor?: StorageQuotaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StorageQuotaScalarFieldEnum | StorageQuotaScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    organizationId: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    role: $Enums.UserRole | null
    organizationId: string | null
    isActive: boolean | null
    lastLoginAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    firstName: number
    lastName: number
    role: number
    organizationId: number
    isActive: number
    lastLoginAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    role?: true
    organizationId?: true
    isActive?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    role?: true
    organizationId?: true
    isActive?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    role?: true
    organizationId?: true
    isActive?: true
    lastLoginAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    organizationId: string
    isActive: boolean
    lastLoginAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    organizationId?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    assignedProjects?: boolean | User$assignedProjectsArgs<ExtArgs>
    delayEvents?: boolean | User$delayEventsArgs<ExtArgs>
    claims?: boolean | User$claimsArgs<ExtArgs>
    evidence?: boolean | User$evidenceArgs<ExtArgs>
    actionItems?: boolean | User$actionItemsArgs<ExtArgs>
    filesUploaded?: boolean | User$filesUploadedArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    mfaSettings?: boolean | User$mfaSettingsArgs<ExtArgs>
    passwordResets?: boolean | User$passwordResetsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    organizationId?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    organizationId?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    organizationId?: boolean
    isActive?: boolean
    lastLoginAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "firstName" | "lastName" | "role" | "organizationId" | "isActive" | "lastLoginAt" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    assignedProjects?: boolean | User$assignedProjectsArgs<ExtArgs>
    delayEvents?: boolean | User$delayEventsArgs<ExtArgs>
    claims?: boolean | User$claimsArgs<ExtArgs>
    evidence?: boolean | User$evidenceArgs<ExtArgs>
    actionItems?: boolean | User$actionItemsArgs<ExtArgs>
    filesUploaded?: boolean | User$filesUploadedArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    mfaSettings?: boolean | User$mfaSettingsArgs<ExtArgs>
    passwordResets?: boolean | User$passwordResetsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      assignedProjects: Prisma.$ProjectPayload<ExtArgs>[]
      delayEvents: Prisma.$DelayEventPayload<ExtArgs>[]
      claims: Prisma.$ClaimPayload<ExtArgs>[]
      evidence: Prisma.$EvidencePayload<ExtArgs>[]
      actionItems: Prisma.$ActionItemPayload<ExtArgs>[]
      filesUploaded: Prisma.$FileMetadataPayload<ExtArgs>[]
      sessions: Prisma.$SessionDataPayload<ExtArgs>[]
      mfaSettings: Prisma.$MfaSettingsPayload<ExtArgs> | null
      passwordResets: Prisma.$PasswordResetTokenPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      firstName: string
      lastName: string
      role: $Enums.UserRole
      organizationId: string
      isActive: boolean
      lastLoginAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedProjects<T extends User$assignedProjectsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedProjectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    delayEvents<T extends User$delayEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$delayEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DelayEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    claims<T extends User$claimsArgs<ExtArgs> = {}>(args?: Subset<T, User$claimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    evidence<T extends User$evidenceArgs<ExtArgs> = {}>(args?: Subset<T, User$evidenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    actionItems<T extends User$actionItemsArgs<ExtArgs> = {}>(args?: Subset<T, User$actionItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    filesUploaded<T extends User$filesUploadedArgs<ExtArgs> = {}>(args?: Subset<T, User$filesUploadedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mfaSettings<T extends User$mfaSettingsArgs<ExtArgs> = {}>(args?: Subset<T, User$mfaSettingsArgs<ExtArgs>>): Prisma__MfaSettingsClient<$Result.GetResult<Prisma.$MfaSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    passwordResets<T extends User$passwordResetsArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly organizationId: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.assignedProjects
   */
  export type User$assignedProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.delayEvents
   */
  export type User$delayEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DelayEvent
     */
    select?: DelayEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DelayEvent
     */
    omit?: DelayEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelayEventInclude<ExtArgs> | null
    where?: DelayEventWhereInput
    orderBy?: DelayEventOrderByWithRelationInput | DelayEventOrderByWithRelationInput[]
    cursor?: DelayEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DelayEventScalarFieldEnum | DelayEventScalarFieldEnum[]
  }

  /**
   * User.claims
   */
  export type User$claimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * User.evidence
   */
  export type User$evidenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    where?: EvidenceWhereInput
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    cursor?: EvidenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[]
  }

  /**
   * User.actionItems
   */
  export type User$actionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    where?: ActionItemWhereInput
    orderBy?: ActionItemOrderByWithRelationInput | ActionItemOrderByWithRelationInput[]
    cursor?: ActionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActionItemScalarFieldEnum | ActionItemScalarFieldEnum[]
  }

  /**
   * User.filesUploaded
   */
  export type User$filesUploadedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    where?: FileMetadataWhereInput
    orderBy?: FileMetadataOrderByWithRelationInput | FileMetadataOrderByWithRelationInput[]
    cursor?: FileMetadataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileMetadataScalarFieldEnum | FileMetadataScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionData
     */
    select?: SessionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionData
     */
    omit?: SessionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDataInclude<ExtArgs> | null
    where?: SessionDataWhereInput
    orderBy?: SessionDataOrderByWithRelationInput | SessionDataOrderByWithRelationInput[]
    cursor?: SessionDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionDataScalarFieldEnum | SessionDataScalarFieldEnum[]
  }

  /**
   * User.mfaSettings
   */
  export type User$mfaSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaSettings
     */
    select?: MfaSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaSettings
     */
    omit?: MfaSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaSettingsInclude<ExtArgs> | null
    where?: MfaSettingsWhereInput
  }

  /**
   * User.passwordResets
   */
  export type User$passwordResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    cursor?: PasswordResetTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    contractValue: Decimal | null
    healthScore: number | null
  }

  export type ProjectSumAggregateOutputType = {
    contractValue: Decimal | null
    healthScore: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    location: string | null
    organizationId: string | null
    status: $Enums.ProjectStatus | null
    contractValue: Decimal | null
    contractType: $Enums.ContractType | null
    startDate: Date | null
    plannedCompletion: Date | null
    currentCompletion: Date | null
    healthScore: number | null
    projectManagerId: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    location: string | null
    organizationId: string | null
    status: $Enums.ProjectStatus | null
    contractValue: Decimal | null
    contractType: $Enums.ContractType | null
    startDate: Date | null
    plannedCompletion: Date | null
    currentCompletion: Date | null
    healthScore: number | null
    projectManagerId: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    location: number
    organizationId: number
    status: number
    contractValue: number
    contractType: number
    startDate: number
    plannedCompletion: number
    currentCompletion: number
    healthScore: number
    projectManagerId: number
    metadata: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    contractValue?: true
    healthScore?: true
  }

  export type ProjectSumAggregateInputType = {
    contractValue?: true
    healthScore?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    location?: true
    organizationId?: true
    status?: true
    contractValue?: true
    contractType?: true
    startDate?: true
    plannedCompletion?: true
    currentCompletion?: true
    healthScore?: true
    projectManagerId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    location?: true
    organizationId?: true
    status?: true
    contractValue?: true
    contractType?: true
    startDate?: true
    plannedCompletion?: true
    currentCompletion?: true
    healthScore?: true
    projectManagerId?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    location?: true
    organizationId?: true
    status?: true
    contractValue?: true
    contractType?: true
    startDate?: true
    plannedCompletion?: true
    currentCompletion?: true
    healthScore?: true
    projectManagerId?: true
    metadata?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    description: string | null
    location: string | null
    organizationId: string
    status: $Enums.ProjectStatus
    contractValue: Decimal | null
    contractType: $Enums.ContractType | null
    startDate: Date
    plannedCompletion: Date | null
    currentCompletion: Date | null
    healthScore: number | null
    projectManagerId: string | null
    metadata: JsonValue | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    organizationId?: boolean
    status?: boolean
    contractValue?: boolean
    contractType?: boolean
    startDate?: boolean
    plannedCompletion?: boolean
    currentCompletion?: boolean
    healthScore?: boolean
    projectManagerId?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    projectManager?: boolean | Project$projectManagerArgs<ExtArgs>
    delayEvents?: boolean | Project$delayEventsArgs<ExtArgs>
    claims?: boolean | Project$claimsArgs<ExtArgs>
    actionItems?: boolean | Project$actionItemsArgs<ExtArgs>
    schedules?: boolean | Project$schedulesArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    organizationId?: boolean
    status?: boolean
    contractValue?: boolean
    contractType?: boolean
    startDate?: boolean
    plannedCompletion?: boolean
    currentCompletion?: boolean
    healthScore?: boolean
    projectManagerId?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    projectManager?: boolean | Project$projectManagerArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    organizationId?: boolean
    status?: boolean
    contractValue?: boolean
    contractType?: boolean
    startDate?: boolean
    plannedCompletion?: boolean
    currentCompletion?: boolean
    healthScore?: boolean
    projectManagerId?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    projectManager?: boolean | Project$projectManagerArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    location?: boolean
    organizationId?: boolean
    status?: boolean
    contractValue?: boolean
    contractType?: boolean
    startDate?: boolean
    plannedCompletion?: boolean
    currentCompletion?: boolean
    healthScore?: boolean
    projectManagerId?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "location" | "organizationId" | "status" | "contractValue" | "contractType" | "startDate" | "plannedCompletion" | "currentCompletion" | "healthScore" | "projectManagerId" | "metadata" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    projectManager?: boolean | Project$projectManagerArgs<ExtArgs>
    delayEvents?: boolean | Project$delayEventsArgs<ExtArgs>
    claims?: boolean | Project$claimsArgs<ExtArgs>
    actionItems?: boolean | Project$actionItemsArgs<ExtArgs>
    schedules?: boolean | Project$schedulesArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    projectManager?: boolean | Project$projectManagerArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    projectManager?: boolean | Project$projectManagerArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      projectManager: Prisma.$UserPayload<ExtArgs> | null
      delayEvents: Prisma.$DelayEventPayload<ExtArgs>[]
      claims: Prisma.$ClaimPayload<ExtArgs>[]
      actionItems: Prisma.$ActionItemPayload<ExtArgs>[]
      schedules: Prisma.$SchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      location: string | null
      organizationId: string
      status: $Enums.ProjectStatus
      contractValue: Prisma.Decimal | null
      contractType: $Enums.ContractType | null
      startDate: Date
      plannedCompletion: Date | null
      currentCompletion: Date | null
      healthScore: number | null
      projectManagerId: string | null
      metadata: Prisma.JsonValue | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projectManager<T extends Project$projectManagerArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectManagerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    delayEvents<T extends Project$delayEventsArgs<ExtArgs> = {}>(args?: Subset<T, Project$delayEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DelayEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    claims<T extends Project$claimsArgs<ExtArgs> = {}>(args?: Subset<T, Project$claimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    actionItems<T extends Project$actionItemsArgs<ExtArgs> = {}>(args?: Subset<T, Project$actionItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schedules<T extends Project$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Project$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly location: FieldRef<"Project", 'String'>
    readonly organizationId: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'ProjectStatus'>
    readonly contractValue: FieldRef<"Project", 'Decimal'>
    readonly contractType: FieldRef<"Project", 'ContractType'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly plannedCompletion: FieldRef<"Project", 'DateTime'>
    readonly currentCompletion: FieldRef<"Project", 'DateTime'>
    readonly healthScore: FieldRef<"Project", 'Int'>
    readonly projectManagerId: FieldRef<"Project", 'String'>
    readonly metadata: FieldRef<"Project", 'Json'>
    readonly isDeleted: FieldRef<"Project", 'Boolean'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.projectManager
   */
  export type Project$projectManagerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Project.delayEvents
   */
  export type Project$delayEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DelayEvent
     */
    select?: DelayEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DelayEvent
     */
    omit?: DelayEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelayEventInclude<ExtArgs> | null
    where?: DelayEventWhereInput
    orderBy?: DelayEventOrderByWithRelationInput | DelayEventOrderByWithRelationInput[]
    cursor?: DelayEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DelayEventScalarFieldEnum | DelayEventScalarFieldEnum[]
  }

  /**
   * Project.claims
   */
  export type Project$claimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Project.actionItems
   */
  export type Project$actionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    where?: ActionItemWhereInput
    orderBy?: ActionItemOrderByWithRelationInput | ActionItemOrderByWithRelationInput[]
    cursor?: ActionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActionItemScalarFieldEnum | ActionItemScalarFieldEnum[]
  }

  /**
   * Project.schedules
   */
  export type Project$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model DelayEvent
   */

  export type AggregateDelayEvent = {
    _count: DelayEventCountAggregateOutputType | null
    _avg: DelayEventAvgAggregateOutputType | null
    _sum: DelayEventSumAggregateOutputType | null
    _min: DelayEventMinAggregateOutputType | null
    _max: DelayEventMaxAggregateOutputType | null
  }

  export type DelayEventAvgAggregateOutputType = {
    delayDays: number | null
    probabilityScore: number | null
    evidenceStrength: number | null
    estimatedCost: Decimal | null
  }

  export type DelayEventSumAggregateOutputType = {
    delayDays: number | null
    probabilityScore: number | null
    evidenceStrength: number | null
    estimatedCost: Decimal | null
  }

  export type DelayEventMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    activityId: string | null
    activityName: string | null
    detectionDate: Date | null
    delayDays: number | null
    causeType: $Enums.DelayType | null
    probabilityScore: number | null
    evidenceStrength: number | null
    status: $Enums.DelayStatus | null
    description: string | null
    estimatedCost: Decimal | null
    criticalPath: boolean | null
    detectedById: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DelayEventMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    activityId: string | null
    activityName: string | null
    detectionDate: Date | null
    delayDays: number | null
    causeType: $Enums.DelayType | null
    probabilityScore: number | null
    evidenceStrength: number | null
    status: $Enums.DelayStatus | null
    description: string | null
    estimatedCost: Decimal | null
    criticalPath: boolean | null
    detectedById: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DelayEventCountAggregateOutputType = {
    id: number
    projectId: number
    activityId: number
    activityName: number
    detectionDate: number
    delayDays: number
    causeType: number
    probabilityScore: number
    evidenceStrength: number
    status: number
    description: number
    estimatedCost: number
    criticalPath: number
    detectedById: number
    metadata: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DelayEventAvgAggregateInputType = {
    delayDays?: true
    probabilityScore?: true
    evidenceStrength?: true
    estimatedCost?: true
  }

  export type DelayEventSumAggregateInputType = {
    delayDays?: true
    probabilityScore?: true
    evidenceStrength?: true
    estimatedCost?: true
  }

  export type DelayEventMinAggregateInputType = {
    id?: true
    projectId?: true
    activityId?: true
    activityName?: true
    detectionDate?: true
    delayDays?: true
    causeType?: true
    probabilityScore?: true
    evidenceStrength?: true
    status?: true
    description?: true
    estimatedCost?: true
    criticalPath?: true
    detectedById?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DelayEventMaxAggregateInputType = {
    id?: true
    projectId?: true
    activityId?: true
    activityName?: true
    detectionDate?: true
    delayDays?: true
    causeType?: true
    probabilityScore?: true
    evidenceStrength?: true
    status?: true
    description?: true
    estimatedCost?: true
    criticalPath?: true
    detectedById?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DelayEventCountAggregateInputType = {
    id?: true
    projectId?: true
    activityId?: true
    activityName?: true
    detectionDate?: true
    delayDays?: true
    causeType?: true
    probabilityScore?: true
    evidenceStrength?: true
    status?: true
    description?: true
    estimatedCost?: true
    criticalPath?: true
    detectedById?: true
    metadata?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DelayEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DelayEvent to aggregate.
     */
    where?: DelayEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DelayEvents to fetch.
     */
    orderBy?: DelayEventOrderByWithRelationInput | DelayEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DelayEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DelayEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DelayEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DelayEvents
    **/
    _count?: true | DelayEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DelayEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DelayEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DelayEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DelayEventMaxAggregateInputType
  }

  export type GetDelayEventAggregateType<T extends DelayEventAggregateArgs> = {
        [P in keyof T & keyof AggregateDelayEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDelayEvent[P]>
      : GetScalarType<T[P], AggregateDelayEvent[P]>
  }




  export type DelayEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DelayEventWhereInput
    orderBy?: DelayEventOrderByWithAggregationInput | DelayEventOrderByWithAggregationInput[]
    by: DelayEventScalarFieldEnum[] | DelayEventScalarFieldEnum
    having?: DelayEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DelayEventCountAggregateInputType | true
    _avg?: DelayEventAvgAggregateInputType
    _sum?: DelayEventSumAggregateInputType
    _min?: DelayEventMinAggregateInputType
    _max?: DelayEventMaxAggregateInputType
  }

  export type DelayEventGroupByOutputType = {
    id: string
    projectId: string
    activityId: string | null
    activityName: string
    detectionDate: Date
    delayDays: number
    causeType: $Enums.DelayType
    probabilityScore: number | null
    evidenceStrength: number | null
    status: $Enums.DelayStatus
    description: string | null
    estimatedCost: Decimal | null
    criticalPath: boolean
    detectedById: string
    metadata: JsonValue | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: DelayEventCountAggregateOutputType | null
    _avg: DelayEventAvgAggregateOutputType | null
    _sum: DelayEventSumAggregateOutputType | null
    _min: DelayEventMinAggregateOutputType | null
    _max: DelayEventMaxAggregateOutputType | null
  }

  type GetDelayEventGroupByPayload<T extends DelayEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DelayEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DelayEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DelayEventGroupByOutputType[P]>
            : GetScalarType<T[P], DelayEventGroupByOutputType[P]>
        }
      >
    >


  export type DelayEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    activityId?: boolean
    activityName?: boolean
    detectionDate?: boolean
    delayDays?: boolean
    causeType?: boolean
    probabilityScore?: boolean
    evidenceStrength?: boolean
    status?: boolean
    description?: boolean
    estimatedCost?: boolean
    criticalPath?: boolean
    detectedById?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    detectedBy?: boolean | UserDefaultArgs<ExtArgs>
    claims?: boolean | DelayEvent$claimsArgs<ExtArgs>
    evidence?: boolean | DelayEvent$evidenceArgs<ExtArgs>
    _count?: boolean | DelayEventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delayEvent"]>

  export type DelayEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    activityId?: boolean
    activityName?: boolean
    detectionDate?: boolean
    delayDays?: boolean
    causeType?: boolean
    probabilityScore?: boolean
    evidenceStrength?: boolean
    status?: boolean
    description?: boolean
    estimatedCost?: boolean
    criticalPath?: boolean
    detectedById?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    detectedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delayEvent"]>

  export type DelayEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    activityId?: boolean
    activityName?: boolean
    detectionDate?: boolean
    delayDays?: boolean
    causeType?: boolean
    probabilityScore?: boolean
    evidenceStrength?: boolean
    status?: boolean
    description?: boolean
    estimatedCost?: boolean
    criticalPath?: boolean
    detectedById?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    detectedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["delayEvent"]>

  export type DelayEventSelectScalar = {
    id?: boolean
    projectId?: boolean
    activityId?: boolean
    activityName?: boolean
    detectionDate?: boolean
    delayDays?: boolean
    causeType?: boolean
    probabilityScore?: boolean
    evidenceStrength?: boolean
    status?: boolean
    description?: boolean
    estimatedCost?: boolean
    criticalPath?: boolean
    detectedById?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DelayEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "activityId" | "activityName" | "detectionDate" | "delayDays" | "causeType" | "probabilityScore" | "evidenceStrength" | "status" | "description" | "estimatedCost" | "criticalPath" | "detectedById" | "metadata" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["delayEvent"]>
  export type DelayEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    detectedBy?: boolean | UserDefaultArgs<ExtArgs>
    claims?: boolean | DelayEvent$claimsArgs<ExtArgs>
    evidence?: boolean | DelayEvent$evidenceArgs<ExtArgs>
    _count?: boolean | DelayEventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DelayEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    detectedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DelayEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    detectedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DelayEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DelayEvent"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      detectedBy: Prisma.$UserPayload<ExtArgs>
      claims: Prisma.$ClaimPayload<ExtArgs>[]
      evidence: Prisma.$EvidencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      activityId: string | null
      activityName: string
      detectionDate: Date
      delayDays: number
      causeType: $Enums.DelayType
      probabilityScore: number | null
      evidenceStrength: number | null
      status: $Enums.DelayStatus
      description: string | null
      estimatedCost: Prisma.Decimal | null
      criticalPath: boolean
      detectedById: string
      metadata: Prisma.JsonValue | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["delayEvent"]>
    composites: {}
  }

  type DelayEventGetPayload<S extends boolean | null | undefined | DelayEventDefaultArgs> = $Result.GetResult<Prisma.$DelayEventPayload, S>

  type DelayEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DelayEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DelayEventCountAggregateInputType | true
    }

  export interface DelayEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DelayEvent'], meta: { name: 'DelayEvent' } }
    /**
     * Find zero or one DelayEvent that matches the filter.
     * @param {DelayEventFindUniqueArgs} args - Arguments to find a DelayEvent
     * @example
     * // Get one DelayEvent
     * const delayEvent = await prisma.delayEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DelayEventFindUniqueArgs>(args: SelectSubset<T, DelayEventFindUniqueArgs<ExtArgs>>): Prisma__DelayEventClient<$Result.GetResult<Prisma.$DelayEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DelayEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DelayEventFindUniqueOrThrowArgs} args - Arguments to find a DelayEvent
     * @example
     * // Get one DelayEvent
     * const delayEvent = await prisma.delayEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DelayEventFindUniqueOrThrowArgs>(args: SelectSubset<T, DelayEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DelayEventClient<$Result.GetResult<Prisma.$DelayEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DelayEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelayEventFindFirstArgs} args - Arguments to find a DelayEvent
     * @example
     * // Get one DelayEvent
     * const delayEvent = await prisma.delayEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DelayEventFindFirstArgs>(args?: SelectSubset<T, DelayEventFindFirstArgs<ExtArgs>>): Prisma__DelayEventClient<$Result.GetResult<Prisma.$DelayEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DelayEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelayEventFindFirstOrThrowArgs} args - Arguments to find a DelayEvent
     * @example
     * // Get one DelayEvent
     * const delayEvent = await prisma.delayEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DelayEventFindFirstOrThrowArgs>(args?: SelectSubset<T, DelayEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__DelayEventClient<$Result.GetResult<Prisma.$DelayEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DelayEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelayEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DelayEvents
     * const delayEvents = await prisma.delayEvent.findMany()
     * 
     * // Get first 10 DelayEvents
     * const delayEvents = await prisma.delayEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const delayEventWithIdOnly = await prisma.delayEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DelayEventFindManyArgs>(args?: SelectSubset<T, DelayEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DelayEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DelayEvent.
     * @param {DelayEventCreateArgs} args - Arguments to create a DelayEvent.
     * @example
     * // Create one DelayEvent
     * const DelayEvent = await prisma.delayEvent.create({
     *   data: {
     *     // ... data to create a DelayEvent
     *   }
     * })
     * 
     */
    create<T extends DelayEventCreateArgs>(args: SelectSubset<T, DelayEventCreateArgs<ExtArgs>>): Prisma__DelayEventClient<$Result.GetResult<Prisma.$DelayEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DelayEvents.
     * @param {DelayEventCreateManyArgs} args - Arguments to create many DelayEvents.
     * @example
     * // Create many DelayEvents
     * const delayEvent = await prisma.delayEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DelayEventCreateManyArgs>(args?: SelectSubset<T, DelayEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DelayEvents and returns the data saved in the database.
     * @param {DelayEventCreateManyAndReturnArgs} args - Arguments to create many DelayEvents.
     * @example
     * // Create many DelayEvents
     * const delayEvent = await prisma.delayEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DelayEvents and only return the `id`
     * const delayEventWithIdOnly = await prisma.delayEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DelayEventCreateManyAndReturnArgs>(args?: SelectSubset<T, DelayEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DelayEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DelayEvent.
     * @param {DelayEventDeleteArgs} args - Arguments to delete one DelayEvent.
     * @example
     * // Delete one DelayEvent
     * const DelayEvent = await prisma.delayEvent.delete({
     *   where: {
     *     // ... filter to delete one DelayEvent
     *   }
     * })
     * 
     */
    delete<T extends DelayEventDeleteArgs>(args: SelectSubset<T, DelayEventDeleteArgs<ExtArgs>>): Prisma__DelayEventClient<$Result.GetResult<Prisma.$DelayEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DelayEvent.
     * @param {DelayEventUpdateArgs} args - Arguments to update one DelayEvent.
     * @example
     * // Update one DelayEvent
     * const delayEvent = await prisma.delayEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DelayEventUpdateArgs>(args: SelectSubset<T, DelayEventUpdateArgs<ExtArgs>>): Prisma__DelayEventClient<$Result.GetResult<Prisma.$DelayEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DelayEvents.
     * @param {DelayEventDeleteManyArgs} args - Arguments to filter DelayEvents to delete.
     * @example
     * // Delete a few DelayEvents
     * const { count } = await prisma.delayEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DelayEventDeleteManyArgs>(args?: SelectSubset<T, DelayEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DelayEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelayEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DelayEvents
     * const delayEvent = await prisma.delayEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DelayEventUpdateManyArgs>(args: SelectSubset<T, DelayEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DelayEvents and returns the data updated in the database.
     * @param {DelayEventUpdateManyAndReturnArgs} args - Arguments to update many DelayEvents.
     * @example
     * // Update many DelayEvents
     * const delayEvent = await prisma.delayEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DelayEvents and only return the `id`
     * const delayEventWithIdOnly = await prisma.delayEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DelayEventUpdateManyAndReturnArgs>(args: SelectSubset<T, DelayEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DelayEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DelayEvent.
     * @param {DelayEventUpsertArgs} args - Arguments to update or create a DelayEvent.
     * @example
     * // Update or create a DelayEvent
     * const delayEvent = await prisma.delayEvent.upsert({
     *   create: {
     *     // ... data to create a DelayEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DelayEvent we want to update
     *   }
     * })
     */
    upsert<T extends DelayEventUpsertArgs>(args: SelectSubset<T, DelayEventUpsertArgs<ExtArgs>>): Prisma__DelayEventClient<$Result.GetResult<Prisma.$DelayEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DelayEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelayEventCountArgs} args - Arguments to filter DelayEvents to count.
     * @example
     * // Count the number of DelayEvents
     * const count = await prisma.delayEvent.count({
     *   where: {
     *     // ... the filter for the DelayEvents we want to count
     *   }
     * })
    **/
    count<T extends DelayEventCountArgs>(
      args?: Subset<T, DelayEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DelayEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DelayEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelayEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DelayEventAggregateArgs>(args: Subset<T, DelayEventAggregateArgs>): Prisma.PrismaPromise<GetDelayEventAggregateType<T>>

    /**
     * Group by DelayEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DelayEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DelayEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DelayEventGroupByArgs['orderBy'] }
        : { orderBy?: DelayEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DelayEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDelayEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DelayEvent model
   */
  readonly fields: DelayEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DelayEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DelayEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    detectedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    claims<T extends DelayEvent$claimsArgs<ExtArgs> = {}>(args?: Subset<T, DelayEvent$claimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    evidence<T extends DelayEvent$evidenceArgs<ExtArgs> = {}>(args?: Subset<T, DelayEvent$evidenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DelayEvent model
   */
  interface DelayEventFieldRefs {
    readonly id: FieldRef<"DelayEvent", 'String'>
    readonly projectId: FieldRef<"DelayEvent", 'String'>
    readonly activityId: FieldRef<"DelayEvent", 'String'>
    readonly activityName: FieldRef<"DelayEvent", 'String'>
    readonly detectionDate: FieldRef<"DelayEvent", 'DateTime'>
    readonly delayDays: FieldRef<"DelayEvent", 'Int'>
    readonly causeType: FieldRef<"DelayEvent", 'DelayType'>
    readonly probabilityScore: FieldRef<"DelayEvent", 'Int'>
    readonly evidenceStrength: FieldRef<"DelayEvent", 'Int'>
    readonly status: FieldRef<"DelayEvent", 'DelayStatus'>
    readonly description: FieldRef<"DelayEvent", 'String'>
    readonly estimatedCost: FieldRef<"DelayEvent", 'Decimal'>
    readonly criticalPath: FieldRef<"DelayEvent", 'Boolean'>
    readonly detectedById: FieldRef<"DelayEvent", 'String'>
    readonly metadata: FieldRef<"DelayEvent", 'Json'>
    readonly isDeleted: FieldRef<"DelayEvent", 'Boolean'>
    readonly createdAt: FieldRef<"DelayEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"DelayEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DelayEvent findUnique
   */
  export type DelayEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DelayEvent
     */
    select?: DelayEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DelayEvent
     */
    omit?: DelayEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelayEventInclude<ExtArgs> | null
    /**
     * Filter, which DelayEvent to fetch.
     */
    where: DelayEventWhereUniqueInput
  }

  /**
   * DelayEvent findUniqueOrThrow
   */
  export type DelayEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DelayEvent
     */
    select?: DelayEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DelayEvent
     */
    omit?: DelayEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelayEventInclude<ExtArgs> | null
    /**
     * Filter, which DelayEvent to fetch.
     */
    where: DelayEventWhereUniqueInput
  }

  /**
   * DelayEvent findFirst
   */
  export type DelayEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DelayEvent
     */
    select?: DelayEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DelayEvent
     */
    omit?: DelayEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelayEventInclude<ExtArgs> | null
    /**
     * Filter, which DelayEvent to fetch.
     */
    where?: DelayEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DelayEvents to fetch.
     */
    orderBy?: DelayEventOrderByWithRelationInput | DelayEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DelayEvents.
     */
    cursor?: DelayEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DelayEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DelayEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DelayEvents.
     */
    distinct?: DelayEventScalarFieldEnum | DelayEventScalarFieldEnum[]
  }

  /**
   * DelayEvent findFirstOrThrow
   */
  export type DelayEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DelayEvent
     */
    select?: DelayEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DelayEvent
     */
    omit?: DelayEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelayEventInclude<ExtArgs> | null
    /**
     * Filter, which DelayEvent to fetch.
     */
    where?: DelayEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DelayEvents to fetch.
     */
    orderBy?: DelayEventOrderByWithRelationInput | DelayEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DelayEvents.
     */
    cursor?: DelayEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DelayEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DelayEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DelayEvents.
     */
    distinct?: DelayEventScalarFieldEnum | DelayEventScalarFieldEnum[]
  }

  /**
   * DelayEvent findMany
   */
  export type DelayEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DelayEvent
     */
    select?: DelayEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DelayEvent
     */
    omit?: DelayEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelayEventInclude<ExtArgs> | null
    /**
     * Filter, which DelayEvents to fetch.
     */
    where?: DelayEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DelayEvents to fetch.
     */
    orderBy?: DelayEventOrderByWithRelationInput | DelayEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DelayEvents.
     */
    cursor?: DelayEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DelayEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DelayEvents.
     */
    skip?: number
    distinct?: DelayEventScalarFieldEnum | DelayEventScalarFieldEnum[]
  }

  /**
   * DelayEvent create
   */
  export type DelayEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DelayEvent
     */
    select?: DelayEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DelayEvent
     */
    omit?: DelayEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelayEventInclude<ExtArgs> | null
    /**
     * The data needed to create a DelayEvent.
     */
    data: XOR<DelayEventCreateInput, DelayEventUncheckedCreateInput>
  }

  /**
   * DelayEvent createMany
   */
  export type DelayEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DelayEvents.
     */
    data: DelayEventCreateManyInput | DelayEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DelayEvent createManyAndReturn
   */
  export type DelayEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DelayEvent
     */
    select?: DelayEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DelayEvent
     */
    omit?: DelayEventOmit<ExtArgs> | null
    /**
     * The data used to create many DelayEvents.
     */
    data: DelayEventCreateManyInput | DelayEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelayEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DelayEvent update
   */
  export type DelayEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DelayEvent
     */
    select?: DelayEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DelayEvent
     */
    omit?: DelayEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelayEventInclude<ExtArgs> | null
    /**
     * The data needed to update a DelayEvent.
     */
    data: XOR<DelayEventUpdateInput, DelayEventUncheckedUpdateInput>
    /**
     * Choose, which DelayEvent to update.
     */
    where: DelayEventWhereUniqueInput
  }

  /**
   * DelayEvent updateMany
   */
  export type DelayEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DelayEvents.
     */
    data: XOR<DelayEventUpdateManyMutationInput, DelayEventUncheckedUpdateManyInput>
    /**
     * Filter which DelayEvents to update
     */
    where?: DelayEventWhereInput
    /**
     * Limit how many DelayEvents to update.
     */
    limit?: number
  }

  /**
   * DelayEvent updateManyAndReturn
   */
  export type DelayEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DelayEvent
     */
    select?: DelayEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DelayEvent
     */
    omit?: DelayEventOmit<ExtArgs> | null
    /**
     * The data used to update DelayEvents.
     */
    data: XOR<DelayEventUpdateManyMutationInput, DelayEventUncheckedUpdateManyInput>
    /**
     * Filter which DelayEvents to update
     */
    where?: DelayEventWhereInput
    /**
     * Limit how many DelayEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelayEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DelayEvent upsert
   */
  export type DelayEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DelayEvent
     */
    select?: DelayEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DelayEvent
     */
    omit?: DelayEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelayEventInclude<ExtArgs> | null
    /**
     * The filter to search for the DelayEvent to update in case it exists.
     */
    where: DelayEventWhereUniqueInput
    /**
     * In case the DelayEvent found by the `where` argument doesn't exist, create a new DelayEvent with this data.
     */
    create: XOR<DelayEventCreateInput, DelayEventUncheckedCreateInput>
    /**
     * In case the DelayEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DelayEventUpdateInput, DelayEventUncheckedUpdateInput>
  }

  /**
   * DelayEvent delete
   */
  export type DelayEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DelayEvent
     */
    select?: DelayEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DelayEvent
     */
    omit?: DelayEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelayEventInclude<ExtArgs> | null
    /**
     * Filter which DelayEvent to delete.
     */
    where: DelayEventWhereUniqueInput
  }

  /**
   * DelayEvent deleteMany
   */
  export type DelayEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DelayEvents to delete
     */
    where?: DelayEventWhereInput
    /**
     * Limit how many DelayEvents to delete.
     */
    limit?: number
  }

  /**
   * DelayEvent.claims
   */
  export type DelayEvent$claimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * DelayEvent.evidence
   */
  export type DelayEvent$evidenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    where?: EvidenceWhereInput
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    cursor?: EvidenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[]
  }

  /**
   * DelayEvent without action
   */
  export type DelayEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DelayEvent
     */
    select?: DelayEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DelayEvent
     */
    omit?: DelayEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelayEventInclude<ExtArgs> | null
  }


  /**
   * Model Claim
   */

  export type AggregateClaim = {
    _count: ClaimCountAggregateOutputType | null
    _avg: ClaimAvgAggregateOutputType | null
    _sum: ClaimSumAggregateOutputType | null
    _min: ClaimMinAggregateOutputType | null
    _max: ClaimMaxAggregateOutputType | null
  }

  export type ClaimAvgAggregateOutputType = {
    claimAmount: Decimal | null
    timeImpactDays: number | null
  }

  export type ClaimSumAggregateOutputType = {
    claimAmount: Decimal | null
    timeImpactDays: number | null
  }

  export type ClaimMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    delayEventId: string | null
    referenceNumber: string | null
    title: string | null
    description: string | null
    submissionDate: Date | null
    noticeDate: Date | null
    claimAmount: Decimal | null
    timeImpactDays: number | null
    status: $Enums.ClaimStatus | null
    responseDueDate: Date | null
    submittedById: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClaimMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    delayEventId: string | null
    referenceNumber: string | null
    title: string | null
    description: string | null
    submissionDate: Date | null
    noticeDate: Date | null
    claimAmount: Decimal | null
    timeImpactDays: number | null
    status: $Enums.ClaimStatus | null
    responseDueDate: Date | null
    submittedById: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClaimCountAggregateOutputType = {
    id: number
    projectId: number
    delayEventId: number
    referenceNumber: number
    title: number
    description: number
    submissionDate: number
    noticeDate: number
    claimAmount: number
    timeImpactDays: number
    status: number
    responseDueDate: number
    submittedById: number
    workflow: number
    metadata: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClaimAvgAggregateInputType = {
    claimAmount?: true
    timeImpactDays?: true
  }

  export type ClaimSumAggregateInputType = {
    claimAmount?: true
    timeImpactDays?: true
  }

  export type ClaimMinAggregateInputType = {
    id?: true
    projectId?: true
    delayEventId?: true
    referenceNumber?: true
    title?: true
    description?: true
    submissionDate?: true
    noticeDate?: true
    claimAmount?: true
    timeImpactDays?: true
    status?: true
    responseDueDate?: true
    submittedById?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClaimMaxAggregateInputType = {
    id?: true
    projectId?: true
    delayEventId?: true
    referenceNumber?: true
    title?: true
    description?: true
    submissionDate?: true
    noticeDate?: true
    claimAmount?: true
    timeImpactDays?: true
    status?: true
    responseDueDate?: true
    submittedById?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClaimCountAggregateInputType = {
    id?: true
    projectId?: true
    delayEventId?: true
    referenceNumber?: true
    title?: true
    description?: true
    submissionDate?: true
    noticeDate?: true
    claimAmount?: true
    timeImpactDays?: true
    status?: true
    responseDueDate?: true
    submittedById?: true
    workflow?: true
    metadata?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClaimAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Claim to aggregate.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Claims
    **/
    _count?: true | ClaimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClaimAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClaimSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaimMaxAggregateInputType
  }

  export type GetClaimAggregateType<T extends ClaimAggregateArgs> = {
        [P in keyof T & keyof AggregateClaim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClaim[P]>
      : GetScalarType<T[P], AggregateClaim[P]>
  }




  export type ClaimGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithAggregationInput | ClaimOrderByWithAggregationInput[]
    by: ClaimScalarFieldEnum[] | ClaimScalarFieldEnum
    having?: ClaimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaimCountAggregateInputType | true
    _avg?: ClaimAvgAggregateInputType
    _sum?: ClaimSumAggregateInputType
    _min?: ClaimMinAggregateInputType
    _max?: ClaimMaxAggregateInputType
  }

  export type ClaimGroupByOutputType = {
    id: string
    projectId: string
    delayEventId: string | null
    referenceNumber: string
    title: string
    description: string | null
    submissionDate: Date | null
    noticeDate: Date | null
    claimAmount: Decimal | null
    timeImpactDays: number | null
    status: $Enums.ClaimStatus
    responseDueDate: Date | null
    submittedById: string | null
    workflow: JsonValue | null
    metadata: JsonValue | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: ClaimCountAggregateOutputType | null
    _avg: ClaimAvgAggregateOutputType | null
    _sum: ClaimSumAggregateOutputType | null
    _min: ClaimMinAggregateOutputType | null
    _max: ClaimMaxAggregateOutputType | null
  }

  type GetClaimGroupByPayload<T extends ClaimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClaimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaimGroupByOutputType[P]>
            : GetScalarType<T[P], ClaimGroupByOutputType[P]>
        }
      >
    >


  export type ClaimSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    delayEventId?: boolean
    referenceNumber?: boolean
    title?: boolean
    description?: boolean
    submissionDate?: boolean
    noticeDate?: boolean
    claimAmount?: boolean
    timeImpactDays?: boolean
    status?: boolean
    responseDueDate?: boolean
    submittedById?: boolean
    workflow?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    delayEvent?: boolean | Claim$delayEventArgs<ExtArgs>
    submittedBy?: boolean | Claim$submittedByArgs<ExtArgs>
    evidence?: boolean | Claim$evidenceArgs<ExtArgs>
    _count?: boolean | ClaimCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claim"]>

  export type ClaimSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    delayEventId?: boolean
    referenceNumber?: boolean
    title?: boolean
    description?: boolean
    submissionDate?: boolean
    noticeDate?: boolean
    claimAmount?: boolean
    timeImpactDays?: boolean
    status?: boolean
    responseDueDate?: boolean
    submittedById?: boolean
    workflow?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    delayEvent?: boolean | Claim$delayEventArgs<ExtArgs>
    submittedBy?: boolean | Claim$submittedByArgs<ExtArgs>
  }, ExtArgs["result"]["claim"]>

  export type ClaimSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    delayEventId?: boolean
    referenceNumber?: boolean
    title?: boolean
    description?: boolean
    submissionDate?: boolean
    noticeDate?: boolean
    claimAmount?: boolean
    timeImpactDays?: boolean
    status?: boolean
    responseDueDate?: boolean
    submittedById?: boolean
    workflow?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    delayEvent?: boolean | Claim$delayEventArgs<ExtArgs>
    submittedBy?: boolean | Claim$submittedByArgs<ExtArgs>
  }, ExtArgs["result"]["claim"]>

  export type ClaimSelectScalar = {
    id?: boolean
    projectId?: boolean
    delayEventId?: boolean
    referenceNumber?: boolean
    title?: boolean
    description?: boolean
    submissionDate?: boolean
    noticeDate?: boolean
    claimAmount?: boolean
    timeImpactDays?: boolean
    status?: boolean
    responseDueDate?: boolean
    submittedById?: boolean
    workflow?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClaimOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "delayEventId" | "referenceNumber" | "title" | "description" | "submissionDate" | "noticeDate" | "claimAmount" | "timeImpactDays" | "status" | "responseDueDate" | "submittedById" | "workflow" | "metadata" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["claim"]>
  export type ClaimInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    delayEvent?: boolean | Claim$delayEventArgs<ExtArgs>
    submittedBy?: boolean | Claim$submittedByArgs<ExtArgs>
    evidence?: boolean | Claim$evidenceArgs<ExtArgs>
    _count?: boolean | ClaimCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClaimIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    delayEvent?: boolean | Claim$delayEventArgs<ExtArgs>
    submittedBy?: boolean | Claim$submittedByArgs<ExtArgs>
  }
  export type ClaimIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    delayEvent?: boolean | Claim$delayEventArgs<ExtArgs>
    submittedBy?: boolean | Claim$submittedByArgs<ExtArgs>
  }

  export type $ClaimPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Claim"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      delayEvent: Prisma.$DelayEventPayload<ExtArgs> | null
      submittedBy: Prisma.$UserPayload<ExtArgs> | null
      evidence: Prisma.$EvidencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      delayEventId: string | null
      referenceNumber: string
      title: string
      description: string | null
      submissionDate: Date | null
      noticeDate: Date | null
      claimAmount: Prisma.Decimal | null
      timeImpactDays: number | null
      status: $Enums.ClaimStatus
      responseDueDate: Date | null
      submittedById: string | null
      workflow: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["claim"]>
    composites: {}
  }

  type ClaimGetPayload<S extends boolean | null | undefined | ClaimDefaultArgs> = $Result.GetResult<Prisma.$ClaimPayload, S>

  type ClaimCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClaimFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClaimCountAggregateInputType | true
    }

  export interface ClaimDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Claim'], meta: { name: 'Claim' } }
    /**
     * Find zero or one Claim that matches the filter.
     * @param {ClaimFindUniqueArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClaimFindUniqueArgs>(args: SelectSubset<T, ClaimFindUniqueArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Claim that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClaimFindUniqueOrThrowArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClaimFindUniqueOrThrowArgs>(args: SelectSubset<T, ClaimFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Claim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindFirstArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClaimFindFirstArgs>(args?: SelectSubset<T, ClaimFindFirstArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Claim that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindFirstOrThrowArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClaimFindFirstOrThrowArgs>(args?: SelectSubset<T, ClaimFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Claims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Claims
     * const claims = await prisma.claim.findMany()
     * 
     * // Get first 10 Claims
     * const claims = await prisma.claim.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claimWithIdOnly = await prisma.claim.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClaimFindManyArgs>(args?: SelectSubset<T, ClaimFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Claim.
     * @param {ClaimCreateArgs} args - Arguments to create a Claim.
     * @example
     * // Create one Claim
     * const Claim = await prisma.claim.create({
     *   data: {
     *     // ... data to create a Claim
     *   }
     * })
     * 
     */
    create<T extends ClaimCreateArgs>(args: SelectSubset<T, ClaimCreateArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Claims.
     * @param {ClaimCreateManyArgs} args - Arguments to create many Claims.
     * @example
     * // Create many Claims
     * const claim = await prisma.claim.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClaimCreateManyArgs>(args?: SelectSubset<T, ClaimCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Claims and returns the data saved in the database.
     * @param {ClaimCreateManyAndReturnArgs} args - Arguments to create many Claims.
     * @example
     * // Create many Claims
     * const claim = await prisma.claim.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Claims and only return the `id`
     * const claimWithIdOnly = await prisma.claim.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClaimCreateManyAndReturnArgs>(args?: SelectSubset<T, ClaimCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Claim.
     * @param {ClaimDeleteArgs} args - Arguments to delete one Claim.
     * @example
     * // Delete one Claim
     * const Claim = await prisma.claim.delete({
     *   where: {
     *     // ... filter to delete one Claim
     *   }
     * })
     * 
     */
    delete<T extends ClaimDeleteArgs>(args: SelectSubset<T, ClaimDeleteArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Claim.
     * @param {ClaimUpdateArgs} args - Arguments to update one Claim.
     * @example
     * // Update one Claim
     * const claim = await prisma.claim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClaimUpdateArgs>(args: SelectSubset<T, ClaimUpdateArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Claims.
     * @param {ClaimDeleteManyArgs} args - Arguments to filter Claims to delete.
     * @example
     * // Delete a few Claims
     * const { count } = await prisma.claim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClaimDeleteManyArgs>(args?: SelectSubset<T, ClaimDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Claims
     * const claim = await prisma.claim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClaimUpdateManyArgs>(args: SelectSubset<T, ClaimUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Claims and returns the data updated in the database.
     * @param {ClaimUpdateManyAndReturnArgs} args - Arguments to update many Claims.
     * @example
     * // Update many Claims
     * const claim = await prisma.claim.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Claims and only return the `id`
     * const claimWithIdOnly = await prisma.claim.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClaimUpdateManyAndReturnArgs>(args: SelectSubset<T, ClaimUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Claim.
     * @param {ClaimUpsertArgs} args - Arguments to update or create a Claim.
     * @example
     * // Update or create a Claim
     * const claim = await prisma.claim.upsert({
     *   create: {
     *     // ... data to create a Claim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Claim we want to update
     *   }
     * })
     */
    upsert<T extends ClaimUpsertArgs>(args: SelectSubset<T, ClaimUpsertArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimCountArgs} args - Arguments to filter Claims to count.
     * @example
     * // Count the number of Claims
     * const count = await prisma.claim.count({
     *   where: {
     *     // ... the filter for the Claims we want to count
     *   }
     * })
    **/
    count<T extends ClaimCountArgs>(
      args?: Subset<T, ClaimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Claim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaimAggregateArgs>(args: Subset<T, ClaimAggregateArgs>): Prisma.PrismaPromise<GetClaimAggregateType<T>>

    /**
     * Group by Claim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClaimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClaimGroupByArgs['orderBy'] }
        : { orderBy?: ClaimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClaimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Claim model
   */
  readonly fields: ClaimFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Claim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClaimClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    delayEvent<T extends Claim$delayEventArgs<ExtArgs> = {}>(args?: Subset<T, Claim$delayEventArgs<ExtArgs>>): Prisma__DelayEventClient<$Result.GetResult<Prisma.$DelayEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    submittedBy<T extends Claim$submittedByArgs<ExtArgs> = {}>(args?: Subset<T, Claim$submittedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    evidence<T extends Claim$evidenceArgs<ExtArgs> = {}>(args?: Subset<T, Claim$evidenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Claim model
   */
  interface ClaimFieldRefs {
    readonly id: FieldRef<"Claim", 'String'>
    readonly projectId: FieldRef<"Claim", 'String'>
    readonly delayEventId: FieldRef<"Claim", 'String'>
    readonly referenceNumber: FieldRef<"Claim", 'String'>
    readonly title: FieldRef<"Claim", 'String'>
    readonly description: FieldRef<"Claim", 'String'>
    readonly submissionDate: FieldRef<"Claim", 'DateTime'>
    readonly noticeDate: FieldRef<"Claim", 'DateTime'>
    readonly claimAmount: FieldRef<"Claim", 'Decimal'>
    readonly timeImpactDays: FieldRef<"Claim", 'Int'>
    readonly status: FieldRef<"Claim", 'ClaimStatus'>
    readonly responseDueDate: FieldRef<"Claim", 'DateTime'>
    readonly submittedById: FieldRef<"Claim", 'String'>
    readonly workflow: FieldRef<"Claim", 'Json'>
    readonly metadata: FieldRef<"Claim", 'Json'>
    readonly isDeleted: FieldRef<"Claim", 'Boolean'>
    readonly createdAt: FieldRef<"Claim", 'DateTime'>
    readonly updatedAt: FieldRef<"Claim", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Claim findUnique
   */
  export type ClaimFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim findUniqueOrThrow
   */
  export type ClaimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim findFirst
   */
  export type ClaimFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claims.
     */
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Claim findFirstOrThrow
   */
  export type ClaimFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claims.
     */
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Claim findMany
   */
  export type ClaimFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claims to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Claim create
   */
  export type ClaimCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The data needed to create a Claim.
     */
    data: XOR<ClaimCreateInput, ClaimUncheckedCreateInput>
  }

  /**
   * Claim createMany
   */
  export type ClaimCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Claims.
     */
    data: ClaimCreateManyInput | ClaimCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Claim createManyAndReturn
   */
  export type ClaimCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * The data used to create many Claims.
     */
    data: ClaimCreateManyInput | ClaimCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Claim update
   */
  export type ClaimUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The data needed to update a Claim.
     */
    data: XOR<ClaimUpdateInput, ClaimUncheckedUpdateInput>
    /**
     * Choose, which Claim to update.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim updateMany
   */
  export type ClaimUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Claims.
     */
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyInput>
    /**
     * Filter which Claims to update
     */
    where?: ClaimWhereInput
    /**
     * Limit how many Claims to update.
     */
    limit?: number
  }

  /**
   * Claim updateManyAndReturn
   */
  export type ClaimUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * The data used to update Claims.
     */
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyInput>
    /**
     * Filter which Claims to update
     */
    where?: ClaimWhereInput
    /**
     * Limit how many Claims to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Claim upsert
   */
  export type ClaimUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The filter to search for the Claim to update in case it exists.
     */
    where: ClaimWhereUniqueInput
    /**
     * In case the Claim found by the `where` argument doesn't exist, create a new Claim with this data.
     */
    create: XOR<ClaimCreateInput, ClaimUncheckedCreateInput>
    /**
     * In case the Claim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClaimUpdateInput, ClaimUncheckedUpdateInput>
  }

  /**
   * Claim delete
   */
  export type ClaimDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter which Claim to delete.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim deleteMany
   */
  export type ClaimDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Claims to delete
     */
    where?: ClaimWhereInput
    /**
     * Limit how many Claims to delete.
     */
    limit?: number
  }

  /**
   * Claim.delayEvent
   */
  export type Claim$delayEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DelayEvent
     */
    select?: DelayEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DelayEvent
     */
    omit?: DelayEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelayEventInclude<ExtArgs> | null
    where?: DelayEventWhereInput
  }

  /**
   * Claim.submittedBy
   */
  export type Claim$submittedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Claim.evidence
   */
  export type Claim$evidenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    where?: EvidenceWhereInput
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    cursor?: EvidenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[]
  }

  /**
   * Claim without action
   */
  export type ClaimDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
  }


  /**
   * Model Evidence
   */

  export type AggregateEvidence = {
    _count: EvidenceCountAggregateOutputType | null
    _avg: EvidenceAvgAggregateOutputType | null
    _sum: EvidenceSumAggregateOutputType | null
    _min: EvidenceMinAggregateOutputType | null
    _max: EvidenceMaxAggregateOutputType | null
  }

  export type EvidenceAvgAggregateOutputType = {
    relevanceScore: number | null
  }

  export type EvidenceSumAggregateOutputType = {
    relevanceScore: number | null
  }

  export type EvidenceMinAggregateOutputType = {
    id: string | null
    delayEventId: string | null
    claimId: string | null
    type: $Enums.EvidenceType | null
    title: string | null
    description: string | null
    sourceSystem: string | null
    filePath: string | null
    fileId: string | null
    relevanceScore: number | null
    extractedText: string | null
    uploadedById: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvidenceMaxAggregateOutputType = {
    id: string | null
    delayEventId: string | null
    claimId: string | null
    type: $Enums.EvidenceType | null
    title: string | null
    description: string | null
    sourceSystem: string | null
    filePath: string | null
    fileId: string | null
    relevanceScore: number | null
    extractedText: string | null
    uploadedById: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EvidenceCountAggregateOutputType = {
    id: number
    delayEventId: number
    claimId: number
    type: number
    title: number
    description: number
    sourceSystem: number
    filePath: number
    fileId: number
    relevanceScore: number
    extractedText: number
    metadata: number
    uploadedById: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EvidenceAvgAggregateInputType = {
    relevanceScore?: true
  }

  export type EvidenceSumAggregateInputType = {
    relevanceScore?: true
  }

  export type EvidenceMinAggregateInputType = {
    id?: true
    delayEventId?: true
    claimId?: true
    type?: true
    title?: true
    description?: true
    sourceSystem?: true
    filePath?: true
    fileId?: true
    relevanceScore?: true
    extractedText?: true
    uploadedById?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvidenceMaxAggregateInputType = {
    id?: true
    delayEventId?: true
    claimId?: true
    type?: true
    title?: true
    description?: true
    sourceSystem?: true
    filePath?: true
    fileId?: true
    relevanceScore?: true
    extractedText?: true
    uploadedById?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EvidenceCountAggregateInputType = {
    id?: true
    delayEventId?: true
    claimId?: true
    type?: true
    title?: true
    description?: true
    sourceSystem?: true
    filePath?: true
    fileId?: true
    relevanceScore?: true
    extractedText?: true
    metadata?: true
    uploadedById?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EvidenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evidence to aggregate.
     */
    where?: EvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidences to fetch.
     */
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evidences
    **/
    _count?: true | EvidenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvidenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvidenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvidenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvidenceMaxAggregateInputType
  }

  export type GetEvidenceAggregateType<T extends EvidenceAggregateArgs> = {
        [P in keyof T & keyof AggregateEvidence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvidence[P]>
      : GetScalarType<T[P], AggregateEvidence[P]>
  }




  export type EvidenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenceWhereInput
    orderBy?: EvidenceOrderByWithAggregationInput | EvidenceOrderByWithAggregationInput[]
    by: EvidenceScalarFieldEnum[] | EvidenceScalarFieldEnum
    having?: EvidenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvidenceCountAggregateInputType | true
    _avg?: EvidenceAvgAggregateInputType
    _sum?: EvidenceSumAggregateInputType
    _min?: EvidenceMinAggregateInputType
    _max?: EvidenceMaxAggregateInputType
  }

  export type EvidenceGroupByOutputType = {
    id: string
    delayEventId: string | null
    claimId: string | null
    type: $Enums.EvidenceType
    title: string
    description: string | null
    sourceSystem: string | null
    filePath: string | null
    fileId: string | null
    relevanceScore: number | null
    extractedText: string | null
    metadata: JsonValue | null
    uploadedById: string
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: EvidenceCountAggregateOutputType | null
    _avg: EvidenceAvgAggregateOutputType | null
    _sum: EvidenceSumAggregateOutputType | null
    _min: EvidenceMinAggregateOutputType | null
    _max: EvidenceMaxAggregateOutputType | null
  }

  type GetEvidenceGroupByPayload<T extends EvidenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvidenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvidenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvidenceGroupByOutputType[P]>
            : GetScalarType<T[P], EvidenceGroupByOutputType[P]>
        }
      >
    >


  export type EvidenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    delayEventId?: boolean
    claimId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    sourceSystem?: boolean
    filePath?: boolean
    fileId?: boolean
    relevanceScore?: boolean
    extractedText?: boolean
    metadata?: boolean
    uploadedById?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    delayEvent?: boolean | Evidence$delayEventArgs<ExtArgs>
    claim?: boolean | Evidence$claimArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    file?: boolean | Evidence$fileArgs<ExtArgs>
  }, ExtArgs["result"]["evidence"]>

  export type EvidenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    delayEventId?: boolean
    claimId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    sourceSystem?: boolean
    filePath?: boolean
    fileId?: boolean
    relevanceScore?: boolean
    extractedText?: boolean
    metadata?: boolean
    uploadedById?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    delayEvent?: boolean | Evidence$delayEventArgs<ExtArgs>
    claim?: boolean | Evidence$claimArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    file?: boolean | Evidence$fileArgs<ExtArgs>
  }, ExtArgs["result"]["evidence"]>

  export type EvidenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    delayEventId?: boolean
    claimId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    sourceSystem?: boolean
    filePath?: boolean
    fileId?: boolean
    relevanceScore?: boolean
    extractedText?: boolean
    metadata?: boolean
    uploadedById?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    delayEvent?: boolean | Evidence$delayEventArgs<ExtArgs>
    claim?: boolean | Evidence$claimArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    file?: boolean | Evidence$fileArgs<ExtArgs>
  }, ExtArgs["result"]["evidence"]>

  export type EvidenceSelectScalar = {
    id?: boolean
    delayEventId?: boolean
    claimId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    sourceSystem?: boolean
    filePath?: boolean
    fileId?: boolean
    relevanceScore?: boolean
    extractedText?: boolean
    metadata?: boolean
    uploadedById?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EvidenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "delayEventId" | "claimId" | "type" | "title" | "description" | "sourceSystem" | "filePath" | "fileId" | "relevanceScore" | "extractedText" | "metadata" | "uploadedById" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["evidence"]>
  export type EvidenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delayEvent?: boolean | Evidence$delayEventArgs<ExtArgs>
    claim?: boolean | Evidence$claimArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    file?: boolean | Evidence$fileArgs<ExtArgs>
  }
  export type EvidenceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delayEvent?: boolean | Evidence$delayEventArgs<ExtArgs>
    claim?: boolean | Evidence$claimArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    file?: boolean | Evidence$fileArgs<ExtArgs>
  }
  export type EvidenceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    delayEvent?: boolean | Evidence$delayEventArgs<ExtArgs>
    claim?: boolean | Evidence$claimArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    file?: boolean | Evidence$fileArgs<ExtArgs>
  }

  export type $EvidencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evidence"
    objects: {
      delayEvent: Prisma.$DelayEventPayload<ExtArgs> | null
      claim: Prisma.$ClaimPayload<ExtArgs> | null
      uploadedBy: Prisma.$UserPayload<ExtArgs>
      file: Prisma.$FileMetadataPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      delayEventId: string | null
      claimId: string | null
      type: $Enums.EvidenceType
      title: string
      description: string | null
      sourceSystem: string | null
      filePath: string | null
      fileId: string | null
      relevanceScore: number | null
      extractedText: string | null
      metadata: Prisma.JsonValue | null
      uploadedById: string
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["evidence"]>
    composites: {}
  }

  type EvidenceGetPayload<S extends boolean | null | undefined | EvidenceDefaultArgs> = $Result.GetResult<Prisma.$EvidencePayload, S>

  type EvidenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EvidenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvidenceCountAggregateInputType | true
    }

  export interface EvidenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evidence'], meta: { name: 'Evidence' } }
    /**
     * Find zero or one Evidence that matches the filter.
     * @param {EvidenceFindUniqueArgs} args - Arguments to find a Evidence
     * @example
     * // Get one Evidence
     * const evidence = await prisma.evidence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvidenceFindUniqueArgs>(args: SelectSubset<T, EvidenceFindUniqueArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Evidence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvidenceFindUniqueOrThrowArgs} args - Arguments to find a Evidence
     * @example
     * // Get one Evidence
     * const evidence = await prisma.evidence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvidenceFindUniqueOrThrowArgs>(args: SelectSubset<T, EvidenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evidence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceFindFirstArgs} args - Arguments to find a Evidence
     * @example
     * // Get one Evidence
     * const evidence = await prisma.evidence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvidenceFindFirstArgs>(args?: SelectSubset<T, EvidenceFindFirstArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evidence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceFindFirstOrThrowArgs} args - Arguments to find a Evidence
     * @example
     * // Get one Evidence
     * const evidence = await prisma.evidence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvidenceFindFirstOrThrowArgs>(args?: SelectSubset<T, EvidenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Evidences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evidences
     * const evidences = await prisma.evidence.findMany()
     * 
     * // Get first 10 Evidences
     * const evidences = await prisma.evidence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evidenceWithIdOnly = await prisma.evidence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvidenceFindManyArgs>(args?: SelectSubset<T, EvidenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Evidence.
     * @param {EvidenceCreateArgs} args - Arguments to create a Evidence.
     * @example
     * // Create one Evidence
     * const Evidence = await prisma.evidence.create({
     *   data: {
     *     // ... data to create a Evidence
     *   }
     * })
     * 
     */
    create<T extends EvidenceCreateArgs>(args: SelectSubset<T, EvidenceCreateArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Evidences.
     * @param {EvidenceCreateManyArgs} args - Arguments to create many Evidences.
     * @example
     * // Create many Evidences
     * const evidence = await prisma.evidence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvidenceCreateManyArgs>(args?: SelectSubset<T, EvidenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Evidences and returns the data saved in the database.
     * @param {EvidenceCreateManyAndReturnArgs} args - Arguments to create many Evidences.
     * @example
     * // Create many Evidences
     * const evidence = await prisma.evidence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Evidences and only return the `id`
     * const evidenceWithIdOnly = await prisma.evidence.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvidenceCreateManyAndReturnArgs>(args?: SelectSubset<T, EvidenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Evidence.
     * @param {EvidenceDeleteArgs} args - Arguments to delete one Evidence.
     * @example
     * // Delete one Evidence
     * const Evidence = await prisma.evidence.delete({
     *   where: {
     *     // ... filter to delete one Evidence
     *   }
     * })
     * 
     */
    delete<T extends EvidenceDeleteArgs>(args: SelectSubset<T, EvidenceDeleteArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Evidence.
     * @param {EvidenceUpdateArgs} args - Arguments to update one Evidence.
     * @example
     * // Update one Evidence
     * const evidence = await prisma.evidence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvidenceUpdateArgs>(args: SelectSubset<T, EvidenceUpdateArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Evidences.
     * @param {EvidenceDeleteManyArgs} args - Arguments to filter Evidences to delete.
     * @example
     * // Delete a few Evidences
     * const { count } = await prisma.evidence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvidenceDeleteManyArgs>(args?: SelectSubset<T, EvidenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evidences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evidences
     * const evidence = await prisma.evidence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvidenceUpdateManyArgs>(args: SelectSubset<T, EvidenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evidences and returns the data updated in the database.
     * @param {EvidenceUpdateManyAndReturnArgs} args - Arguments to update many Evidences.
     * @example
     * // Update many Evidences
     * const evidence = await prisma.evidence.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Evidences and only return the `id`
     * const evidenceWithIdOnly = await prisma.evidence.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EvidenceUpdateManyAndReturnArgs>(args: SelectSubset<T, EvidenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Evidence.
     * @param {EvidenceUpsertArgs} args - Arguments to update or create a Evidence.
     * @example
     * // Update or create a Evidence
     * const evidence = await prisma.evidence.upsert({
     *   create: {
     *     // ... data to create a Evidence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evidence we want to update
     *   }
     * })
     */
    upsert<T extends EvidenceUpsertArgs>(args: SelectSubset<T, EvidenceUpsertArgs<ExtArgs>>): Prisma__EvidenceClient<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Evidences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceCountArgs} args - Arguments to filter Evidences to count.
     * @example
     * // Count the number of Evidences
     * const count = await prisma.evidence.count({
     *   where: {
     *     // ... the filter for the Evidences we want to count
     *   }
     * })
    **/
    count<T extends EvidenceCountArgs>(
      args?: Subset<T, EvidenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvidenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evidence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvidenceAggregateArgs>(args: Subset<T, EvidenceAggregateArgs>): Prisma.PrismaPromise<GetEvidenceAggregateType<T>>

    /**
     * Group by Evidence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvidenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvidenceGroupByArgs['orderBy'] }
        : { orderBy?: EvidenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvidenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvidenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evidence model
   */
  readonly fields: EvidenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evidence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvidenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    delayEvent<T extends Evidence$delayEventArgs<ExtArgs> = {}>(args?: Subset<T, Evidence$delayEventArgs<ExtArgs>>): Prisma__DelayEventClient<$Result.GetResult<Prisma.$DelayEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    claim<T extends Evidence$claimArgs<ExtArgs> = {}>(args?: Subset<T, Evidence$claimArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    file<T extends Evidence$fileArgs<ExtArgs> = {}>(args?: Subset<T, Evidence$fileArgs<ExtArgs>>): Prisma__FileMetadataClient<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evidence model
   */
  interface EvidenceFieldRefs {
    readonly id: FieldRef<"Evidence", 'String'>
    readonly delayEventId: FieldRef<"Evidence", 'String'>
    readonly claimId: FieldRef<"Evidence", 'String'>
    readonly type: FieldRef<"Evidence", 'EvidenceType'>
    readonly title: FieldRef<"Evidence", 'String'>
    readonly description: FieldRef<"Evidence", 'String'>
    readonly sourceSystem: FieldRef<"Evidence", 'String'>
    readonly filePath: FieldRef<"Evidence", 'String'>
    readonly fileId: FieldRef<"Evidence", 'String'>
    readonly relevanceScore: FieldRef<"Evidence", 'Int'>
    readonly extractedText: FieldRef<"Evidence", 'String'>
    readonly metadata: FieldRef<"Evidence", 'Json'>
    readonly uploadedById: FieldRef<"Evidence", 'String'>
    readonly isDeleted: FieldRef<"Evidence", 'Boolean'>
    readonly createdAt: FieldRef<"Evidence", 'DateTime'>
    readonly updatedAt: FieldRef<"Evidence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Evidence findUnique
   */
  export type EvidenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter, which Evidence to fetch.
     */
    where: EvidenceWhereUniqueInput
  }

  /**
   * Evidence findUniqueOrThrow
   */
  export type EvidenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter, which Evidence to fetch.
     */
    where: EvidenceWhereUniqueInput
  }

  /**
   * Evidence findFirst
   */
  export type EvidenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter, which Evidence to fetch.
     */
    where?: EvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidences to fetch.
     */
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evidences.
     */
    cursor?: EvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evidences.
     */
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[]
  }

  /**
   * Evidence findFirstOrThrow
   */
  export type EvidenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter, which Evidence to fetch.
     */
    where?: EvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidences to fetch.
     */
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evidences.
     */
    cursor?: EvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evidences.
     */
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[]
  }

  /**
   * Evidence findMany
   */
  export type EvidenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter, which Evidences to fetch.
     */
    where?: EvidenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evidences to fetch.
     */
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evidences.
     */
    cursor?: EvidenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evidences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evidences.
     */
    skip?: number
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[]
  }

  /**
   * Evidence create
   */
  export type EvidenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * The data needed to create a Evidence.
     */
    data: XOR<EvidenceCreateInput, EvidenceUncheckedCreateInput>
  }

  /**
   * Evidence createMany
   */
  export type EvidenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evidences.
     */
    data: EvidenceCreateManyInput | EvidenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evidence createManyAndReturn
   */
  export type EvidenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * The data used to create many Evidences.
     */
    data: EvidenceCreateManyInput | EvidenceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evidence update
   */
  export type EvidenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * The data needed to update a Evidence.
     */
    data: XOR<EvidenceUpdateInput, EvidenceUncheckedUpdateInput>
    /**
     * Choose, which Evidence to update.
     */
    where: EvidenceWhereUniqueInput
  }

  /**
   * Evidence updateMany
   */
  export type EvidenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evidences.
     */
    data: XOR<EvidenceUpdateManyMutationInput, EvidenceUncheckedUpdateManyInput>
    /**
     * Filter which Evidences to update
     */
    where?: EvidenceWhereInput
    /**
     * Limit how many Evidences to update.
     */
    limit?: number
  }

  /**
   * Evidence updateManyAndReturn
   */
  export type EvidenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * The data used to update Evidences.
     */
    data: XOR<EvidenceUpdateManyMutationInput, EvidenceUncheckedUpdateManyInput>
    /**
     * Filter which Evidences to update
     */
    where?: EvidenceWhereInput
    /**
     * Limit how many Evidences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evidence upsert
   */
  export type EvidenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * The filter to search for the Evidence to update in case it exists.
     */
    where: EvidenceWhereUniqueInput
    /**
     * In case the Evidence found by the `where` argument doesn't exist, create a new Evidence with this data.
     */
    create: XOR<EvidenceCreateInput, EvidenceUncheckedCreateInput>
    /**
     * In case the Evidence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvidenceUpdateInput, EvidenceUncheckedUpdateInput>
  }

  /**
   * Evidence delete
   */
  export type EvidenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    /**
     * Filter which Evidence to delete.
     */
    where: EvidenceWhereUniqueInput
  }

  /**
   * Evidence deleteMany
   */
  export type EvidenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evidences to delete
     */
    where?: EvidenceWhereInput
    /**
     * Limit how many Evidences to delete.
     */
    limit?: number
  }

  /**
   * Evidence.delayEvent
   */
  export type Evidence$delayEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DelayEvent
     */
    select?: DelayEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DelayEvent
     */
    omit?: DelayEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DelayEventInclude<ExtArgs> | null
    where?: DelayEventWhereInput
  }

  /**
   * Evidence.claim
   */
  export type Evidence$claimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
  }

  /**
   * Evidence.file
   */
  export type Evidence$fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    where?: FileMetadataWhereInput
  }

  /**
   * Evidence without action
   */
  export type EvidenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
  }


  /**
   * Model Schedule
   */

  export type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  export type ScheduleMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    description: string | null
    format: $Enums.ScheduleFormat | null
    version: string | null
    baselineDate: Date | null
    statusDate: Date | null
    filePath: string | null
    fileId: string | null
    isBaseline: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    name: string | null
    description: string | null
    format: $Enums.ScheduleFormat | null
    version: string | null
    baselineDate: Date | null
    statusDate: Date | null
    filePath: string | null
    fileId: string | null
    isBaseline: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleCountAggregateOutputType = {
    id: number
    projectId: number
    name: number
    description: number
    format: number
    version: number
    baselineDate: number
    statusDate: number
    filePath: number
    fileId: number
    metadata: number
    isBaseline: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduleMinAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    format?: true
    version?: true
    baselineDate?: true
    statusDate?: true
    filePath?: true
    fileId?: true
    isBaseline?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleMaxAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    format?: true
    version?: true
    baselineDate?: true
    statusDate?: true
    filePath?: true
    fileId?: true
    isBaseline?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleCountAggregateInputType = {
    id?: true
    projectId?: true
    name?: true
    description?: true
    format?: true
    version?: true
    baselineDate?: true
    statusDate?: true
    filePath?: true
    fileId?: true
    metadata?: true
    isBaseline?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedule to aggregate.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedules
    **/
    _count?: true | ScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType
  }

  export type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedule[P]>
      : GetScalarType<T[P], AggregateSchedule[P]>
  }




  export type ScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithAggregationInput | ScheduleOrderByWithAggregationInput[]
    by: ScheduleScalarFieldEnum[] | ScheduleScalarFieldEnum
    having?: ScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleCountAggregateInputType | true
    _min?: ScheduleMinAggregateInputType
    _max?: ScheduleMaxAggregateInputType
  }

  export type ScheduleGroupByOutputType = {
    id: string
    projectId: string
    name: string
    description: string | null
    format: $Enums.ScheduleFormat
    version: string | null
    baselineDate: Date | null
    statusDate: Date | null
    filePath: string | null
    fileId: string | null
    metadata: JsonValue | null
    isBaseline: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: ScheduleCountAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  type GetScheduleGroupByPayload<T extends ScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    format?: boolean
    version?: boolean
    baselineDate?: boolean
    statusDate?: boolean
    filePath?: boolean
    fileId?: boolean
    metadata?: boolean
    isBaseline?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    file?: boolean | Schedule$fileArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    format?: boolean
    version?: boolean
    baselineDate?: boolean
    statusDate?: boolean
    filePath?: boolean
    fileId?: boolean
    metadata?: boolean
    isBaseline?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    file?: boolean | Schedule$fileArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    format?: boolean
    version?: boolean
    baselineDate?: boolean
    statusDate?: boolean
    filePath?: boolean
    fileId?: boolean
    metadata?: boolean
    isBaseline?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    file?: boolean | Schedule$fileArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectScalar = {
    id?: boolean
    projectId?: boolean
    name?: boolean
    description?: boolean
    format?: boolean
    version?: boolean
    baselineDate?: boolean
    statusDate?: boolean
    filePath?: boolean
    fileId?: boolean
    metadata?: boolean
    isBaseline?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "name" | "description" | "format" | "version" | "baselineDate" | "statusDate" | "filePath" | "fileId" | "metadata" | "isBaseline" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["schedule"]>
  export type ScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    file?: boolean | Schedule$fileArgs<ExtArgs>
  }
  export type ScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    file?: boolean | Schedule$fileArgs<ExtArgs>
  }
  export type ScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    file?: boolean | Schedule$fileArgs<ExtArgs>
  }

  export type $SchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Schedule"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      file: Prisma.$FileMetadataPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      name: string
      description: string | null
      format: $Enums.ScheduleFormat
      version: string | null
      baselineDate: Date | null
      statusDate: Date | null
      filePath: string | null
      fileId: string | null
      metadata: Prisma.JsonValue | null
      isBaseline: boolean
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schedule"]>
    composites: {}
  }

  type ScheduleGetPayload<S extends boolean | null | undefined | ScheduleDefaultArgs> = $Result.GetResult<Prisma.$SchedulePayload, S>

  type ScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleCountAggregateInputType | true
    }

  export interface ScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Schedule'], meta: { name: 'Schedule' } }
    /**
     * Find zero or one Schedule that matches the filter.
     * @param {ScheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleFindUniqueArgs>(args: SelectSubset<T, ScheduleFindUniqueArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Schedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleFindUniqueOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleFindFirstArgs>(args?: SelectSubset<T, ScheduleFindFirstArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleWithIdOnly = await prisma.schedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleFindManyArgs>(args?: SelectSubset<T, ScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Schedule.
     * @param {ScheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     * 
     */
    create<T extends ScheduleCreateArgs>(args: SelectSubset<T, ScheduleCreateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Schedules.
     * @param {ScheduleCreateManyArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleCreateManyArgs>(args?: SelectSubset<T, ScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schedules and returns the data saved in the database.
     * @param {ScheduleCreateManyAndReturnArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Schedule.
     * @param {ScheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     * 
     */
    delete<T extends ScheduleDeleteArgs>(args: SelectSubset<T, ScheduleDeleteArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Schedule.
     * @param {ScheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleUpdateArgs>(args: SelectSubset<T, ScheduleUpdateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Schedules.
     * @param {ScheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleDeleteManyArgs>(args?: SelectSubset<T, ScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleUpdateManyArgs>(args: SelectSubset<T, ScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules and returns the data updated in the database.
     * @param {ScheduleUpdateManyAndReturnArgs} args - Arguments to update many Schedules.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Schedule.
     * @param {ScheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleUpsertArgs>(args: SelectSubset<T, ScheduleUpsertArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends ScheduleCountArgs>(
      args?: Subset<T, ScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): Prisma.PrismaPromise<GetScheduleAggregateType<T>>

    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Schedule model
   */
  readonly fields: ScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    file<T extends Schedule$fileArgs<ExtArgs> = {}>(args?: Subset<T, Schedule$fileArgs<ExtArgs>>): Prisma__FileMetadataClient<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Schedule model
   */
  interface ScheduleFieldRefs {
    readonly id: FieldRef<"Schedule", 'String'>
    readonly projectId: FieldRef<"Schedule", 'String'>
    readonly name: FieldRef<"Schedule", 'String'>
    readonly description: FieldRef<"Schedule", 'String'>
    readonly format: FieldRef<"Schedule", 'ScheduleFormat'>
    readonly version: FieldRef<"Schedule", 'String'>
    readonly baselineDate: FieldRef<"Schedule", 'DateTime'>
    readonly statusDate: FieldRef<"Schedule", 'DateTime'>
    readonly filePath: FieldRef<"Schedule", 'String'>
    readonly fileId: FieldRef<"Schedule", 'String'>
    readonly metadata: FieldRef<"Schedule", 'Json'>
    readonly isBaseline: FieldRef<"Schedule", 'Boolean'>
    readonly isDeleted: FieldRef<"Schedule", 'Boolean'>
    readonly createdAt: FieldRef<"Schedule", 'DateTime'>
    readonly updatedAt: FieldRef<"Schedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Schedule findUnique
   */
  export type ScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findUniqueOrThrow
   */
  export type ScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findFirst
   */
  export type ScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findFirstOrThrow
   */
  export type ScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findMany
   */
  export type ScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule create
   */
  export type ScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a Schedule.
     */
    data: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
  }

  /**
   * Schedule createMany
   */
  export type ScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Schedule createManyAndReturn
   */
  export type ScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedule update
   */
  export type ScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a Schedule.
     */
    data: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
    /**
     * Choose, which Schedule to update.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule updateMany
   */
  export type ScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
  }

  /**
   * Schedule updateManyAndReturn
   */
  export type ScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedule upsert
   */
  export type ScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the Schedule to update in case it exists.
     */
    where: ScheduleWhereUniqueInput
    /**
     * In case the Schedule found by the `where` argument doesn't exist, create a new Schedule with this data.
     */
    create: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
    /**
     * In case the Schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
  }

  /**
   * Schedule delete
   */
  export type ScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter which Schedule to delete.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule deleteMany
   */
  export type ScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to delete
     */
    where?: ScheduleWhereInput
    /**
     * Limit how many Schedules to delete.
     */
    limit?: number
  }

  /**
   * Schedule.file
   */
  export type Schedule$fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    where?: FileMetadataWhereInput
  }

  /**
   * Schedule without action
   */
  export type ScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
  }


  /**
   * Model ActionItem
   */

  export type AggregateActionItem = {
    _count: ActionItemCountAggregateOutputType | null
    _min: ActionItemMinAggregateOutputType | null
    _max: ActionItemMaxAggregateOutputType | null
  }

  export type ActionItemMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    priority: $Enums.Priority | null
    dueDate: Date | null
    projectId: string | null
    assignedToId: string | null
    status: $Enums.ActionItemStatus | null
    completedAt: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActionItemMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    priority: $Enums.Priority | null
    dueDate: Date | null
    projectId: string | null
    assignedToId: string | null
    status: $Enums.ActionItemStatus | null
    completedAt: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ActionItemCountAggregateOutputType = {
    id: number
    title: number
    description: number
    priority: number
    dueDate: number
    projectId: number
    assignedToId: number
    status: number
    completedAt: number
    metadata: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ActionItemMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    priority?: true
    dueDate?: true
    projectId?: true
    assignedToId?: true
    status?: true
    completedAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActionItemMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    priority?: true
    dueDate?: true
    projectId?: true
    assignedToId?: true
    status?: true
    completedAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ActionItemCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    priority?: true
    dueDate?: true
    projectId?: true
    assignedToId?: true
    status?: true
    completedAt?: true
    metadata?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ActionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionItem to aggregate.
     */
    where?: ActionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionItems to fetch.
     */
    orderBy?: ActionItemOrderByWithRelationInput | ActionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActionItems
    **/
    _count?: true | ActionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActionItemMaxAggregateInputType
  }

  export type GetActionItemAggregateType<T extends ActionItemAggregateArgs> = {
        [P in keyof T & keyof AggregateActionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActionItem[P]>
      : GetScalarType<T[P], AggregateActionItem[P]>
  }




  export type ActionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActionItemWhereInput
    orderBy?: ActionItemOrderByWithAggregationInput | ActionItemOrderByWithAggregationInput[]
    by: ActionItemScalarFieldEnum[] | ActionItemScalarFieldEnum
    having?: ActionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActionItemCountAggregateInputType | true
    _min?: ActionItemMinAggregateInputType
    _max?: ActionItemMaxAggregateInputType
  }

  export type ActionItemGroupByOutputType = {
    id: string
    title: string
    description: string | null
    priority: $Enums.Priority
    dueDate: Date
    projectId: string
    assignedToId: string
    status: $Enums.ActionItemStatus
    completedAt: Date | null
    metadata: JsonValue | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: ActionItemCountAggregateOutputType | null
    _min: ActionItemMinAggregateOutputType | null
    _max: ActionItemMaxAggregateOutputType | null
  }

  type GetActionItemGroupByPayload<T extends ActionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActionItemGroupByOutputType[P]>
            : GetScalarType<T[P], ActionItemGroupByOutputType[P]>
        }
      >
    >


  export type ActionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    dueDate?: boolean
    projectId?: boolean
    assignedToId?: boolean
    status?: boolean
    completedAt?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actionItem"]>

  export type ActionItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    dueDate?: boolean
    projectId?: boolean
    assignedToId?: boolean
    status?: boolean
    completedAt?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actionItem"]>

  export type ActionItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    dueDate?: boolean
    projectId?: boolean
    assignedToId?: boolean
    status?: boolean
    completedAt?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actionItem"]>

  export type ActionItemSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    dueDate?: boolean
    projectId?: boolean
    assignedToId?: boolean
    status?: boolean
    completedAt?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ActionItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "priority" | "dueDate" | "projectId" | "assignedToId" | "status" | "completedAt" | "metadata" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["actionItem"]>
  export type ActionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActionItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActionItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    assignedTo?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActionItem"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      assignedTo: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      priority: $Enums.Priority
      dueDate: Date
      projectId: string
      assignedToId: string
      status: $Enums.ActionItemStatus
      completedAt: Date | null
      metadata: Prisma.JsonValue | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["actionItem"]>
    composites: {}
  }

  type ActionItemGetPayload<S extends boolean | null | undefined | ActionItemDefaultArgs> = $Result.GetResult<Prisma.$ActionItemPayload, S>

  type ActionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActionItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActionItemCountAggregateInputType | true
    }

  export interface ActionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActionItem'], meta: { name: 'ActionItem' } }
    /**
     * Find zero or one ActionItem that matches the filter.
     * @param {ActionItemFindUniqueArgs} args - Arguments to find a ActionItem
     * @example
     * // Get one ActionItem
     * const actionItem = await prisma.actionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActionItemFindUniqueArgs>(args: SelectSubset<T, ActionItemFindUniqueArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActionItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActionItemFindUniqueOrThrowArgs} args - Arguments to find a ActionItem
     * @example
     * // Get one ActionItem
     * const actionItem = await prisma.actionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ActionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionItemFindFirstArgs} args - Arguments to find a ActionItem
     * @example
     * // Get one ActionItem
     * const actionItem = await prisma.actionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActionItemFindFirstArgs>(args?: SelectSubset<T, ActionItemFindFirstArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionItemFindFirstOrThrowArgs} args - Arguments to find a ActionItem
     * @example
     * // Get one ActionItem
     * const actionItem = await prisma.actionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ActionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActionItems
     * const actionItems = await prisma.actionItem.findMany()
     * 
     * // Get first 10 ActionItems
     * const actionItems = await prisma.actionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actionItemWithIdOnly = await prisma.actionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActionItemFindManyArgs>(args?: SelectSubset<T, ActionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActionItem.
     * @param {ActionItemCreateArgs} args - Arguments to create a ActionItem.
     * @example
     * // Create one ActionItem
     * const ActionItem = await prisma.actionItem.create({
     *   data: {
     *     // ... data to create a ActionItem
     *   }
     * })
     * 
     */
    create<T extends ActionItemCreateArgs>(args: SelectSubset<T, ActionItemCreateArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActionItems.
     * @param {ActionItemCreateManyArgs} args - Arguments to create many ActionItems.
     * @example
     * // Create many ActionItems
     * const actionItem = await prisma.actionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActionItemCreateManyArgs>(args?: SelectSubset<T, ActionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActionItems and returns the data saved in the database.
     * @param {ActionItemCreateManyAndReturnArgs} args - Arguments to create many ActionItems.
     * @example
     * // Create many ActionItems
     * const actionItem = await prisma.actionItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActionItems and only return the `id`
     * const actionItemWithIdOnly = await prisma.actionItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActionItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ActionItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActionItem.
     * @param {ActionItemDeleteArgs} args - Arguments to delete one ActionItem.
     * @example
     * // Delete one ActionItem
     * const ActionItem = await prisma.actionItem.delete({
     *   where: {
     *     // ... filter to delete one ActionItem
     *   }
     * })
     * 
     */
    delete<T extends ActionItemDeleteArgs>(args: SelectSubset<T, ActionItemDeleteArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActionItem.
     * @param {ActionItemUpdateArgs} args - Arguments to update one ActionItem.
     * @example
     * // Update one ActionItem
     * const actionItem = await prisma.actionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActionItemUpdateArgs>(args: SelectSubset<T, ActionItemUpdateArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActionItems.
     * @param {ActionItemDeleteManyArgs} args - Arguments to filter ActionItems to delete.
     * @example
     * // Delete a few ActionItems
     * const { count } = await prisma.actionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActionItemDeleteManyArgs>(args?: SelectSubset<T, ActionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActionItems
     * const actionItem = await prisma.actionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActionItemUpdateManyArgs>(args: SelectSubset<T, ActionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActionItems and returns the data updated in the database.
     * @param {ActionItemUpdateManyAndReturnArgs} args - Arguments to update many ActionItems.
     * @example
     * // Update many ActionItems
     * const actionItem = await prisma.actionItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActionItems and only return the `id`
     * const actionItemWithIdOnly = await prisma.actionItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActionItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ActionItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActionItem.
     * @param {ActionItemUpsertArgs} args - Arguments to update or create a ActionItem.
     * @example
     * // Update or create a ActionItem
     * const actionItem = await prisma.actionItem.upsert({
     *   create: {
     *     // ... data to create a ActionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActionItem we want to update
     *   }
     * })
     */
    upsert<T extends ActionItemUpsertArgs>(args: SelectSubset<T, ActionItemUpsertArgs<ExtArgs>>): Prisma__ActionItemClient<$Result.GetResult<Prisma.$ActionItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionItemCountArgs} args - Arguments to filter ActionItems to count.
     * @example
     * // Count the number of ActionItems
     * const count = await prisma.actionItem.count({
     *   where: {
     *     // ... the filter for the ActionItems we want to count
     *   }
     * })
    **/
    count<T extends ActionItemCountArgs>(
      args?: Subset<T, ActionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActionItemAggregateArgs>(args: Subset<T, ActionItemAggregateArgs>): Prisma.PrismaPromise<GetActionItemAggregateType<T>>

    /**
     * Group by ActionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActionItemGroupByArgs['orderBy'] }
        : { orderBy?: ActionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActionItem model
   */
  readonly fields: ActionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignedTo<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActionItem model
   */
  interface ActionItemFieldRefs {
    readonly id: FieldRef<"ActionItem", 'String'>
    readonly title: FieldRef<"ActionItem", 'String'>
    readonly description: FieldRef<"ActionItem", 'String'>
    readonly priority: FieldRef<"ActionItem", 'Priority'>
    readonly dueDate: FieldRef<"ActionItem", 'DateTime'>
    readonly projectId: FieldRef<"ActionItem", 'String'>
    readonly assignedToId: FieldRef<"ActionItem", 'String'>
    readonly status: FieldRef<"ActionItem", 'ActionItemStatus'>
    readonly completedAt: FieldRef<"ActionItem", 'DateTime'>
    readonly metadata: FieldRef<"ActionItem", 'Json'>
    readonly isDeleted: FieldRef<"ActionItem", 'Boolean'>
    readonly createdAt: FieldRef<"ActionItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ActionItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActionItem findUnique
   */
  export type ActionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * Filter, which ActionItem to fetch.
     */
    where: ActionItemWhereUniqueInput
  }

  /**
   * ActionItem findUniqueOrThrow
   */
  export type ActionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * Filter, which ActionItem to fetch.
     */
    where: ActionItemWhereUniqueInput
  }

  /**
   * ActionItem findFirst
   */
  export type ActionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * Filter, which ActionItem to fetch.
     */
    where?: ActionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionItems to fetch.
     */
    orderBy?: ActionItemOrderByWithRelationInput | ActionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionItems.
     */
    cursor?: ActionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionItems.
     */
    distinct?: ActionItemScalarFieldEnum | ActionItemScalarFieldEnum[]
  }

  /**
   * ActionItem findFirstOrThrow
   */
  export type ActionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * Filter, which ActionItem to fetch.
     */
    where?: ActionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionItems to fetch.
     */
    orderBy?: ActionItemOrderByWithRelationInput | ActionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActionItems.
     */
    cursor?: ActionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActionItems.
     */
    distinct?: ActionItemScalarFieldEnum | ActionItemScalarFieldEnum[]
  }

  /**
   * ActionItem findMany
   */
  export type ActionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * Filter, which ActionItems to fetch.
     */
    where?: ActionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActionItems to fetch.
     */
    orderBy?: ActionItemOrderByWithRelationInput | ActionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActionItems.
     */
    cursor?: ActionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActionItems.
     */
    skip?: number
    distinct?: ActionItemScalarFieldEnum | ActionItemScalarFieldEnum[]
  }

  /**
   * ActionItem create
   */
  export type ActionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ActionItem.
     */
    data: XOR<ActionItemCreateInput, ActionItemUncheckedCreateInput>
  }

  /**
   * ActionItem createMany
   */
  export type ActionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActionItems.
     */
    data: ActionItemCreateManyInput | ActionItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActionItem createManyAndReturn
   */
  export type ActionItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * The data used to create many ActionItems.
     */
    data: ActionItemCreateManyInput | ActionItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActionItem update
   */
  export type ActionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ActionItem.
     */
    data: XOR<ActionItemUpdateInput, ActionItemUncheckedUpdateInput>
    /**
     * Choose, which ActionItem to update.
     */
    where: ActionItemWhereUniqueInput
  }

  /**
   * ActionItem updateMany
   */
  export type ActionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActionItems.
     */
    data: XOR<ActionItemUpdateManyMutationInput, ActionItemUncheckedUpdateManyInput>
    /**
     * Filter which ActionItems to update
     */
    where?: ActionItemWhereInput
    /**
     * Limit how many ActionItems to update.
     */
    limit?: number
  }

  /**
   * ActionItem updateManyAndReturn
   */
  export type ActionItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * The data used to update ActionItems.
     */
    data: XOR<ActionItemUpdateManyMutationInput, ActionItemUncheckedUpdateManyInput>
    /**
     * Filter which ActionItems to update
     */
    where?: ActionItemWhereInput
    /**
     * Limit how many ActionItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActionItem upsert
   */
  export type ActionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ActionItem to update in case it exists.
     */
    where: ActionItemWhereUniqueInput
    /**
     * In case the ActionItem found by the `where` argument doesn't exist, create a new ActionItem with this data.
     */
    create: XOR<ActionItemCreateInput, ActionItemUncheckedCreateInput>
    /**
     * In case the ActionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActionItemUpdateInput, ActionItemUncheckedUpdateInput>
  }

  /**
   * ActionItem delete
   */
  export type ActionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
    /**
     * Filter which ActionItem to delete.
     */
    where: ActionItemWhereUniqueInput
  }

  /**
   * ActionItem deleteMany
   */
  export type ActionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActionItems to delete
     */
    where?: ActionItemWhereInput
    /**
     * Limit how many ActionItems to delete.
     */
    limit?: number
  }

  /**
   * ActionItem without action
   */
  export type ActionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActionItem
     */
    select?: ActionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActionItem
     */
    omit?: ActionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActionItemInclude<ExtArgs> | null
  }


  /**
   * Model FileMetadata
   */

  export type AggregateFileMetadata = {
    _count: FileMetadataCountAggregateOutputType | null
    _avg: FileMetadataAvgAggregateOutputType | null
    _sum: FileMetadataSumAggregateOutputType | null
    _min: FileMetadataMinAggregateOutputType | null
    _max: FileMetadataMaxAggregateOutputType | null
  }

  export type FileMetadataAvgAggregateOutputType = {
    size: number | null
  }

  export type FileMetadataSumAggregateOutputType = {
    size: bigint | null
  }

  export type FileMetadataMinAggregateOutputType = {
    id: string | null
    filename: string | null
    originalName: string | null
    mimeType: string | null
    size: bigint | null
    checksum: string | null
    organizationId: string | null
    uploadedById: string | null
    path: string | null
    isPublic: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FileMetadataMaxAggregateOutputType = {
    id: string | null
    filename: string | null
    originalName: string | null
    mimeType: string | null
    size: bigint | null
    checksum: string | null
    organizationId: string | null
    uploadedById: string | null
    path: string | null
    isPublic: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FileMetadataCountAggregateOutputType = {
    id: number
    filename: number
    originalName: number
    mimeType: number
    size: number
    checksum: number
    organizationId: number
    uploadedById: number
    path: number
    isPublic: number
    tags: number
    metadata: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FileMetadataAvgAggregateInputType = {
    size?: true
  }

  export type FileMetadataSumAggregateInputType = {
    size?: true
  }

  export type FileMetadataMinAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    checksum?: true
    organizationId?: true
    uploadedById?: true
    path?: true
    isPublic?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FileMetadataMaxAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    checksum?: true
    organizationId?: true
    uploadedById?: true
    path?: true
    isPublic?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FileMetadataCountAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    checksum?: true
    organizationId?: true
    uploadedById?: true
    path?: true
    isPublic?: true
    tags?: true
    metadata?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FileMetadataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileMetadata to aggregate.
     */
    where?: FileMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileMetadata to fetch.
     */
    orderBy?: FileMetadataOrderByWithRelationInput | FileMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileMetadata
    **/
    _count?: true | FileMetadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileMetadataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileMetadataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMetadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMetadataMaxAggregateInputType
  }

  export type GetFileMetadataAggregateType<T extends FileMetadataAggregateArgs> = {
        [P in keyof T & keyof AggregateFileMetadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileMetadata[P]>
      : GetScalarType<T[P], AggregateFileMetadata[P]>
  }




  export type FileMetadataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileMetadataWhereInput
    orderBy?: FileMetadataOrderByWithAggregationInput | FileMetadataOrderByWithAggregationInput[]
    by: FileMetadataScalarFieldEnum[] | FileMetadataScalarFieldEnum
    having?: FileMetadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileMetadataCountAggregateInputType | true
    _avg?: FileMetadataAvgAggregateInputType
    _sum?: FileMetadataSumAggregateInputType
    _min?: FileMetadataMinAggregateInputType
    _max?: FileMetadataMaxAggregateInputType
  }

  export type FileMetadataGroupByOutputType = {
    id: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint
    checksum: string | null
    organizationId: string
    uploadedById: string
    path: string
    isPublic: boolean
    tags: string[]
    metadata: JsonValue | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: FileMetadataCountAggregateOutputType | null
    _avg: FileMetadataAvgAggregateOutputType | null
    _sum: FileMetadataSumAggregateOutputType | null
    _min: FileMetadataMinAggregateOutputType | null
    _max: FileMetadataMaxAggregateOutputType | null
  }

  type GetFileMetadataGroupByPayload<T extends FileMetadataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileMetadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileMetadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileMetadataGroupByOutputType[P]>
            : GetScalarType<T[P], FileMetadataGroupByOutputType[P]>
        }
      >
    >


  export type FileMetadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    checksum?: boolean
    organizationId?: boolean
    uploadedById?: boolean
    path?: boolean
    isPublic?: boolean
    tags?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    evidence?: boolean | FileMetadata$evidenceArgs<ExtArgs>
    schedules?: boolean | FileMetadata$schedulesArgs<ExtArgs>
    _count?: boolean | FileMetadataCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileMetadata"]>

  export type FileMetadataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    checksum?: boolean
    organizationId?: boolean
    uploadedById?: boolean
    path?: boolean
    isPublic?: boolean
    tags?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileMetadata"]>

  export type FileMetadataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    checksum?: boolean
    organizationId?: boolean
    uploadedById?: boolean
    path?: boolean
    isPublic?: boolean
    tags?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileMetadata"]>

  export type FileMetadataSelectScalar = {
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    checksum?: boolean
    organizationId?: boolean
    uploadedById?: boolean
    path?: boolean
    isPublic?: boolean
    tags?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FileMetadataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filename" | "originalName" | "mimeType" | "size" | "checksum" | "organizationId" | "uploadedById" | "path" | "isPublic" | "tags" | "metadata" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["fileMetadata"]>
  export type FileMetadataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
    evidence?: boolean | FileMetadata$evidenceArgs<ExtArgs>
    schedules?: boolean | FileMetadata$schedulesArgs<ExtArgs>
    _count?: boolean | FileMetadataCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FileMetadataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FileMetadataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    uploadedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FileMetadataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileMetadata"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      uploadedBy: Prisma.$UserPayload<ExtArgs>
      evidence: Prisma.$EvidencePayload<ExtArgs>[]
      schedules: Prisma.$SchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      filename: string
      originalName: string
      mimeType: string
      size: bigint
      checksum: string | null
      organizationId: string
      uploadedById: string
      path: string
      isPublic: boolean
      tags: string[]
      metadata: Prisma.JsonValue | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fileMetadata"]>
    composites: {}
  }

  type FileMetadataGetPayload<S extends boolean | null | undefined | FileMetadataDefaultArgs> = $Result.GetResult<Prisma.$FileMetadataPayload, S>

  type FileMetadataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileMetadataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileMetadataCountAggregateInputType | true
    }

  export interface FileMetadataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileMetadata'], meta: { name: 'FileMetadata' } }
    /**
     * Find zero or one FileMetadata that matches the filter.
     * @param {FileMetadataFindUniqueArgs} args - Arguments to find a FileMetadata
     * @example
     * // Get one FileMetadata
     * const fileMetadata = await prisma.fileMetadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileMetadataFindUniqueArgs>(args: SelectSubset<T, FileMetadataFindUniqueArgs<ExtArgs>>): Prisma__FileMetadataClient<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FileMetadata that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileMetadataFindUniqueOrThrowArgs} args - Arguments to find a FileMetadata
     * @example
     * // Get one FileMetadata
     * const fileMetadata = await prisma.fileMetadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileMetadataFindUniqueOrThrowArgs>(args: SelectSubset<T, FileMetadataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileMetadataClient<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMetadataFindFirstArgs} args - Arguments to find a FileMetadata
     * @example
     * // Get one FileMetadata
     * const fileMetadata = await prisma.fileMetadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileMetadataFindFirstArgs>(args?: SelectSubset<T, FileMetadataFindFirstArgs<ExtArgs>>): Prisma__FileMetadataClient<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileMetadata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMetadataFindFirstOrThrowArgs} args - Arguments to find a FileMetadata
     * @example
     * // Get one FileMetadata
     * const fileMetadata = await prisma.fileMetadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileMetadataFindFirstOrThrowArgs>(args?: SelectSubset<T, FileMetadataFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileMetadataClient<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FileMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMetadataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileMetadata
     * const fileMetadata = await prisma.fileMetadata.findMany()
     * 
     * // Get first 10 FileMetadata
     * const fileMetadata = await prisma.fileMetadata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileMetadataWithIdOnly = await prisma.fileMetadata.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileMetadataFindManyArgs>(args?: SelectSubset<T, FileMetadataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FileMetadata.
     * @param {FileMetadataCreateArgs} args - Arguments to create a FileMetadata.
     * @example
     * // Create one FileMetadata
     * const FileMetadata = await prisma.fileMetadata.create({
     *   data: {
     *     // ... data to create a FileMetadata
     *   }
     * })
     * 
     */
    create<T extends FileMetadataCreateArgs>(args: SelectSubset<T, FileMetadataCreateArgs<ExtArgs>>): Prisma__FileMetadataClient<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FileMetadata.
     * @param {FileMetadataCreateManyArgs} args - Arguments to create many FileMetadata.
     * @example
     * // Create many FileMetadata
     * const fileMetadata = await prisma.fileMetadata.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileMetadataCreateManyArgs>(args?: SelectSubset<T, FileMetadataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FileMetadata and returns the data saved in the database.
     * @param {FileMetadataCreateManyAndReturnArgs} args - Arguments to create many FileMetadata.
     * @example
     * // Create many FileMetadata
     * const fileMetadata = await prisma.fileMetadata.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FileMetadata and only return the `id`
     * const fileMetadataWithIdOnly = await prisma.fileMetadata.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileMetadataCreateManyAndReturnArgs>(args?: SelectSubset<T, FileMetadataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FileMetadata.
     * @param {FileMetadataDeleteArgs} args - Arguments to delete one FileMetadata.
     * @example
     * // Delete one FileMetadata
     * const FileMetadata = await prisma.fileMetadata.delete({
     *   where: {
     *     // ... filter to delete one FileMetadata
     *   }
     * })
     * 
     */
    delete<T extends FileMetadataDeleteArgs>(args: SelectSubset<T, FileMetadataDeleteArgs<ExtArgs>>): Prisma__FileMetadataClient<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FileMetadata.
     * @param {FileMetadataUpdateArgs} args - Arguments to update one FileMetadata.
     * @example
     * // Update one FileMetadata
     * const fileMetadata = await prisma.fileMetadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileMetadataUpdateArgs>(args: SelectSubset<T, FileMetadataUpdateArgs<ExtArgs>>): Prisma__FileMetadataClient<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FileMetadata.
     * @param {FileMetadataDeleteManyArgs} args - Arguments to filter FileMetadata to delete.
     * @example
     * // Delete a few FileMetadata
     * const { count } = await prisma.fileMetadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileMetadataDeleteManyArgs>(args?: SelectSubset<T, FileMetadataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMetadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileMetadata
     * const fileMetadata = await prisma.fileMetadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileMetadataUpdateManyArgs>(args: SelectSubset<T, FileMetadataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileMetadata and returns the data updated in the database.
     * @param {FileMetadataUpdateManyAndReturnArgs} args - Arguments to update many FileMetadata.
     * @example
     * // Update many FileMetadata
     * const fileMetadata = await prisma.fileMetadata.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FileMetadata and only return the `id`
     * const fileMetadataWithIdOnly = await prisma.fileMetadata.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileMetadataUpdateManyAndReturnArgs>(args: SelectSubset<T, FileMetadataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FileMetadata.
     * @param {FileMetadataUpsertArgs} args - Arguments to update or create a FileMetadata.
     * @example
     * // Update or create a FileMetadata
     * const fileMetadata = await prisma.fileMetadata.upsert({
     *   create: {
     *     // ... data to create a FileMetadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileMetadata we want to update
     *   }
     * })
     */
    upsert<T extends FileMetadataUpsertArgs>(args: SelectSubset<T, FileMetadataUpsertArgs<ExtArgs>>): Prisma__FileMetadataClient<$Result.GetResult<Prisma.$FileMetadataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FileMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMetadataCountArgs} args - Arguments to filter FileMetadata to count.
     * @example
     * // Count the number of FileMetadata
     * const count = await prisma.fileMetadata.count({
     *   where: {
     *     // ... the filter for the FileMetadata we want to count
     *   }
     * })
    **/
    count<T extends FileMetadataCountArgs>(
      args?: Subset<T, FileMetadataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileMetadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMetadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileMetadataAggregateArgs>(args: Subset<T, FileMetadataAggregateArgs>): Prisma.PrismaPromise<GetFileMetadataAggregateType<T>>

    /**
     * Group by FileMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileMetadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileMetadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileMetadataGroupByArgs['orderBy'] }
        : { orderBy?: FileMetadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileMetadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileMetadataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileMetadata model
   */
  readonly fields: FileMetadataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileMetadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileMetadataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploadedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    evidence<T extends FileMetadata$evidenceArgs<ExtArgs> = {}>(args?: Subset<T, FileMetadata$evidenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schedules<T extends FileMetadata$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, FileMetadata$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileMetadata model
   */
  interface FileMetadataFieldRefs {
    readonly id: FieldRef<"FileMetadata", 'String'>
    readonly filename: FieldRef<"FileMetadata", 'String'>
    readonly originalName: FieldRef<"FileMetadata", 'String'>
    readonly mimeType: FieldRef<"FileMetadata", 'String'>
    readonly size: FieldRef<"FileMetadata", 'BigInt'>
    readonly checksum: FieldRef<"FileMetadata", 'String'>
    readonly organizationId: FieldRef<"FileMetadata", 'String'>
    readonly uploadedById: FieldRef<"FileMetadata", 'String'>
    readonly path: FieldRef<"FileMetadata", 'String'>
    readonly isPublic: FieldRef<"FileMetadata", 'Boolean'>
    readonly tags: FieldRef<"FileMetadata", 'String[]'>
    readonly metadata: FieldRef<"FileMetadata", 'Json'>
    readonly isDeleted: FieldRef<"FileMetadata", 'Boolean'>
    readonly createdAt: FieldRef<"FileMetadata", 'DateTime'>
    readonly updatedAt: FieldRef<"FileMetadata", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FileMetadata findUnique
   */
  export type FileMetadataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    /**
     * Filter, which FileMetadata to fetch.
     */
    where: FileMetadataWhereUniqueInput
  }

  /**
   * FileMetadata findUniqueOrThrow
   */
  export type FileMetadataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    /**
     * Filter, which FileMetadata to fetch.
     */
    where: FileMetadataWhereUniqueInput
  }

  /**
   * FileMetadata findFirst
   */
  export type FileMetadataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    /**
     * Filter, which FileMetadata to fetch.
     */
    where?: FileMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileMetadata to fetch.
     */
    orderBy?: FileMetadataOrderByWithRelationInput | FileMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileMetadata.
     */
    cursor?: FileMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileMetadata.
     */
    distinct?: FileMetadataScalarFieldEnum | FileMetadataScalarFieldEnum[]
  }

  /**
   * FileMetadata findFirstOrThrow
   */
  export type FileMetadataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    /**
     * Filter, which FileMetadata to fetch.
     */
    where?: FileMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileMetadata to fetch.
     */
    orderBy?: FileMetadataOrderByWithRelationInput | FileMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileMetadata.
     */
    cursor?: FileMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileMetadata.
     */
    distinct?: FileMetadataScalarFieldEnum | FileMetadataScalarFieldEnum[]
  }

  /**
   * FileMetadata findMany
   */
  export type FileMetadataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    /**
     * Filter, which FileMetadata to fetch.
     */
    where?: FileMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileMetadata to fetch.
     */
    orderBy?: FileMetadataOrderByWithRelationInput | FileMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileMetadata.
     */
    cursor?: FileMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileMetadata.
     */
    skip?: number
    distinct?: FileMetadataScalarFieldEnum | FileMetadataScalarFieldEnum[]
  }

  /**
   * FileMetadata create
   */
  export type FileMetadataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    /**
     * The data needed to create a FileMetadata.
     */
    data: XOR<FileMetadataCreateInput, FileMetadataUncheckedCreateInput>
  }

  /**
   * FileMetadata createMany
   */
  export type FileMetadataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileMetadata.
     */
    data: FileMetadataCreateManyInput | FileMetadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FileMetadata createManyAndReturn
   */
  export type FileMetadataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * The data used to create many FileMetadata.
     */
    data: FileMetadataCreateManyInput | FileMetadataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileMetadata update
   */
  export type FileMetadataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    /**
     * The data needed to update a FileMetadata.
     */
    data: XOR<FileMetadataUpdateInput, FileMetadataUncheckedUpdateInput>
    /**
     * Choose, which FileMetadata to update.
     */
    where: FileMetadataWhereUniqueInput
  }

  /**
   * FileMetadata updateMany
   */
  export type FileMetadataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileMetadata.
     */
    data: XOR<FileMetadataUpdateManyMutationInput, FileMetadataUncheckedUpdateManyInput>
    /**
     * Filter which FileMetadata to update
     */
    where?: FileMetadataWhereInput
    /**
     * Limit how many FileMetadata to update.
     */
    limit?: number
  }

  /**
   * FileMetadata updateManyAndReturn
   */
  export type FileMetadataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * The data used to update FileMetadata.
     */
    data: XOR<FileMetadataUpdateManyMutationInput, FileMetadataUncheckedUpdateManyInput>
    /**
     * Filter which FileMetadata to update
     */
    where?: FileMetadataWhereInput
    /**
     * Limit how many FileMetadata to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileMetadata upsert
   */
  export type FileMetadataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    /**
     * The filter to search for the FileMetadata to update in case it exists.
     */
    where: FileMetadataWhereUniqueInput
    /**
     * In case the FileMetadata found by the `where` argument doesn't exist, create a new FileMetadata with this data.
     */
    create: XOR<FileMetadataCreateInput, FileMetadataUncheckedCreateInput>
    /**
     * In case the FileMetadata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileMetadataUpdateInput, FileMetadataUncheckedUpdateInput>
  }

  /**
   * FileMetadata delete
   */
  export type FileMetadataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
    /**
     * Filter which FileMetadata to delete.
     */
    where: FileMetadataWhereUniqueInput
  }

  /**
   * FileMetadata deleteMany
   */
  export type FileMetadataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileMetadata to delete
     */
    where?: FileMetadataWhereInput
    /**
     * Limit how many FileMetadata to delete.
     */
    limit?: number
  }

  /**
   * FileMetadata.evidence
   */
  export type FileMetadata$evidenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evidence
     */
    select?: EvidenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evidence
     */
    omit?: EvidenceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceInclude<ExtArgs> | null
    where?: EvidenceWhereInput
    orderBy?: EvidenceOrderByWithRelationInput | EvidenceOrderByWithRelationInput[]
    cursor?: EvidenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvidenceScalarFieldEnum | EvidenceScalarFieldEnum[]
  }

  /**
   * FileMetadata.schedules
   */
  export type FileMetadata$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Schedule
     */
    omit?: ScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * FileMetadata without action
   */
  export type FileMetadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileMetadata
     */
    select?: FileMetadataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileMetadata
     */
    omit?: FileMetadataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileMetadataInclude<ExtArgs> | null
  }


  /**
   * Model StorageQuota
   */

  export type AggregateStorageQuota = {
    _count: StorageQuotaCountAggregateOutputType | null
    _avg: StorageQuotaAvgAggregateOutputType | null
    _sum: StorageQuotaSumAggregateOutputType | null
    _min: StorageQuotaMinAggregateOutputType | null
    _max: StorageQuotaMaxAggregateOutputType | null
  }

  export type StorageQuotaAvgAggregateOutputType = {
    usedBytes: number | null
    limitBytes: number | null
    fileCount: number | null
    maxFileCount: number | null
  }

  export type StorageQuotaSumAggregateOutputType = {
    usedBytes: bigint | null
    limitBytes: bigint | null
    fileCount: number | null
    maxFileCount: number | null
  }

  export type StorageQuotaMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    usedBytes: bigint | null
    limitBytes: bigint | null
    fileCount: number | null
    maxFileCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StorageQuotaMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    usedBytes: bigint | null
    limitBytes: bigint | null
    fileCount: number | null
    maxFileCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StorageQuotaCountAggregateOutputType = {
    id: number
    organizationId: number
    usedBytes: number
    limitBytes: number
    fileCount: number
    maxFileCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StorageQuotaAvgAggregateInputType = {
    usedBytes?: true
    limitBytes?: true
    fileCount?: true
    maxFileCount?: true
  }

  export type StorageQuotaSumAggregateInputType = {
    usedBytes?: true
    limitBytes?: true
    fileCount?: true
    maxFileCount?: true
  }

  export type StorageQuotaMinAggregateInputType = {
    id?: true
    organizationId?: true
    usedBytes?: true
    limitBytes?: true
    fileCount?: true
    maxFileCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StorageQuotaMaxAggregateInputType = {
    id?: true
    organizationId?: true
    usedBytes?: true
    limitBytes?: true
    fileCount?: true
    maxFileCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StorageQuotaCountAggregateInputType = {
    id?: true
    organizationId?: true
    usedBytes?: true
    limitBytes?: true
    fileCount?: true
    maxFileCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StorageQuotaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorageQuota to aggregate.
     */
    where?: StorageQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageQuotas to fetch.
     */
    orderBy?: StorageQuotaOrderByWithRelationInput | StorageQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StorageQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StorageQuotas
    **/
    _count?: true | StorageQuotaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StorageQuotaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StorageQuotaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StorageQuotaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StorageQuotaMaxAggregateInputType
  }

  export type GetStorageQuotaAggregateType<T extends StorageQuotaAggregateArgs> = {
        [P in keyof T & keyof AggregateStorageQuota]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStorageQuota[P]>
      : GetScalarType<T[P], AggregateStorageQuota[P]>
  }




  export type StorageQuotaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StorageQuotaWhereInput
    orderBy?: StorageQuotaOrderByWithAggregationInput | StorageQuotaOrderByWithAggregationInput[]
    by: StorageQuotaScalarFieldEnum[] | StorageQuotaScalarFieldEnum
    having?: StorageQuotaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StorageQuotaCountAggregateInputType | true
    _avg?: StorageQuotaAvgAggregateInputType
    _sum?: StorageQuotaSumAggregateInputType
    _min?: StorageQuotaMinAggregateInputType
    _max?: StorageQuotaMaxAggregateInputType
  }

  export type StorageQuotaGroupByOutputType = {
    id: string
    organizationId: string
    usedBytes: bigint
    limitBytes: bigint
    fileCount: number
    maxFileCount: number
    createdAt: Date
    updatedAt: Date
    _count: StorageQuotaCountAggregateOutputType | null
    _avg: StorageQuotaAvgAggregateOutputType | null
    _sum: StorageQuotaSumAggregateOutputType | null
    _min: StorageQuotaMinAggregateOutputType | null
    _max: StorageQuotaMaxAggregateOutputType | null
  }

  type GetStorageQuotaGroupByPayload<T extends StorageQuotaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StorageQuotaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StorageQuotaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StorageQuotaGroupByOutputType[P]>
            : GetScalarType<T[P], StorageQuotaGroupByOutputType[P]>
        }
      >
    >


  export type StorageQuotaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    usedBytes?: boolean
    limitBytes?: boolean
    fileCount?: boolean
    maxFileCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storageQuota"]>

  export type StorageQuotaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    usedBytes?: boolean
    limitBytes?: boolean
    fileCount?: boolean
    maxFileCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storageQuota"]>

  export type StorageQuotaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    usedBytes?: boolean
    limitBytes?: boolean
    fileCount?: boolean
    maxFileCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storageQuota"]>

  export type StorageQuotaSelectScalar = {
    id?: boolean
    organizationId?: boolean
    usedBytes?: boolean
    limitBytes?: boolean
    fileCount?: boolean
    maxFileCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StorageQuotaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "usedBytes" | "limitBytes" | "fileCount" | "maxFileCount" | "createdAt" | "updatedAt", ExtArgs["result"]["storageQuota"]>
  export type StorageQuotaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type StorageQuotaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type StorageQuotaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $StorageQuotaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StorageQuota"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: string
      usedBytes: bigint
      limitBytes: bigint
      fileCount: number
      maxFileCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["storageQuota"]>
    composites: {}
  }

  type StorageQuotaGetPayload<S extends boolean | null | undefined | StorageQuotaDefaultArgs> = $Result.GetResult<Prisma.$StorageQuotaPayload, S>

  type StorageQuotaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StorageQuotaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StorageQuotaCountAggregateInputType | true
    }

  export interface StorageQuotaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StorageQuota'], meta: { name: 'StorageQuota' } }
    /**
     * Find zero or one StorageQuota that matches the filter.
     * @param {StorageQuotaFindUniqueArgs} args - Arguments to find a StorageQuota
     * @example
     * // Get one StorageQuota
     * const storageQuota = await prisma.storageQuota.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StorageQuotaFindUniqueArgs>(args: SelectSubset<T, StorageQuotaFindUniqueArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StorageQuota that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StorageQuotaFindUniqueOrThrowArgs} args - Arguments to find a StorageQuota
     * @example
     * // Get one StorageQuota
     * const storageQuota = await prisma.storageQuota.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StorageQuotaFindUniqueOrThrowArgs>(args: SelectSubset<T, StorageQuotaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StorageQuota that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageQuotaFindFirstArgs} args - Arguments to find a StorageQuota
     * @example
     * // Get one StorageQuota
     * const storageQuota = await prisma.storageQuota.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StorageQuotaFindFirstArgs>(args?: SelectSubset<T, StorageQuotaFindFirstArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StorageQuota that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageQuotaFindFirstOrThrowArgs} args - Arguments to find a StorageQuota
     * @example
     * // Get one StorageQuota
     * const storageQuota = await prisma.storageQuota.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StorageQuotaFindFirstOrThrowArgs>(args?: SelectSubset<T, StorageQuotaFindFirstOrThrowArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StorageQuotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageQuotaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StorageQuotas
     * const storageQuotas = await prisma.storageQuota.findMany()
     * 
     * // Get first 10 StorageQuotas
     * const storageQuotas = await prisma.storageQuota.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storageQuotaWithIdOnly = await prisma.storageQuota.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StorageQuotaFindManyArgs>(args?: SelectSubset<T, StorageQuotaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StorageQuota.
     * @param {StorageQuotaCreateArgs} args - Arguments to create a StorageQuota.
     * @example
     * // Create one StorageQuota
     * const StorageQuota = await prisma.storageQuota.create({
     *   data: {
     *     // ... data to create a StorageQuota
     *   }
     * })
     * 
     */
    create<T extends StorageQuotaCreateArgs>(args: SelectSubset<T, StorageQuotaCreateArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StorageQuotas.
     * @param {StorageQuotaCreateManyArgs} args - Arguments to create many StorageQuotas.
     * @example
     * // Create many StorageQuotas
     * const storageQuota = await prisma.storageQuota.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StorageQuotaCreateManyArgs>(args?: SelectSubset<T, StorageQuotaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StorageQuotas and returns the data saved in the database.
     * @param {StorageQuotaCreateManyAndReturnArgs} args - Arguments to create many StorageQuotas.
     * @example
     * // Create many StorageQuotas
     * const storageQuota = await prisma.storageQuota.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StorageQuotas and only return the `id`
     * const storageQuotaWithIdOnly = await prisma.storageQuota.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StorageQuotaCreateManyAndReturnArgs>(args?: SelectSubset<T, StorageQuotaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StorageQuota.
     * @param {StorageQuotaDeleteArgs} args - Arguments to delete one StorageQuota.
     * @example
     * // Delete one StorageQuota
     * const StorageQuota = await prisma.storageQuota.delete({
     *   where: {
     *     // ... filter to delete one StorageQuota
     *   }
     * })
     * 
     */
    delete<T extends StorageQuotaDeleteArgs>(args: SelectSubset<T, StorageQuotaDeleteArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StorageQuota.
     * @param {StorageQuotaUpdateArgs} args - Arguments to update one StorageQuota.
     * @example
     * // Update one StorageQuota
     * const storageQuota = await prisma.storageQuota.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StorageQuotaUpdateArgs>(args: SelectSubset<T, StorageQuotaUpdateArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StorageQuotas.
     * @param {StorageQuotaDeleteManyArgs} args - Arguments to filter StorageQuotas to delete.
     * @example
     * // Delete a few StorageQuotas
     * const { count } = await prisma.storageQuota.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StorageQuotaDeleteManyArgs>(args?: SelectSubset<T, StorageQuotaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StorageQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageQuotaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StorageQuotas
     * const storageQuota = await prisma.storageQuota.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StorageQuotaUpdateManyArgs>(args: SelectSubset<T, StorageQuotaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StorageQuotas and returns the data updated in the database.
     * @param {StorageQuotaUpdateManyAndReturnArgs} args - Arguments to update many StorageQuotas.
     * @example
     * // Update many StorageQuotas
     * const storageQuota = await prisma.storageQuota.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StorageQuotas and only return the `id`
     * const storageQuotaWithIdOnly = await prisma.storageQuota.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StorageQuotaUpdateManyAndReturnArgs>(args: SelectSubset<T, StorageQuotaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StorageQuota.
     * @param {StorageQuotaUpsertArgs} args - Arguments to update or create a StorageQuota.
     * @example
     * // Update or create a StorageQuota
     * const storageQuota = await prisma.storageQuota.upsert({
     *   create: {
     *     // ... data to create a StorageQuota
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StorageQuota we want to update
     *   }
     * })
     */
    upsert<T extends StorageQuotaUpsertArgs>(args: SelectSubset<T, StorageQuotaUpsertArgs<ExtArgs>>): Prisma__StorageQuotaClient<$Result.GetResult<Prisma.$StorageQuotaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StorageQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageQuotaCountArgs} args - Arguments to filter StorageQuotas to count.
     * @example
     * // Count the number of StorageQuotas
     * const count = await prisma.storageQuota.count({
     *   where: {
     *     // ... the filter for the StorageQuotas we want to count
     *   }
     * })
    **/
    count<T extends StorageQuotaCountArgs>(
      args?: Subset<T, StorageQuotaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StorageQuotaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StorageQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageQuotaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StorageQuotaAggregateArgs>(args: Subset<T, StorageQuotaAggregateArgs>): Prisma.PrismaPromise<GetStorageQuotaAggregateType<T>>

    /**
     * Group by StorageQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StorageQuotaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StorageQuotaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StorageQuotaGroupByArgs['orderBy'] }
        : { orderBy?: StorageQuotaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StorageQuotaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStorageQuotaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StorageQuota model
   */
  readonly fields: StorageQuotaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StorageQuota.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StorageQuotaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StorageQuota model
   */
  interface StorageQuotaFieldRefs {
    readonly id: FieldRef<"StorageQuota", 'String'>
    readonly organizationId: FieldRef<"StorageQuota", 'String'>
    readonly usedBytes: FieldRef<"StorageQuota", 'BigInt'>
    readonly limitBytes: FieldRef<"StorageQuota", 'BigInt'>
    readonly fileCount: FieldRef<"StorageQuota", 'Int'>
    readonly maxFileCount: FieldRef<"StorageQuota", 'Int'>
    readonly createdAt: FieldRef<"StorageQuota", 'DateTime'>
    readonly updatedAt: FieldRef<"StorageQuota", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StorageQuota findUnique
   */
  export type StorageQuotaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageQuota
     */
    omit?: StorageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * Filter, which StorageQuota to fetch.
     */
    where: StorageQuotaWhereUniqueInput
  }

  /**
   * StorageQuota findUniqueOrThrow
   */
  export type StorageQuotaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageQuota
     */
    omit?: StorageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * Filter, which StorageQuota to fetch.
     */
    where: StorageQuotaWhereUniqueInput
  }

  /**
   * StorageQuota findFirst
   */
  export type StorageQuotaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageQuota
     */
    omit?: StorageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * Filter, which StorageQuota to fetch.
     */
    where?: StorageQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageQuotas to fetch.
     */
    orderBy?: StorageQuotaOrderByWithRelationInput | StorageQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorageQuotas.
     */
    cursor?: StorageQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorageQuotas.
     */
    distinct?: StorageQuotaScalarFieldEnum | StorageQuotaScalarFieldEnum[]
  }

  /**
   * StorageQuota findFirstOrThrow
   */
  export type StorageQuotaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageQuota
     */
    omit?: StorageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * Filter, which StorageQuota to fetch.
     */
    where?: StorageQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageQuotas to fetch.
     */
    orderBy?: StorageQuotaOrderByWithRelationInput | StorageQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StorageQuotas.
     */
    cursor?: StorageQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StorageQuotas.
     */
    distinct?: StorageQuotaScalarFieldEnum | StorageQuotaScalarFieldEnum[]
  }

  /**
   * StorageQuota findMany
   */
  export type StorageQuotaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageQuota
     */
    omit?: StorageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * Filter, which StorageQuotas to fetch.
     */
    where?: StorageQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StorageQuotas to fetch.
     */
    orderBy?: StorageQuotaOrderByWithRelationInput | StorageQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StorageQuotas.
     */
    cursor?: StorageQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StorageQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StorageQuotas.
     */
    skip?: number
    distinct?: StorageQuotaScalarFieldEnum | StorageQuotaScalarFieldEnum[]
  }

  /**
   * StorageQuota create
   */
  export type StorageQuotaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageQuota
     */
    omit?: StorageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * The data needed to create a StorageQuota.
     */
    data: XOR<StorageQuotaCreateInput, StorageQuotaUncheckedCreateInput>
  }

  /**
   * StorageQuota createMany
   */
  export type StorageQuotaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StorageQuotas.
     */
    data: StorageQuotaCreateManyInput | StorageQuotaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StorageQuota createManyAndReturn
   */
  export type StorageQuotaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StorageQuota
     */
    omit?: StorageQuotaOmit<ExtArgs> | null
    /**
     * The data used to create many StorageQuotas.
     */
    data: StorageQuotaCreateManyInput | StorageQuotaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StorageQuota update
   */
  export type StorageQuotaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageQuota
     */
    omit?: StorageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * The data needed to update a StorageQuota.
     */
    data: XOR<StorageQuotaUpdateInput, StorageQuotaUncheckedUpdateInput>
    /**
     * Choose, which StorageQuota to update.
     */
    where: StorageQuotaWhereUniqueInput
  }

  /**
   * StorageQuota updateMany
   */
  export type StorageQuotaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StorageQuotas.
     */
    data: XOR<StorageQuotaUpdateManyMutationInput, StorageQuotaUncheckedUpdateManyInput>
    /**
     * Filter which StorageQuotas to update
     */
    where?: StorageQuotaWhereInput
    /**
     * Limit how many StorageQuotas to update.
     */
    limit?: number
  }

  /**
   * StorageQuota updateManyAndReturn
   */
  export type StorageQuotaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StorageQuota
     */
    omit?: StorageQuotaOmit<ExtArgs> | null
    /**
     * The data used to update StorageQuotas.
     */
    data: XOR<StorageQuotaUpdateManyMutationInput, StorageQuotaUncheckedUpdateManyInput>
    /**
     * Filter which StorageQuotas to update
     */
    where?: StorageQuotaWhereInput
    /**
     * Limit how many StorageQuotas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StorageQuota upsert
   */
  export type StorageQuotaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageQuota
     */
    omit?: StorageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * The filter to search for the StorageQuota to update in case it exists.
     */
    where: StorageQuotaWhereUniqueInput
    /**
     * In case the StorageQuota found by the `where` argument doesn't exist, create a new StorageQuota with this data.
     */
    create: XOR<StorageQuotaCreateInput, StorageQuotaUncheckedCreateInput>
    /**
     * In case the StorageQuota was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StorageQuotaUpdateInput, StorageQuotaUncheckedUpdateInput>
  }

  /**
   * StorageQuota delete
   */
  export type StorageQuotaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageQuota
     */
    omit?: StorageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
    /**
     * Filter which StorageQuota to delete.
     */
    where: StorageQuotaWhereUniqueInput
  }

  /**
   * StorageQuota deleteMany
   */
  export type StorageQuotaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StorageQuotas to delete
     */
    where?: StorageQuotaWhereInput
    /**
     * Limit how many StorageQuotas to delete.
     */
    limit?: number
  }

  /**
   * StorageQuota without action
   */
  export type StorageQuotaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StorageQuota
     */
    select?: StorageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StorageQuota
     */
    omit?: StorageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StorageQuotaInclude<ExtArgs> | null
  }


  /**
   * Model SessionData
   */

  export type AggregateSessionData = {
    _count: SessionDataCountAggregateOutputType | null
    _min: SessionDataMinAggregateOutputType | null
    _max: SessionDataMaxAggregateOutputType | null
  }

  export type SessionDataMinAggregateOutputType = {
    id: string | null
    userId: string | null
    expiresAt: Date | null
    lastActivityAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionDataMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    expiresAt: Date | null
    lastActivityAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SessionDataCountAggregateOutputType = {
    id: number
    userId: number
    deviceInfo: number
    location: number
    expiresAt: number
    lastActivityAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SessionDataMinAggregateInputType = {
    id?: true
    userId?: true
    expiresAt?: true
    lastActivityAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionDataMaxAggregateInputType = {
    id?: true
    userId?: true
    expiresAt?: true
    lastActivityAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SessionDataCountAggregateInputType = {
    id?: true
    userId?: true
    deviceInfo?: true
    location?: true
    expiresAt?: true
    lastActivityAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SessionDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionData to aggregate.
     */
    where?: SessionDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionData to fetch.
     */
    orderBy?: SessionDataOrderByWithRelationInput | SessionDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionData
    **/
    _count?: true | SessionDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionDataMaxAggregateInputType
  }

  export type GetSessionDataAggregateType<T extends SessionDataAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionData[P]>
      : GetScalarType<T[P], AggregateSessionData[P]>
  }




  export type SessionDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionDataWhereInput
    orderBy?: SessionDataOrderByWithAggregationInput | SessionDataOrderByWithAggregationInput[]
    by: SessionDataScalarFieldEnum[] | SessionDataScalarFieldEnum
    having?: SessionDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionDataCountAggregateInputType | true
    _min?: SessionDataMinAggregateInputType
    _max?: SessionDataMaxAggregateInputType
  }

  export type SessionDataGroupByOutputType = {
    id: string
    userId: string
    deviceInfo: JsonValue
    location: JsonValue | null
    expiresAt: Date
    lastActivityAt: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SessionDataCountAggregateOutputType | null
    _min: SessionDataMinAggregateOutputType | null
    _max: SessionDataMaxAggregateOutputType | null
  }

  type GetSessionDataGroupByPayload<T extends SessionDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionDataGroupByOutputType[P]>
            : GetScalarType<T[P], SessionDataGroupByOutputType[P]>
        }
      >
    >


  export type SessionDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceInfo?: boolean
    location?: boolean
    expiresAt?: boolean
    lastActivityAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionData"]>

  export type SessionDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceInfo?: boolean
    location?: boolean
    expiresAt?: boolean
    lastActivityAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionData"]>

  export type SessionDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceInfo?: boolean
    location?: boolean
    expiresAt?: boolean
    lastActivityAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionData"]>

  export type SessionDataSelectScalar = {
    id?: boolean
    userId?: boolean
    deviceInfo?: boolean
    location?: boolean
    expiresAt?: boolean
    lastActivityAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SessionDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "deviceInfo" | "location" | "expiresAt" | "lastActivityAt" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["sessionData"]>
  export type SessionDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionData"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      deviceInfo: Prisma.JsonValue
      location: Prisma.JsonValue | null
      expiresAt: Date
      lastActivityAt: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sessionData"]>
    composites: {}
  }

  type SessionDataGetPayload<S extends boolean | null | undefined | SessionDataDefaultArgs> = $Result.GetResult<Prisma.$SessionDataPayload, S>

  type SessionDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionDataCountAggregateInputType | true
    }

  export interface SessionDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionData'], meta: { name: 'SessionData' } }
    /**
     * Find zero or one SessionData that matches the filter.
     * @param {SessionDataFindUniqueArgs} args - Arguments to find a SessionData
     * @example
     * // Get one SessionData
     * const sessionData = await prisma.sessionData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionDataFindUniqueArgs>(args: SelectSubset<T, SessionDataFindUniqueArgs<ExtArgs>>): Prisma__SessionDataClient<$Result.GetResult<Prisma.$SessionDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessionData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionDataFindUniqueOrThrowArgs} args - Arguments to find a SessionData
     * @example
     * // Get one SessionData
     * const sessionData = await prisma.sessionData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionDataFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionDataClient<$Result.GetResult<Prisma.$SessionDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionDataFindFirstArgs} args - Arguments to find a SessionData
     * @example
     * // Get one SessionData
     * const sessionData = await prisma.sessionData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionDataFindFirstArgs>(args?: SelectSubset<T, SessionDataFindFirstArgs<ExtArgs>>): Prisma__SessionDataClient<$Result.GetResult<Prisma.$SessionDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionDataFindFirstOrThrowArgs} args - Arguments to find a SessionData
     * @example
     * // Get one SessionData
     * const sessionData = await prisma.sessionData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionDataFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionDataClient<$Result.GetResult<Prisma.$SessionDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessionData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionData
     * const sessionData = await prisma.sessionData.findMany()
     * 
     * // Get first 10 SessionData
     * const sessionData = await prisma.sessionData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionDataWithIdOnly = await prisma.sessionData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionDataFindManyArgs>(args?: SelectSubset<T, SessionDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessionData.
     * @param {SessionDataCreateArgs} args - Arguments to create a SessionData.
     * @example
     * // Create one SessionData
     * const SessionData = await prisma.sessionData.create({
     *   data: {
     *     // ... data to create a SessionData
     *   }
     * })
     * 
     */
    create<T extends SessionDataCreateArgs>(args: SelectSubset<T, SessionDataCreateArgs<ExtArgs>>): Prisma__SessionDataClient<$Result.GetResult<Prisma.$SessionDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessionData.
     * @param {SessionDataCreateManyArgs} args - Arguments to create many SessionData.
     * @example
     * // Create many SessionData
     * const sessionData = await prisma.sessionData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionDataCreateManyArgs>(args?: SelectSubset<T, SessionDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionData and returns the data saved in the database.
     * @param {SessionDataCreateManyAndReturnArgs} args - Arguments to create many SessionData.
     * @example
     * // Create many SessionData
     * const sessionData = await prisma.sessionData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionData and only return the `id`
     * const sessionDataWithIdOnly = await prisma.sessionData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionDataCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SessionData.
     * @param {SessionDataDeleteArgs} args - Arguments to delete one SessionData.
     * @example
     * // Delete one SessionData
     * const SessionData = await prisma.sessionData.delete({
     *   where: {
     *     // ... filter to delete one SessionData
     *   }
     * })
     * 
     */
    delete<T extends SessionDataDeleteArgs>(args: SelectSubset<T, SessionDataDeleteArgs<ExtArgs>>): Prisma__SessionDataClient<$Result.GetResult<Prisma.$SessionDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessionData.
     * @param {SessionDataUpdateArgs} args - Arguments to update one SessionData.
     * @example
     * // Update one SessionData
     * const sessionData = await prisma.sessionData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionDataUpdateArgs>(args: SelectSubset<T, SessionDataUpdateArgs<ExtArgs>>): Prisma__SessionDataClient<$Result.GetResult<Prisma.$SessionDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessionData.
     * @param {SessionDataDeleteManyArgs} args - Arguments to filter SessionData to delete.
     * @example
     * // Delete a few SessionData
     * const { count } = await prisma.sessionData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDataDeleteManyArgs>(args?: SelectSubset<T, SessionDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionData
     * const sessionData = await prisma.sessionData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionDataUpdateManyArgs>(args: SelectSubset<T, SessionDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionData and returns the data updated in the database.
     * @param {SessionDataUpdateManyAndReturnArgs} args - Arguments to update many SessionData.
     * @example
     * // Update many SessionData
     * const sessionData = await prisma.sessionData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessionData and only return the `id`
     * const sessionDataWithIdOnly = await prisma.sessionData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionDataUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SessionData.
     * @param {SessionDataUpsertArgs} args - Arguments to update or create a SessionData.
     * @example
     * // Update or create a SessionData
     * const sessionData = await prisma.sessionData.upsert({
     *   create: {
     *     // ... data to create a SessionData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionData we want to update
     *   }
     * })
     */
    upsert<T extends SessionDataUpsertArgs>(args: SelectSubset<T, SessionDataUpsertArgs<ExtArgs>>): Prisma__SessionDataClient<$Result.GetResult<Prisma.$SessionDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessionData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionDataCountArgs} args - Arguments to filter SessionData to count.
     * @example
     * // Count the number of SessionData
     * const count = await prisma.sessionData.count({
     *   where: {
     *     // ... the filter for the SessionData we want to count
     *   }
     * })
    **/
    count<T extends SessionDataCountArgs>(
      args?: Subset<T, SessionDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionDataAggregateArgs>(args: Subset<T, SessionDataAggregateArgs>): Prisma.PrismaPromise<GetSessionDataAggregateType<T>>

    /**
     * Group by SessionData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionDataGroupByArgs['orderBy'] }
        : { orderBy?: SessionDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionData model
   */
  readonly fields: SessionDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionData model
   */
  interface SessionDataFieldRefs {
    readonly id: FieldRef<"SessionData", 'String'>
    readonly userId: FieldRef<"SessionData", 'String'>
    readonly deviceInfo: FieldRef<"SessionData", 'Json'>
    readonly location: FieldRef<"SessionData", 'Json'>
    readonly expiresAt: FieldRef<"SessionData", 'DateTime'>
    readonly lastActivityAt: FieldRef<"SessionData", 'DateTime'>
    readonly isActive: FieldRef<"SessionData", 'Boolean'>
    readonly createdAt: FieldRef<"SessionData", 'DateTime'>
    readonly updatedAt: FieldRef<"SessionData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SessionData findUnique
   */
  export type SessionDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionData
     */
    select?: SessionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionData
     */
    omit?: SessionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDataInclude<ExtArgs> | null
    /**
     * Filter, which SessionData to fetch.
     */
    where: SessionDataWhereUniqueInput
  }

  /**
   * SessionData findUniqueOrThrow
   */
  export type SessionDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionData
     */
    select?: SessionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionData
     */
    omit?: SessionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDataInclude<ExtArgs> | null
    /**
     * Filter, which SessionData to fetch.
     */
    where: SessionDataWhereUniqueInput
  }

  /**
   * SessionData findFirst
   */
  export type SessionDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionData
     */
    select?: SessionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionData
     */
    omit?: SessionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDataInclude<ExtArgs> | null
    /**
     * Filter, which SessionData to fetch.
     */
    where?: SessionDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionData to fetch.
     */
    orderBy?: SessionDataOrderByWithRelationInput | SessionDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionData.
     */
    cursor?: SessionDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionData.
     */
    distinct?: SessionDataScalarFieldEnum | SessionDataScalarFieldEnum[]
  }

  /**
   * SessionData findFirstOrThrow
   */
  export type SessionDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionData
     */
    select?: SessionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionData
     */
    omit?: SessionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDataInclude<ExtArgs> | null
    /**
     * Filter, which SessionData to fetch.
     */
    where?: SessionDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionData to fetch.
     */
    orderBy?: SessionDataOrderByWithRelationInput | SessionDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionData.
     */
    cursor?: SessionDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionData.
     */
    distinct?: SessionDataScalarFieldEnum | SessionDataScalarFieldEnum[]
  }

  /**
   * SessionData findMany
   */
  export type SessionDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionData
     */
    select?: SessionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionData
     */
    omit?: SessionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDataInclude<ExtArgs> | null
    /**
     * Filter, which SessionData to fetch.
     */
    where?: SessionDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionData to fetch.
     */
    orderBy?: SessionDataOrderByWithRelationInput | SessionDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionData.
     */
    cursor?: SessionDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionData.
     */
    skip?: number
    distinct?: SessionDataScalarFieldEnum | SessionDataScalarFieldEnum[]
  }

  /**
   * SessionData create
   */
  export type SessionDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionData
     */
    select?: SessionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionData
     */
    omit?: SessionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDataInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionData.
     */
    data: XOR<SessionDataCreateInput, SessionDataUncheckedCreateInput>
  }

  /**
   * SessionData createMany
   */
  export type SessionDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionData.
     */
    data: SessionDataCreateManyInput | SessionDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionData createManyAndReturn
   */
  export type SessionDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionData
     */
    select?: SessionDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionData
     */
    omit?: SessionDataOmit<ExtArgs> | null
    /**
     * The data used to create many SessionData.
     */
    data: SessionDataCreateManyInput | SessionDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionData update
   */
  export type SessionDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionData
     */
    select?: SessionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionData
     */
    omit?: SessionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDataInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionData.
     */
    data: XOR<SessionDataUpdateInput, SessionDataUncheckedUpdateInput>
    /**
     * Choose, which SessionData to update.
     */
    where: SessionDataWhereUniqueInput
  }

  /**
   * SessionData updateMany
   */
  export type SessionDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionData.
     */
    data: XOR<SessionDataUpdateManyMutationInput, SessionDataUncheckedUpdateManyInput>
    /**
     * Filter which SessionData to update
     */
    where?: SessionDataWhereInput
    /**
     * Limit how many SessionData to update.
     */
    limit?: number
  }

  /**
   * SessionData updateManyAndReturn
   */
  export type SessionDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionData
     */
    select?: SessionDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionData
     */
    omit?: SessionDataOmit<ExtArgs> | null
    /**
     * The data used to update SessionData.
     */
    data: XOR<SessionDataUpdateManyMutationInput, SessionDataUncheckedUpdateManyInput>
    /**
     * Filter which SessionData to update
     */
    where?: SessionDataWhereInput
    /**
     * Limit how many SessionData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionData upsert
   */
  export type SessionDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionData
     */
    select?: SessionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionData
     */
    omit?: SessionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDataInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionData to update in case it exists.
     */
    where: SessionDataWhereUniqueInput
    /**
     * In case the SessionData found by the `where` argument doesn't exist, create a new SessionData with this data.
     */
    create: XOR<SessionDataCreateInput, SessionDataUncheckedCreateInput>
    /**
     * In case the SessionData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionDataUpdateInput, SessionDataUncheckedUpdateInput>
  }

  /**
   * SessionData delete
   */
  export type SessionDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionData
     */
    select?: SessionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionData
     */
    omit?: SessionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDataInclude<ExtArgs> | null
    /**
     * Filter which SessionData to delete.
     */
    where: SessionDataWhereUniqueInput
  }

  /**
   * SessionData deleteMany
   */
  export type SessionDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionData to delete
     */
    where?: SessionDataWhereInput
    /**
     * Limit how many SessionData to delete.
     */
    limit?: number
  }

  /**
   * SessionData without action
   */
  export type SessionDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionData
     */
    select?: SessionDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionData
     */
    omit?: SessionDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDataInclude<ExtArgs> | null
  }


  /**
   * Model MfaSettings
   */

  export type AggregateMfaSettings = {
    _count: MfaSettingsCountAggregateOutputType | null
    _min: MfaSettingsMinAggregateOutputType | null
    _max: MfaSettingsMaxAggregateOutputType | null
  }

  export type MfaSettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    isEnabled: boolean | null
    method: $Enums.MfaMethod | null
    secret: string | null
    lastUsedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MfaSettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    isEnabled: boolean | null
    method: $Enums.MfaMethod | null
    secret: string | null
    lastUsedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MfaSettingsCountAggregateOutputType = {
    id: number
    userId: number
    isEnabled: number
    method: number
    secret: number
    backupCodes: number
    lastUsedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MfaSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    isEnabled?: true
    method?: true
    secret?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MfaSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    isEnabled?: true
    method?: true
    secret?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MfaSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    isEnabled?: true
    method?: true
    secret?: true
    backupCodes?: true
    lastUsedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MfaSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MfaSettings to aggregate.
     */
    where?: MfaSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MfaSettings to fetch.
     */
    orderBy?: MfaSettingsOrderByWithRelationInput | MfaSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MfaSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MfaSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MfaSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MfaSettings
    **/
    _count?: true | MfaSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MfaSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MfaSettingsMaxAggregateInputType
  }

  export type GetMfaSettingsAggregateType<T extends MfaSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateMfaSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMfaSettings[P]>
      : GetScalarType<T[P], AggregateMfaSettings[P]>
  }




  export type MfaSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MfaSettingsWhereInput
    orderBy?: MfaSettingsOrderByWithAggregationInput | MfaSettingsOrderByWithAggregationInput[]
    by: MfaSettingsScalarFieldEnum[] | MfaSettingsScalarFieldEnum
    having?: MfaSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MfaSettingsCountAggregateInputType | true
    _min?: MfaSettingsMinAggregateInputType
    _max?: MfaSettingsMaxAggregateInputType
  }

  export type MfaSettingsGroupByOutputType = {
    id: string
    userId: string
    isEnabled: boolean
    method: $Enums.MfaMethod
    secret: string | null
    backupCodes: string[]
    lastUsedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MfaSettingsCountAggregateOutputType | null
    _min: MfaSettingsMinAggregateOutputType | null
    _max: MfaSettingsMaxAggregateOutputType | null
  }

  type GetMfaSettingsGroupByPayload<T extends MfaSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MfaSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MfaSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MfaSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], MfaSettingsGroupByOutputType[P]>
        }
      >
    >


  export type MfaSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    isEnabled?: boolean
    method?: boolean
    secret?: boolean
    backupCodes?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mfaSettings"]>

  export type MfaSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    isEnabled?: boolean
    method?: boolean
    secret?: boolean
    backupCodes?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mfaSettings"]>

  export type MfaSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    isEnabled?: boolean
    method?: boolean
    secret?: boolean
    backupCodes?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mfaSettings"]>

  export type MfaSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    isEnabled?: boolean
    method?: boolean
    secret?: boolean
    backupCodes?: boolean
    lastUsedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MfaSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "isEnabled" | "method" | "secret" | "backupCodes" | "lastUsedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["mfaSettings"]>
  export type MfaSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MfaSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MfaSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MfaSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MfaSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      isEnabled: boolean
      method: $Enums.MfaMethod
      secret: string | null
      backupCodes: string[]
      lastUsedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mfaSettings"]>
    composites: {}
  }

  type MfaSettingsGetPayload<S extends boolean | null | undefined | MfaSettingsDefaultArgs> = $Result.GetResult<Prisma.$MfaSettingsPayload, S>

  type MfaSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MfaSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MfaSettingsCountAggregateInputType | true
    }

  export interface MfaSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MfaSettings'], meta: { name: 'MfaSettings' } }
    /**
     * Find zero or one MfaSettings that matches the filter.
     * @param {MfaSettingsFindUniqueArgs} args - Arguments to find a MfaSettings
     * @example
     * // Get one MfaSettings
     * const mfaSettings = await prisma.mfaSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MfaSettingsFindUniqueArgs>(args: SelectSubset<T, MfaSettingsFindUniqueArgs<ExtArgs>>): Prisma__MfaSettingsClient<$Result.GetResult<Prisma.$MfaSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MfaSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MfaSettingsFindUniqueOrThrowArgs} args - Arguments to find a MfaSettings
     * @example
     * // Get one MfaSettings
     * const mfaSettings = await prisma.mfaSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MfaSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, MfaSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MfaSettingsClient<$Result.GetResult<Prisma.$MfaSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MfaSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MfaSettingsFindFirstArgs} args - Arguments to find a MfaSettings
     * @example
     * // Get one MfaSettings
     * const mfaSettings = await prisma.mfaSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MfaSettingsFindFirstArgs>(args?: SelectSubset<T, MfaSettingsFindFirstArgs<ExtArgs>>): Prisma__MfaSettingsClient<$Result.GetResult<Prisma.$MfaSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MfaSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MfaSettingsFindFirstOrThrowArgs} args - Arguments to find a MfaSettings
     * @example
     * // Get one MfaSettings
     * const mfaSettings = await prisma.mfaSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MfaSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, MfaSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__MfaSettingsClient<$Result.GetResult<Prisma.$MfaSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MfaSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MfaSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MfaSettings
     * const mfaSettings = await prisma.mfaSettings.findMany()
     * 
     * // Get first 10 MfaSettings
     * const mfaSettings = await prisma.mfaSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mfaSettingsWithIdOnly = await prisma.mfaSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MfaSettingsFindManyArgs>(args?: SelectSubset<T, MfaSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MfaSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MfaSettings.
     * @param {MfaSettingsCreateArgs} args - Arguments to create a MfaSettings.
     * @example
     * // Create one MfaSettings
     * const MfaSettings = await prisma.mfaSettings.create({
     *   data: {
     *     // ... data to create a MfaSettings
     *   }
     * })
     * 
     */
    create<T extends MfaSettingsCreateArgs>(args: SelectSubset<T, MfaSettingsCreateArgs<ExtArgs>>): Prisma__MfaSettingsClient<$Result.GetResult<Prisma.$MfaSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MfaSettings.
     * @param {MfaSettingsCreateManyArgs} args - Arguments to create many MfaSettings.
     * @example
     * // Create many MfaSettings
     * const mfaSettings = await prisma.mfaSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MfaSettingsCreateManyArgs>(args?: SelectSubset<T, MfaSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MfaSettings and returns the data saved in the database.
     * @param {MfaSettingsCreateManyAndReturnArgs} args - Arguments to create many MfaSettings.
     * @example
     * // Create many MfaSettings
     * const mfaSettings = await prisma.mfaSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MfaSettings and only return the `id`
     * const mfaSettingsWithIdOnly = await prisma.mfaSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MfaSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, MfaSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MfaSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MfaSettings.
     * @param {MfaSettingsDeleteArgs} args - Arguments to delete one MfaSettings.
     * @example
     * // Delete one MfaSettings
     * const MfaSettings = await prisma.mfaSettings.delete({
     *   where: {
     *     // ... filter to delete one MfaSettings
     *   }
     * })
     * 
     */
    delete<T extends MfaSettingsDeleteArgs>(args: SelectSubset<T, MfaSettingsDeleteArgs<ExtArgs>>): Prisma__MfaSettingsClient<$Result.GetResult<Prisma.$MfaSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MfaSettings.
     * @param {MfaSettingsUpdateArgs} args - Arguments to update one MfaSettings.
     * @example
     * // Update one MfaSettings
     * const mfaSettings = await prisma.mfaSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MfaSettingsUpdateArgs>(args: SelectSubset<T, MfaSettingsUpdateArgs<ExtArgs>>): Prisma__MfaSettingsClient<$Result.GetResult<Prisma.$MfaSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MfaSettings.
     * @param {MfaSettingsDeleteManyArgs} args - Arguments to filter MfaSettings to delete.
     * @example
     * // Delete a few MfaSettings
     * const { count } = await prisma.mfaSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MfaSettingsDeleteManyArgs>(args?: SelectSubset<T, MfaSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MfaSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MfaSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MfaSettings
     * const mfaSettings = await prisma.mfaSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MfaSettingsUpdateManyArgs>(args: SelectSubset<T, MfaSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MfaSettings and returns the data updated in the database.
     * @param {MfaSettingsUpdateManyAndReturnArgs} args - Arguments to update many MfaSettings.
     * @example
     * // Update many MfaSettings
     * const mfaSettings = await prisma.mfaSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MfaSettings and only return the `id`
     * const mfaSettingsWithIdOnly = await prisma.mfaSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MfaSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, MfaSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MfaSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MfaSettings.
     * @param {MfaSettingsUpsertArgs} args - Arguments to update or create a MfaSettings.
     * @example
     * // Update or create a MfaSettings
     * const mfaSettings = await prisma.mfaSettings.upsert({
     *   create: {
     *     // ... data to create a MfaSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MfaSettings we want to update
     *   }
     * })
     */
    upsert<T extends MfaSettingsUpsertArgs>(args: SelectSubset<T, MfaSettingsUpsertArgs<ExtArgs>>): Prisma__MfaSettingsClient<$Result.GetResult<Prisma.$MfaSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MfaSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MfaSettingsCountArgs} args - Arguments to filter MfaSettings to count.
     * @example
     * // Count the number of MfaSettings
     * const count = await prisma.mfaSettings.count({
     *   where: {
     *     // ... the filter for the MfaSettings we want to count
     *   }
     * })
    **/
    count<T extends MfaSettingsCountArgs>(
      args?: Subset<T, MfaSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MfaSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MfaSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MfaSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MfaSettingsAggregateArgs>(args: Subset<T, MfaSettingsAggregateArgs>): Prisma.PrismaPromise<GetMfaSettingsAggregateType<T>>

    /**
     * Group by MfaSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MfaSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MfaSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MfaSettingsGroupByArgs['orderBy'] }
        : { orderBy?: MfaSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MfaSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMfaSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MfaSettings model
   */
  readonly fields: MfaSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MfaSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MfaSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MfaSettings model
   */
  interface MfaSettingsFieldRefs {
    readonly id: FieldRef<"MfaSettings", 'String'>
    readonly userId: FieldRef<"MfaSettings", 'String'>
    readonly isEnabled: FieldRef<"MfaSettings", 'Boolean'>
    readonly method: FieldRef<"MfaSettings", 'MfaMethod'>
    readonly secret: FieldRef<"MfaSettings", 'String'>
    readonly backupCodes: FieldRef<"MfaSettings", 'String[]'>
    readonly lastUsedAt: FieldRef<"MfaSettings", 'DateTime'>
    readonly createdAt: FieldRef<"MfaSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"MfaSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MfaSettings findUnique
   */
  export type MfaSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaSettings
     */
    select?: MfaSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaSettings
     */
    omit?: MfaSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaSettingsInclude<ExtArgs> | null
    /**
     * Filter, which MfaSettings to fetch.
     */
    where: MfaSettingsWhereUniqueInput
  }

  /**
   * MfaSettings findUniqueOrThrow
   */
  export type MfaSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaSettings
     */
    select?: MfaSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaSettings
     */
    omit?: MfaSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaSettingsInclude<ExtArgs> | null
    /**
     * Filter, which MfaSettings to fetch.
     */
    where: MfaSettingsWhereUniqueInput
  }

  /**
   * MfaSettings findFirst
   */
  export type MfaSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaSettings
     */
    select?: MfaSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaSettings
     */
    omit?: MfaSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaSettingsInclude<ExtArgs> | null
    /**
     * Filter, which MfaSettings to fetch.
     */
    where?: MfaSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MfaSettings to fetch.
     */
    orderBy?: MfaSettingsOrderByWithRelationInput | MfaSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MfaSettings.
     */
    cursor?: MfaSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MfaSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MfaSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MfaSettings.
     */
    distinct?: MfaSettingsScalarFieldEnum | MfaSettingsScalarFieldEnum[]
  }

  /**
   * MfaSettings findFirstOrThrow
   */
  export type MfaSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaSettings
     */
    select?: MfaSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaSettings
     */
    omit?: MfaSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaSettingsInclude<ExtArgs> | null
    /**
     * Filter, which MfaSettings to fetch.
     */
    where?: MfaSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MfaSettings to fetch.
     */
    orderBy?: MfaSettingsOrderByWithRelationInput | MfaSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MfaSettings.
     */
    cursor?: MfaSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MfaSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MfaSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MfaSettings.
     */
    distinct?: MfaSettingsScalarFieldEnum | MfaSettingsScalarFieldEnum[]
  }

  /**
   * MfaSettings findMany
   */
  export type MfaSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaSettings
     */
    select?: MfaSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaSettings
     */
    omit?: MfaSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaSettingsInclude<ExtArgs> | null
    /**
     * Filter, which MfaSettings to fetch.
     */
    where?: MfaSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MfaSettings to fetch.
     */
    orderBy?: MfaSettingsOrderByWithRelationInput | MfaSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MfaSettings.
     */
    cursor?: MfaSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MfaSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MfaSettings.
     */
    skip?: number
    distinct?: MfaSettingsScalarFieldEnum | MfaSettingsScalarFieldEnum[]
  }

  /**
   * MfaSettings create
   */
  export type MfaSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaSettings
     */
    select?: MfaSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaSettings
     */
    omit?: MfaSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a MfaSettings.
     */
    data: XOR<MfaSettingsCreateInput, MfaSettingsUncheckedCreateInput>
  }

  /**
   * MfaSettings createMany
   */
  export type MfaSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MfaSettings.
     */
    data: MfaSettingsCreateManyInput | MfaSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MfaSettings createManyAndReturn
   */
  export type MfaSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaSettings
     */
    select?: MfaSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MfaSettings
     */
    omit?: MfaSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many MfaSettings.
     */
    data: MfaSettingsCreateManyInput | MfaSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MfaSettings update
   */
  export type MfaSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaSettings
     */
    select?: MfaSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaSettings
     */
    omit?: MfaSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a MfaSettings.
     */
    data: XOR<MfaSettingsUpdateInput, MfaSettingsUncheckedUpdateInput>
    /**
     * Choose, which MfaSettings to update.
     */
    where: MfaSettingsWhereUniqueInput
  }

  /**
   * MfaSettings updateMany
   */
  export type MfaSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MfaSettings.
     */
    data: XOR<MfaSettingsUpdateManyMutationInput, MfaSettingsUncheckedUpdateManyInput>
    /**
     * Filter which MfaSettings to update
     */
    where?: MfaSettingsWhereInput
    /**
     * Limit how many MfaSettings to update.
     */
    limit?: number
  }

  /**
   * MfaSettings updateManyAndReturn
   */
  export type MfaSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaSettings
     */
    select?: MfaSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MfaSettings
     */
    omit?: MfaSettingsOmit<ExtArgs> | null
    /**
     * The data used to update MfaSettings.
     */
    data: XOR<MfaSettingsUpdateManyMutationInput, MfaSettingsUncheckedUpdateManyInput>
    /**
     * Filter which MfaSettings to update
     */
    where?: MfaSettingsWhereInput
    /**
     * Limit how many MfaSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MfaSettings upsert
   */
  export type MfaSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaSettings
     */
    select?: MfaSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaSettings
     */
    omit?: MfaSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the MfaSettings to update in case it exists.
     */
    where: MfaSettingsWhereUniqueInput
    /**
     * In case the MfaSettings found by the `where` argument doesn't exist, create a new MfaSettings with this data.
     */
    create: XOR<MfaSettingsCreateInput, MfaSettingsUncheckedCreateInput>
    /**
     * In case the MfaSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MfaSettingsUpdateInput, MfaSettingsUncheckedUpdateInput>
  }

  /**
   * MfaSettings delete
   */
  export type MfaSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaSettings
     */
    select?: MfaSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaSettings
     */
    omit?: MfaSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaSettingsInclude<ExtArgs> | null
    /**
     * Filter which MfaSettings to delete.
     */
    where: MfaSettingsWhereUniqueInput
  }

  /**
   * MfaSettings deleteMany
   */
  export type MfaSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MfaSettings to delete
     */
    where?: MfaSettingsWhereInput
    /**
     * Limit how many MfaSettings to delete.
     */
    limit?: number
  }

  /**
   * MfaSettings without action
   */
  export type MfaSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MfaSettings
     */
    select?: MfaSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MfaSettings
     */
    omit?: MfaSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MfaSettingsInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    isUsed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    isUsed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    isUsed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    isUsed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    isUsed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    isUsed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    isUsed: boolean
    createdAt: Date
    updatedAt: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    isUsed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt" | "isUsed" | "createdAt" | "updatedAt", ExtArgs["result"]["passwordResetToken"]>
  export type PasswordResetTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      isUsed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens and returns the data updated in the database.
     * @param {PasswordResetTokenUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetTokens.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly userId: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expiresAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly isUsed: FieldRef<"PasswordResetToken", 'Boolean'>
    readonly createdAt: FieldRef<"PasswordResetToken", 'DateTime'>
    readonly updatedAt: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken updateManyAndReturn
   */
  export type PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetTokenInclude<ExtArgs> | null
  }


  /**
   * Model AnalyticsEvent
   */

  export type AggregateAnalyticsEvent = {
    _count: AnalyticsEventCountAggregateOutputType | null
    _min: AnalyticsEventMinAggregateOutputType | null
    _max: AnalyticsEventMaxAggregateOutputType | null
  }

  export type AnalyticsEventMinAggregateOutputType = {
    id: string | null
    eventType: string | null
    userId: string | null
    organizationId: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type AnalyticsEventMaxAggregateOutputType = {
    id: string | null
    eventType: string | null
    userId: string | null
    organizationId: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type AnalyticsEventCountAggregateOutputType = {
    id: number
    eventType: number
    userId: number
    organizationId: number
    properties: number
    timestamp: number
    createdAt: number
    _all: number
  }


  export type AnalyticsEventMinAggregateInputType = {
    id?: true
    eventType?: true
    userId?: true
    organizationId?: true
    timestamp?: true
    createdAt?: true
  }

  export type AnalyticsEventMaxAggregateInputType = {
    id?: true
    eventType?: true
    userId?: true
    organizationId?: true
    timestamp?: true
    createdAt?: true
  }

  export type AnalyticsEventCountAggregateInputType = {
    id?: true
    eventType?: true
    userId?: true
    organizationId?: true
    properties?: true
    timestamp?: true
    createdAt?: true
    _all?: true
  }

  export type AnalyticsEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsEvent to aggregate.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsEvents
    **/
    _count?: true | AnalyticsEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsEventMaxAggregateInputType
  }

  export type GetAnalyticsEventAggregateType<T extends AnalyticsEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsEvent[P]>
      : GetScalarType<T[P], AggregateAnalyticsEvent[P]>
  }




  export type AnalyticsEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsEventWhereInput
    orderBy?: AnalyticsEventOrderByWithAggregationInput | AnalyticsEventOrderByWithAggregationInput[]
    by: AnalyticsEventScalarFieldEnum[] | AnalyticsEventScalarFieldEnum
    having?: AnalyticsEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsEventCountAggregateInputType | true
    _min?: AnalyticsEventMinAggregateInputType
    _max?: AnalyticsEventMaxAggregateInputType
  }

  export type AnalyticsEventGroupByOutputType = {
    id: string
    eventType: string
    userId: string | null
    organizationId: string
    properties: JsonValue
    timestamp: Date
    createdAt: Date
    _count: AnalyticsEventCountAggregateOutputType | null
    _min: AnalyticsEventMinAggregateOutputType | null
    _max: AnalyticsEventMaxAggregateOutputType | null
  }

  type GetAnalyticsEventGroupByPayload<T extends AnalyticsEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsEventGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsEventGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    userId?: boolean
    organizationId?: boolean
    properties?: boolean
    timestamp?: boolean
    createdAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    userId?: boolean
    organizationId?: boolean
    properties?: boolean
    timestamp?: boolean
    createdAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventType?: boolean
    userId?: boolean
    organizationId?: boolean
    properties?: boolean
    timestamp?: boolean
    createdAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsEvent"]>

  export type AnalyticsEventSelectScalar = {
    id?: boolean
    eventType?: boolean
    userId?: boolean
    organizationId?: boolean
    properties?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }

  export type AnalyticsEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventType" | "userId" | "organizationId" | "properties" | "timestamp" | "createdAt", ExtArgs["result"]["analyticsEvent"]>
  export type AnalyticsEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type AnalyticsEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type AnalyticsEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $AnalyticsEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsEvent"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventType: string
      userId: string | null
      organizationId: string
      properties: Prisma.JsonValue
      timestamp: Date
      createdAt: Date
    }, ExtArgs["result"]["analyticsEvent"]>
    composites: {}
  }

  type AnalyticsEventGetPayload<S extends boolean | null | undefined | AnalyticsEventDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsEventPayload, S>

  type AnalyticsEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsEventCountAggregateInputType | true
    }

  export interface AnalyticsEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsEvent'], meta: { name: 'AnalyticsEvent' } }
    /**
     * Find zero or one AnalyticsEvent that matches the filter.
     * @param {AnalyticsEventFindUniqueArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsEventFindUniqueArgs>(args: SelectSubset<T, AnalyticsEventFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnalyticsEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsEventFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindFirstArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsEventFindFirstArgs>(args?: SelectSubset<T, AnalyticsEventFindFirstArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnalyticsEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindFirstOrThrowArgs} args - Arguments to find a AnalyticsEvent
     * @example
     * // Get one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnalyticsEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsEvents
     * const analyticsEvents = await prisma.analyticsEvent.findMany()
     * 
     * // Get first 10 AnalyticsEvents
     * const analyticsEvents = await prisma.analyticsEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsEventFindManyArgs>(args?: SelectSubset<T, AnalyticsEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnalyticsEvent.
     * @param {AnalyticsEventCreateArgs} args - Arguments to create a AnalyticsEvent.
     * @example
     * // Create one AnalyticsEvent
     * const AnalyticsEvent = await prisma.analyticsEvent.create({
     *   data: {
     *     // ... data to create a AnalyticsEvent
     *   }
     * })
     * 
     */
    create<T extends AnalyticsEventCreateArgs>(args: SelectSubset<T, AnalyticsEventCreateArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnalyticsEvents.
     * @param {AnalyticsEventCreateManyArgs} args - Arguments to create many AnalyticsEvents.
     * @example
     * // Create many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsEventCreateManyArgs>(args?: SelectSubset<T, AnalyticsEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsEvents and returns the data saved in the database.
     * @param {AnalyticsEventCreateManyAndReturnArgs} args - Arguments to create many AnalyticsEvents.
     * @example
     * // Create many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsEvents and only return the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsEventCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnalyticsEvent.
     * @param {AnalyticsEventDeleteArgs} args - Arguments to delete one AnalyticsEvent.
     * @example
     * // Delete one AnalyticsEvent
     * const AnalyticsEvent = await prisma.analyticsEvent.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsEvent
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsEventDeleteArgs>(args: SelectSubset<T, AnalyticsEventDeleteArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnalyticsEvent.
     * @param {AnalyticsEventUpdateArgs} args - Arguments to update one AnalyticsEvent.
     * @example
     * // Update one AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsEventUpdateArgs>(args: SelectSubset<T, AnalyticsEventUpdateArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnalyticsEvents.
     * @param {AnalyticsEventDeleteManyArgs} args - Arguments to filter AnalyticsEvents to delete.
     * @example
     * // Delete a few AnalyticsEvents
     * const { count } = await prisma.analyticsEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsEventDeleteManyArgs>(args?: SelectSubset<T, AnalyticsEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsEventUpdateManyArgs>(args: SelectSubset<T, AnalyticsEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsEvents and returns the data updated in the database.
     * @param {AnalyticsEventUpdateManyAndReturnArgs} args - Arguments to update many AnalyticsEvents.
     * @example
     * // Update many AnalyticsEvents
     * const analyticsEvent = await prisma.analyticsEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnalyticsEvents and only return the `id`
     * const analyticsEventWithIdOnly = await prisma.analyticsEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalyticsEventUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalyticsEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnalyticsEvent.
     * @param {AnalyticsEventUpsertArgs} args - Arguments to update or create a AnalyticsEvent.
     * @example
     * // Update or create a AnalyticsEvent
     * const analyticsEvent = await prisma.analyticsEvent.upsert({
     *   create: {
     *     // ... data to create a AnalyticsEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsEvent we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsEventUpsertArgs>(args: SelectSubset<T, AnalyticsEventUpsertArgs<ExtArgs>>): Prisma__AnalyticsEventClient<$Result.GetResult<Prisma.$AnalyticsEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnalyticsEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventCountArgs} args - Arguments to filter AnalyticsEvents to count.
     * @example
     * // Count the number of AnalyticsEvents
     * const count = await prisma.analyticsEvent.count({
     *   where: {
     *     // ... the filter for the AnalyticsEvents we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsEventCountArgs>(
      args?: Subset<T, AnalyticsEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsEventAggregateArgs>(args: Subset<T, AnalyticsEventAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsEventAggregateType<T>>

    /**
     * Group by AnalyticsEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsEventGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsEvent model
   */
  readonly fields: AnalyticsEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsEvent model
   */
  interface AnalyticsEventFieldRefs {
    readonly id: FieldRef<"AnalyticsEvent", 'String'>
    readonly eventType: FieldRef<"AnalyticsEvent", 'String'>
    readonly userId: FieldRef<"AnalyticsEvent", 'String'>
    readonly organizationId: FieldRef<"AnalyticsEvent", 'String'>
    readonly properties: FieldRef<"AnalyticsEvent", 'Json'>
    readonly timestamp: FieldRef<"AnalyticsEvent", 'DateTime'>
    readonly createdAt: FieldRef<"AnalyticsEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsEvent findUnique
   */
  export type AnalyticsEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent findUniqueOrThrow
   */
  export type AnalyticsEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent findFirst
   */
  export type AnalyticsEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsEvents.
     */
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent findFirstOrThrow
   */
  export type AnalyticsEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvent to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsEvents.
     */
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent findMany
   */
  export type AnalyticsEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsEvents to fetch.
     */
    where?: AnalyticsEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsEvents to fetch.
     */
    orderBy?: AnalyticsEventOrderByWithRelationInput | AnalyticsEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsEvents.
     */
    cursor?: AnalyticsEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsEvents.
     */
    skip?: number
    distinct?: AnalyticsEventScalarFieldEnum | AnalyticsEventScalarFieldEnum[]
  }

  /**
   * AnalyticsEvent create
   */
  export type AnalyticsEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsEvent.
     */
    data: XOR<AnalyticsEventCreateInput, AnalyticsEventUncheckedCreateInput>
  }

  /**
   * AnalyticsEvent createMany
   */
  export type AnalyticsEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsEvents.
     */
    data: AnalyticsEventCreateManyInput | AnalyticsEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsEvent createManyAndReturn
   */
  export type AnalyticsEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The data used to create many AnalyticsEvents.
     */
    data: AnalyticsEventCreateManyInput | AnalyticsEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalyticsEvent update
   */
  export type AnalyticsEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsEvent.
     */
    data: XOR<AnalyticsEventUpdateInput, AnalyticsEventUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsEvent to update.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent updateMany
   */
  export type AnalyticsEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsEvents.
     */
    data: XOR<AnalyticsEventUpdateManyMutationInput, AnalyticsEventUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsEvents to update
     */
    where?: AnalyticsEventWhereInput
    /**
     * Limit how many AnalyticsEvents to update.
     */
    limit?: number
  }

  /**
   * AnalyticsEvent updateManyAndReturn
   */
  export type AnalyticsEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * The data used to update AnalyticsEvents.
     */
    data: XOR<AnalyticsEventUpdateManyMutationInput, AnalyticsEventUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsEvents to update
     */
    where?: AnalyticsEventWhereInput
    /**
     * Limit how many AnalyticsEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalyticsEvent upsert
   */
  export type AnalyticsEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsEvent to update in case it exists.
     */
    where: AnalyticsEventWhereUniqueInput
    /**
     * In case the AnalyticsEvent found by the `where` argument doesn't exist, create a new AnalyticsEvent with this data.
     */
    create: XOR<AnalyticsEventCreateInput, AnalyticsEventUncheckedCreateInput>
    /**
     * In case the AnalyticsEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsEventUpdateInput, AnalyticsEventUncheckedUpdateInput>
  }

  /**
   * AnalyticsEvent delete
   */
  export type AnalyticsEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
    /**
     * Filter which AnalyticsEvent to delete.
     */
    where: AnalyticsEventWhereUniqueInput
  }

  /**
   * AnalyticsEvent deleteMany
   */
  export type AnalyticsEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsEvents to delete
     */
    where?: AnalyticsEventWhereInput
    /**
     * Limit how many AnalyticsEvents to delete.
     */
    limit?: number
  }

  /**
   * AnalyticsEvent without action
   */
  export type AnalyticsEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsEvent
     */
    select?: AnalyticsEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnalyticsEvent
     */
    omit?: AnalyticsEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsEventInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    userId: string | null
    organizationId: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    userId: string | null
    organizationId: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    action: number
    entityType: number
    entityId: number
    userId: number
    organizationId: number
    changes: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    userId?: true
    organizationId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    userId?: true
    organizationId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    userId?: true
    organizationId?: true
    changes?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    action: string
    entityType: string
    entityId: string
    userId: string
    organizationId: string
    changes: JsonValue | null
    metadata: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    userId?: boolean
    organizationId?: boolean
    changes?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    userId?: boolean
    organizationId?: boolean
    changes?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    userId?: boolean
    organizationId?: boolean
    changes?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    userId?: boolean
    organizationId?: boolean
    changes?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "entityType" | "entityId" | "userId" | "organizationId" | "changes" | "metadata" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      organization: Prisma.$OrganizationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      entityType: string
      entityId: string
      userId: string
      organizationId: string
      changes: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly organizationId: FieldRef<"AuditLog", 'String'>
    readonly changes: FieldRef<"AuditLog", 'Json'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    domain: 'domain',
    isActive: 'isActive',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    organizationId: 'organizationId',
    isActive: 'isActive',
    lastLoginAt: 'lastLoginAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    location: 'location',
    organizationId: 'organizationId',
    status: 'status',
    contractValue: 'contractValue',
    contractType: 'contractType',
    startDate: 'startDate',
    plannedCompletion: 'plannedCompletion',
    currentCompletion: 'currentCompletion',
    healthScore: 'healthScore',
    projectManagerId: 'projectManagerId',
    metadata: 'metadata',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const DelayEventScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    activityId: 'activityId',
    activityName: 'activityName',
    detectionDate: 'detectionDate',
    delayDays: 'delayDays',
    causeType: 'causeType',
    probabilityScore: 'probabilityScore',
    evidenceStrength: 'evidenceStrength',
    status: 'status',
    description: 'description',
    estimatedCost: 'estimatedCost',
    criticalPath: 'criticalPath',
    detectedById: 'detectedById',
    metadata: 'metadata',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DelayEventScalarFieldEnum = (typeof DelayEventScalarFieldEnum)[keyof typeof DelayEventScalarFieldEnum]


  export const ClaimScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    delayEventId: 'delayEventId',
    referenceNumber: 'referenceNumber',
    title: 'title',
    description: 'description',
    submissionDate: 'submissionDate',
    noticeDate: 'noticeDate',
    claimAmount: 'claimAmount',
    timeImpactDays: 'timeImpactDays',
    status: 'status',
    responseDueDate: 'responseDueDate',
    submittedById: 'submittedById',
    workflow: 'workflow',
    metadata: 'metadata',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClaimScalarFieldEnum = (typeof ClaimScalarFieldEnum)[keyof typeof ClaimScalarFieldEnum]


  export const EvidenceScalarFieldEnum: {
    id: 'id',
    delayEventId: 'delayEventId',
    claimId: 'claimId',
    type: 'type',
    title: 'title',
    description: 'description',
    sourceSystem: 'sourceSystem',
    filePath: 'filePath',
    fileId: 'fileId',
    relevanceScore: 'relevanceScore',
    extractedText: 'extractedText',
    metadata: 'metadata',
    uploadedById: 'uploadedById',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EvidenceScalarFieldEnum = (typeof EvidenceScalarFieldEnum)[keyof typeof EvidenceScalarFieldEnum]


  export const ScheduleScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    name: 'name',
    description: 'description',
    format: 'format',
    version: 'version',
    baselineDate: 'baselineDate',
    statusDate: 'statusDate',
    filePath: 'filePath',
    fileId: 'fileId',
    metadata: 'metadata',
    isBaseline: 'isBaseline',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum]


  export const ActionItemScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    priority: 'priority',
    dueDate: 'dueDate',
    projectId: 'projectId',
    assignedToId: 'assignedToId',
    status: 'status',
    completedAt: 'completedAt',
    metadata: 'metadata',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ActionItemScalarFieldEnum = (typeof ActionItemScalarFieldEnum)[keyof typeof ActionItemScalarFieldEnum]


  export const FileMetadataScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    originalName: 'originalName',
    mimeType: 'mimeType',
    size: 'size',
    checksum: 'checksum',
    organizationId: 'organizationId',
    uploadedById: 'uploadedById',
    path: 'path',
    isPublic: 'isPublic',
    tags: 'tags',
    metadata: 'metadata',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FileMetadataScalarFieldEnum = (typeof FileMetadataScalarFieldEnum)[keyof typeof FileMetadataScalarFieldEnum]


  export const StorageQuotaScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    usedBytes: 'usedBytes',
    limitBytes: 'limitBytes',
    fileCount: 'fileCount',
    maxFileCount: 'maxFileCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StorageQuotaScalarFieldEnum = (typeof StorageQuotaScalarFieldEnum)[keyof typeof StorageQuotaScalarFieldEnum]


  export const SessionDataScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    deviceInfo: 'deviceInfo',
    location: 'location',
    expiresAt: 'expiresAt',
    lastActivityAt: 'lastActivityAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SessionDataScalarFieldEnum = (typeof SessionDataScalarFieldEnum)[keyof typeof SessionDataScalarFieldEnum]


  export const MfaSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    isEnabled: 'isEnabled',
    method: 'method',
    secret: 'secret',
    backupCodes: 'backupCodes',
    lastUsedAt: 'lastUsedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MfaSettingsScalarFieldEnum = (typeof MfaSettingsScalarFieldEnum)[keyof typeof MfaSettingsScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    isUsed: 'isUsed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const AnalyticsEventScalarFieldEnum: {
    id: 'id',
    eventType: 'eventType',
    userId: 'userId',
    organizationId: 'organizationId',
    properties: 'properties',
    timestamp: 'timestamp',
    createdAt: 'createdAt'
  };

  export type AnalyticsEventScalarFieldEnum = (typeof AnalyticsEventScalarFieldEnum)[keyof typeof AnalyticsEventScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    userId: 'userId',
    organizationId: 'organizationId',
    changes: 'changes',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'ProjectStatus'
   */
  export type EnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus'>
    


  /**
   * Reference to a field of type 'ProjectStatus[]'
   */
  export type ListEnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ContractType'
   */
  export type EnumContractTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractType'>
    


  /**
   * Reference to a field of type 'ContractType[]'
   */
  export type ListEnumContractTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContractType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DelayType'
   */
  export type EnumDelayTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DelayType'>
    


  /**
   * Reference to a field of type 'DelayType[]'
   */
  export type ListEnumDelayTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DelayType[]'>
    


  /**
   * Reference to a field of type 'DelayStatus'
   */
  export type EnumDelayStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DelayStatus'>
    


  /**
   * Reference to a field of type 'DelayStatus[]'
   */
  export type ListEnumDelayStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DelayStatus[]'>
    


  /**
   * Reference to a field of type 'ClaimStatus'
   */
  export type EnumClaimStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClaimStatus'>
    


  /**
   * Reference to a field of type 'ClaimStatus[]'
   */
  export type ListEnumClaimStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClaimStatus[]'>
    


  /**
   * Reference to a field of type 'EvidenceType'
   */
  export type EnumEvidenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EvidenceType'>
    


  /**
   * Reference to a field of type 'EvidenceType[]'
   */
  export type ListEnumEvidenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EvidenceType[]'>
    


  /**
   * Reference to a field of type 'ScheduleFormat'
   */
  export type EnumScheduleFormatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleFormat'>
    


  /**
   * Reference to a field of type 'ScheduleFormat[]'
   */
  export type ListEnumScheduleFormatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ScheduleFormat[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'ActionItemStatus'
   */
  export type EnumActionItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionItemStatus'>
    


  /**
   * Reference to a field of type 'ActionItemStatus[]'
   */
  export type ListEnumActionItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionItemStatus[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'MfaMethod'
   */
  export type EnumMfaMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MfaMethod'>
    


  /**
   * Reference to a field of type 'MfaMethod[]'
   */
  export type ListEnumMfaMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MfaMethod[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter<"Organization"> | string
    name?: StringFilter<"Organization"> | string
    domain?: StringFilter<"Organization"> | string
    isActive?: BoolFilter<"Organization"> | boolean
    settings?: JsonNullableFilter<"Organization">
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    users?: UserListRelationFilter
    projects?: ProjectListRelationFilter
    files?: FileMetadataListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    events?: AnalyticsEventListRelationFilter
    quotas?: StorageQuotaListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    isActive?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    files?: FileMetadataOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    events?: AnalyticsEventOrderByRelationAggregateInput
    quotas?: StorageQuotaOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    domain?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    isActive?: BoolFilter<"Organization"> | boolean
    settings?: JsonNullableFilter<"Organization">
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    users?: UserListRelationFilter
    projects?: ProjectListRelationFilter
    files?: FileMetadataListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    events?: AnalyticsEventListRelationFilter
    quotas?: StorageQuotaListRelationFilter
  }, "id" | "domain">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    isActive?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organization"> | string
    name?: StringWithAggregatesFilter<"Organization"> | string
    domain?: StringWithAggregatesFilter<"Organization"> | string
    isActive?: BoolWithAggregatesFilter<"Organization"> | boolean
    settings?: JsonNullableWithAggregatesFilter<"Organization">
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    organizationId?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    assignedProjects?: ProjectListRelationFilter
    delayEvents?: DelayEventListRelationFilter
    claims?: ClaimListRelationFilter
    evidence?: EvidenceListRelationFilter
    actionItems?: ActionItemListRelationFilter
    filesUploaded?: FileMetadataListRelationFilter
    sessions?: SessionDataListRelationFilter
    mfaSettings?: XOR<MfaSettingsNullableScalarRelationFilter, MfaSettingsWhereInput> | null
    passwordResets?: PasswordResetTokenListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    organizationId?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    assignedProjects?: ProjectOrderByRelationAggregateInput
    delayEvents?: DelayEventOrderByRelationAggregateInput
    claims?: ClaimOrderByRelationAggregateInput
    evidence?: EvidenceOrderByRelationAggregateInput
    actionItems?: ActionItemOrderByRelationAggregateInput
    filesUploaded?: FileMetadataOrderByRelationAggregateInput
    sessions?: SessionDataOrderByRelationAggregateInput
    mfaSettings?: MfaSettingsOrderByWithRelationInput
    passwordResets?: PasswordResetTokenOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    organizationId?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    assignedProjects?: ProjectListRelationFilter
    delayEvents?: DelayEventListRelationFilter
    claims?: ClaimListRelationFilter
    evidence?: EvidenceListRelationFilter
    actionItems?: ActionItemListRelationFilter
    filesUploaded?: FileMetadataListRelationFilter
    sessions?: SessionDataListRelationFilter
    mfaSettings?: XOR<MfaSettingsNullableScalarRelationFilter, MfaSettingsWhereInput> | null
    passwordResets?: PasswordResetTokenListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    organizationId?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    organizationId?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    location?: StringNullableFilter<"Project"> | string | null
    organizationId?: StringFilter<"Project"> | string
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    contractValue?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    contractType?: EnumContractTypeNullableFilter<"Project"> | $Enums.ContractType | null
    startDate?: DateTimeFilter<"Project"> | Date | string
    plannedCompletion?: DateTimeNullableFilter<"Project"> | Date | string | null
    currentCompletion?: DateTimeNullableFilter<"Project"> | Date | string | null
    healthScore?: IntNullableFilter<"Project"> | number | null
    projectManagerId?: StringNullableFilter<"Project"> | string | null
    metadata?: JsonNullableFilter<"Project">
    isDeleted?: BoolFilter<"Project"> | boolean
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    projectManager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    delayEvents?: DelayEventListRelationFilter
    claims?: ClaimListRelationFilter
    actionItems?: ActionItemListRelationFilter
    schedules?: ScheduleListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    status?: SortOrder
    contractValue?: SortOrderInput | SortOrder
    contractType?: SortOrderInput | SortOrder
    startDate?: SortOrder
    plannedCompletion?: SortOrderInput | SortOrder
    currentCompletion?: SortOrderInput | SortOrder
    healthScore?: SortOrderInput | SortOrder
    projectManagerId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    projectManager?: UserOrderByWithRelationInput
    delayEvents?: DelayEventOrderByRelationAggregateInput
    claims?: ClaimOrderByRelationAggregateInput
    actionItems?: ActionItemOrderByRelationAggregateInput
    schedules?: ScheduleOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    location?: StringNullableFilter<"Project"> | string | null
    organizationId?: StringFilter<"Project"> | string
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    contractValue?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    contractType?: EnumContractTypeNullableFilter<"Project"> | $Enums.ContractType | null
    startDate?: DateTimeFilter<"Project"> | Date | string
    plannedCompletion?: DateTimeNullableFilter<"Project"> | Date | string | null
    currentCompletion?: DateTimeNullableFilter<"Project"> | Date | string | null
    healthScore?: IntNullableFilter<"Project"> | number | null
    projectManagerId?: StringNullableFilter<"Project"> | string | null
    metadata?: JsonNullableFilter<"Project">
    isDeleted?: BoolFilter<"Project"> | boolean
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    projectManager?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    delayEvents?: DelayEventListRelationFilter
    claims?: ClaimListRelationFilter
    actionItems?: ActionItemListRelationFilter
    schedules?: ScheduleListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    status?: SortOrder
    contractValue?: SortOrderInput | SortOrder
    contractType?: SortOrderInput | SortOrder
    startDate?: SortOrder
    plannedCompletion?: SortOrderInput | SortOrder
    currentCompletion?: SortOrderInput | SortOrder
    healthScore?: SortOrderInput | SortOrder
    projectManagerId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    location?: StringNullableWithAggregatesFilter<"Project"> | string | null
    organizationId?: StringWithAggregatesFilter<"Project"> | string
    status?: EnumProjectStatusWithAggregatesFilter<"Project"> | $Enums.ProjectStatus
    contractValue?: DecimalNullableWithAggregatesFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    contractType?: EnumContractTypeNullableWithAggregatesFilter<"Project"> | $Enums.ContractType | null
    startDate?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    plannedCompletion?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    currentCompletion?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    healthScore?: IntNullableWithAggregatesFilter<"Project"> | number | null
    projectManagerId?: StringNullableWithAggregatesFilter<"Project"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Project">
    isDeleted?: BoolWithAggregatesFilter<"Project"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type DelayEventWhereInput = {
    AND?: DelayEventWhereInput | DelayEventWhereInput[]
    OR?: DelayEventWhereInput[]
    NOT?: DelayEventWhereInput | DelayEventWhereInput[]
    id?: StringFilter<"DelayEvent"> | string
    projectId?: StringFilter<"DelayEvent"> | string
    activityId?: StringNullableFilter<"DelayEvent"> | string | null
    activityName?: StringFilter<"DelayEvent"> | string
    detectionDate?: DateTimeFilter<"DelayEvent"> | Date | string
    delayDays?: IntFilter<"DelayEvent"> | number
    causeType?: EnumDelayTypeFilter<"DelayEvent"> | $Enums.DelayType
    probabilityScore?: IntNullableFilter<"DelayEvent"> | number | null
    evidenceStrength?: IntNullableFilter<"DelayEvent"> | number | null
    status?: EnumDelayStatusFilter<"DelayEvent"> | $Enums.DelayStatus
    description?: StringNullableFilter<"DelayEvent"> | string | null
    estimatedCost?: DecimalNullableFilter<"DelayEvent"> | Decimal | DecimalJsLike | number | string | null
    criticalPath?: BoolFilter<"DelayEvent"> | boolean
    detectedById?: StringFilter<"DelayEvent"> | string
    metadata?: JsonNullableFilter<"DelayEvent">
    isDeleted?: BoolFilter<"DelayEvent"> | boolean
    createdAt?: DateTimeFilter<"DelayEvent"> | Date | string
    updatedAt?: DateTimeFilter<"DelayEvent"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    detectedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    claims?: ClaimListRelationFilter
    evidence?: EvidenceListRelationFilter
  }

  export type DelayEventOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    activityId?: SortOrderInput | SortOrder
    activityName?: SortOrder
    detectionDate?: SortOrder
    delayDays?: SortOrder
    causeType?: SortOrder
    probabilityScore?: SortOrderInput | SortOrder
    evidenceStrength?: SortOrderInput | SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    estimatedCost?: SortOrderInput | SortOrder
    criticalPath?: SortOrder
    detectedById?: SortOrder
    metadata?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    detectedBy?: UserOrderByWithRelationInput
    claims?: ClaimOrderByRelationAggregateInput
    evidence?: EvidenceOrderByRelationAggregateInput
  }

  export type DelayEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DelayEventWhereInput | DelayEventWhereInput[]
    OR?: DelayEventWhereInput[]
    NOT?: DelayEventWhereInput | DelayEventWhereInput[]
    projectId?: StringFilter<"DelayEvent"> | string
    activityId?: StringNullableFilter<"DelayEvent"> | string | null
    activityName?: StringFilter<"DelayEvent"> | string
    detectionDate?: DateTimeFilter<"DelayEvent"> | Date | string
    delayDays?: IntFilter<"DelayEvent"> | number
    causeType?: EnumDelayTypeFilter<"DelayEvent"> | $Enums.DelayType
    probabilityScore?: IntNullableFilter<"DelayEvent"> | number | null
    evidenceStrength?: IntNullableFilter<"DelayEvent"> | number | null
    status?: EnumDelayStatusFilter<"DelayEvent"> | $Enums.DelayStatus
    description?: StringNullableFilter<"DelayEvent"> | string | null
    estimatedCost?: DecimalNullableFilter<"DelayEvent"> | Decimal | DecimalJsLike | number | string | null
    criticalPath?: BoolFilter<"DelayEvent"> | boolean
    detectedById?: StringFilter<"DelayEvent"> | string
    metadata?: JsonNullableFilter<"DelayEvent">
    isDeleted?: BoolFilter<"DelayEvent"> | boolean
    createdAt?: DateTimeFilter<"DelayEvent"> | Date | string
    updatedAt?: DateTimeFilter<"DelayEvent"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    detectedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    claims?: ClaimListRelationFilter
    evidence?: EvidenceListRelationFilter
  }, "id">

  export type DelayEventOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    activityId?: SortOrderInput | SortOrder
    activityName?: SortOrder
    detectionDate?: SortOrder
    delayDays?: SortOrder
    causeType?: SortOrder
    probabilityScore?: SortOrderInput | SortOrder
    evidenceStrength?: SortOrderInput | SortOrder
    status?: SortOrder
    description?: SortOrderInput | SortOrder
    estimatedCost?: SortOrderInput | SortOrder
    criticalPath?: SortOrder
    detectedById?: SortOrder
    metadata?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DelayEventCountOrderByAggregateInput
    _avg?: DelayEventAvgOrderByAggregateInput
    _max?: DelayEventMaxOrderByAggregateInput
    _min?: DelayEventMinOrderByAggregateInput
    _sum?: DelayEventSumOrderByAggregateInput
  }

  export type DelayEventScalarWhereWithAggregatesInput = {
    AND?: DelayEventScalarWhereWithAggregatesInput | DelayEventScalarWhereWithAggregatesInput[]
    OR?: DelayEventScalarWhereWithAggregatesInput[]
    NOT?: DelayEventScalarWhereWithAggregatesInput | DelayEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DelayEvent"> | string
    projectId?: StringWithAggregatesFilter<"DelayEvent"> | string
    activityId?: StringNullableWithAggregatesFilter<"DelayEvent"> | string | null
    activityName?: StringWithAggregatesFilter<"DelayEvent"> | string
    detectionDate?: DateTimeWithAggregatesFilter<"DelayEvent"> | Date | string
    delayDays?: IntWithAggregatesFilter<"DelayEvent"> | number
    causeType?: EnumDelayTypeWithAggregatesFilter<"DelayEvent"> | $Enums.DelayType
    probabilityScore?: IntNullableWithAggregatesFilter<"DelayEvent"> | number | null
    evidenceStrength?: IntNullableWithAggregatesFilter<"DelayEvent"> | number | null
    status?: EnumDelayStatusWithAggregatesFilter<"DelayEvent"> | $Enums.DelayStatus
    description?: StringNullableWithAggregatesFilter<"DelayEvent"> | string | null
    estimatedCost?: DecimalNullableWithAggregatesFilter<"DelayEvent"> | Decimal | DecimalJsLike | number | string | null
    criticalPath?: BoolWithAggregatesFilter<"DelayEvent"> | boolean
    detectedById?: StringWithAggregatesFilter<"DelayEvent"> | string
    metadata?: JsonNullableWithAggregatesFilter<"DelayEvent">
    isDeleted?: BoolWithAggregatesFilter<"DelayEvent"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DelayEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DelayEvent"> | Date | string
  }

  export type ClaimWhereInput = {
    AND?: ClaimWhereInput | ClaimWhereInput[]
    OR?: ClaimWhereInput[]
    NOT?: ClaimWhereInput | ClaimWhereInput[]
    id?: StringFilter<"Claim"> | string
    projectId?: StringFilter<"Claim"> | string
    delayEventId?: StringNullableFilter<"Claim"> | string | null
    referenceNumber?: StringFilter<"Claim"> | string
    title?: StringFilter<"Claim"> | string
    description?: StringNullableFilter<"Claim"> | string | null
    submissionDate?: DateTimeNullableFilter<"Claim"> | Date | string | null
    noticeDate?: DateTimeNullableFilter<"Claim"> | Date | string | null
    claimAmount?: DecimalNullableFilter<"Claim"> | Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: IntNullableFilter<"Claim"> | number | null
    status?: EnumClaimStatusFilter<"Claim"> | $Enums.ClaimStatus
    responseDueDate?: DateTimeNullableFilter<"Claim"> | Date | string | null
    submittedById?: StringNullableFilter<"Claim"> | string | null
    workflow?: JsonNullableFilter<"Claim">
    metadata?: JsonNullableFilter<"Claim">
    isDeleted?: BoolFilter<"Claim"> | boolean
    createdAt?: DateTimeFilter<"Claim"> | Date | string
    updatedAt?: DateTimeFilter<"Claim"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    delayEvent?: XOR<DelayEventNullableScalarRelationFilter, DelayEventWhereInput> | null
    submittedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    evidence?: EvidenceListRelationFilter
  }

  export type ClaimOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    delayEventId?: SortOrderInput | SortOrder
    referenceNumber?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    submissionDate?: SortOrderInput | SortOrder
    noticeDate?: SortOrderInput | SortOrder
    claimAmount?: SortOrderInput | SortOrder
    timeImpactDays?: SortOrderInput | SortOrder
    status?: SortOrder
    responseDueDate?: SortOrderInput | SortOrder
    submittedById?: SortOrderInput | SortOrder
    workflow?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    delayEvent?: DelayEventOrderByWithRelationInput
    submittedBy?: UserOrderByWithRelationInput
    evidence?: EvidenceOrderByRelationAggregateInput
  }

  export type ClaimWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    referenceNumber?: string
    AND?: ClaimWhereInput | ClaimWhereInput[]
    OR?: ClaimWhereInput[]
    NOT?: ClaimWhereInput | ClaimWhereInput[]
    projectId?: StringFilter<"Claim"> | string
    delayEventId?: StringNullableFilter<"Claim"> | string | null
    title?: StringFilter<"Claim"> | string
    description?: StringNullableFilter<"Claim"> | string | null
    submissionDate?: DateTimeNullableFilter<"Claim"> | Date | string | null
    noticeDate?: DateTimeNullableFilter<"Claim"> | Date | string | null
    claimAmount?: DecimalNullableFilter<"Claim"> | Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: IntNullableFilter<"Claim"> | number | null
    status?: EnumClaimStatusFilter<"Claim"> | $Enums.ClaimStatus
    responseDueDate?: DateTimeNullableFilter<"Claim"> | Date | string | null
    submittedById?: StringNullableFilter<"Claim"> | string | null
    workflow?: JsonNullableFilter<"Claim">
    metadata?: JsonNullableFilter<"Claim">
    isDeleted?: BoolFilter<"Claim"> | boolean
    createdAt?: DateTimeFilter<"Claim"> | Date | string
    updatedAt?: DateTimeFilter<"Claim"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    delayEvent?: XOR<DelayEventNullableScalarRelationFilter, DelayEventWhereInput> | null
    submittedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    evidence?: EvidenceListRelationFilter
  }, "id" | "referenceNumber">

  export type ClaimOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    delayEventId?: SortOrderInput | SortOrder
    referenceNumber?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    submissionDate?: SortOrderInput | SortOrder
    noticeDate?: SortOrderInput | SortOrder
    claimAmount?: SortOrderInput | SortOrder
    timeImpactDays?: SortOrderInput | SortOrder
    status?: SortOrder
    responseDueDate?: SortOrderInput | SortOrder
    submittedById?: SortOrderInput | SortOrder
    workflow?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClaimCountOrderByAggregateInput
    _avg?: ClaimAvgOrderByAggregateInput
    _max?: ClaimMaxOrderByAggregateInput
    _min?: ClaimMinOrderByAggregateInput
    _sum?: ClaimSumOrderByAggregateInput
  }

  export type ClaimScalarWhereWithAggregatesInput = {
    AND?: ClaimScalarWhereWithAggregatesInput | ClaimScalarWhereWithAggregatesInput[]
    OR?: ClaimScalarWhereWithAggregatesInput[]
    NOT?: ClaimScalarWhereWithAggregatesInput | ClaimScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Claim"> | string
    projectId?: StringWithAggregatesFilter<"Claim"> | string
    delayEventId?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    referenceNumber?: StringWithAggregatesFilter<"Claim"> | string
    title?: StringWithAggregatesFilter<"Claim"> | string
    description?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    submissionDate?: DateTimeNullableWithAggregatesFilter<"Claim"> | Date | string | null
    noticeDate?: DateTimeNullableWithAggregatesFilter<"Claim"> | Date | string | null
    claimAmount?: DecimalNullableWithAggregatesFilter<"Claim"> | Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: IntNullableWithAggregatesFilter<"Claim"> | number | null
    status?: EnumClaimStatusWithAggregatesFilter<"Claim"> | $Enums.ClaimStatus
    responseDueDate?: DateTimeNullableWithAggregatesFilter<"Claim"> | Date | string | null
    submittedById?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    workflow?: JsonNullableWithAggregatesFilter<"Claim">
    metadata?: JsonNullableWithAggregatesFilter<"Claim">
    isDeleted?: BoolWithAggregatesFilter<"Claim"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Claim"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Claim"> | Date | string
  }

  export type EvidenceWhereInput = {
    AND?: EvidenceWhereInput | EvidenceWhereInput[]
    OR?: EvidenceWhereInput[]
    NOT?: EvidenceWhereInput | EvidenceWhereInput[]
    id?: StringFilter<"Evidence"> | string
    delayEventId?: StringNullableFilter<"Evidence"> | string | null
    claimId?: StringNullableFilter<"Evidence"> | string | null
    type?: EnumEvidenceTypeFilter<"Evidence"> | $Enums.EvidenceType
    title?: StringFilter<"Evidence"> | string
    description?: StringNullableFilter<"Evidence"> | string | null
    sourceSystem?: StringNullableFilter<"Evidence"> | string | null
    filePath?: StringNullableFilter<"Evidence"> | string | null
    fileId?: StringNullableFilter<"Evidence"> | string | null
    relevanceScore?: IntNullableFilter<"Evidence"> | number | null
    extractedText?: StringNullableFilter<"Evidence"> | string | null
    metadata?: JsonNullableFilter<"Evidence">
    uploadedById?: StringFilter<"Evidence"> | string
    isDeleted?: BoolFilter<"Evidence"> | boolean
    createdAt?: DateTimeFilter<"Evidence"> | Date | string
    updatedAt?: DateTimeFilter<"Evidence"> | Date | string
    delayEvent?: XOR<DelayEventNullableScalarRelationFilter, DelayEventWhereInput> | null
    claim?: XOR<ClaimNullableScalarRelationFilter, ClaimWhereInput> | null
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    file?: XOR<FileMetadataNullableScalarRelationFilter, FileMetadataWhereInput> | null
  }

  export type EvidenceOrderByWithRelationInput = {
    id?: SortOrder
    delayEventId?: SortOrderInput | SortOrder
    claimId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    sourceSystem?: SortOrderInput | SortOrder
    filePath?: SortOrderInput | SortOrder
    fileId?: SortOrderInput | SortOrder
    relevanceScore?: SortOrderInput | SortOrder
    extractedText?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    delayEvent?: DelayEventOrderByWithRelationInput
    claim?: ClaimOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
    file?: FileMetadataOrderByWithRelationInput
  }

  export type EvidenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EvidenceWhereInput | EvidenceWhereInput[]
    OR?: EvidenceWhereInput[]
    NOT?: EvidenceWhereInput | EvidenceWhereInput[]
    delayEventId?: StringNullableFilter<"Evidence"> | string | null
    claimId?: StringNullableFilter<"Evidence"> | string | null
    type?: EnumEvidenceTypeFilter<"Evidence"> | $Enums.EvidenceType
    title?: StringFilter<"Evidence"> | string
    description?: StringNullableFilter<"Evidence"> | string | null
    sourceSystem?: StringNullableFilter<"Evidence"> | string | null
    filePath?: StringNullableFilter<"Evidence"> | string | null
    fileId?: StringNullableFilter<"Evidence"> | string | null
    relevanceScore?: IntNullableFilter<"Evidence"> | number | null
    extractedText?: StringNullableFilter<"Evidence"> | string | null
    metadata?: JsonNullableFilter<"Evidence">
    uploadedById?: StringFilter<"Evidence"> | string
    isDeleted?: BoolFilter<"Evidence"> | boolean
    createdAt?: DateTimeFilter<"Evidence"> | Date | string
    updatedAt?: DateTimeFilter<"Evidence"> | Date | string
    delayEvent?: XOR<DelayEventNullableScalarRelationFilter, DelayEventWhereInput> | null
    claim?: XOR<ClaimNullableScalarRelationFilter, ClaimWhereInput> | null
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    file?: XOR<FileMetadataNullableScalarRelationFilter, FileMetadataWhereInput> | null
  }, "id">

  export type EvidenceOrderByWithAggregationInput = {
    id?: SortOrder
    delayEventId?: SortOrderInput | SortOrder
    claimId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    sourceSystem?: SortOrderInput | SortOrder
    filePath?: SortOrderInput | SortOrder
    fileId?: SortOrderInput | SortOrder
    relevanceScore?: SortOrderInput | SortOrder
    extractedText?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    uploadedById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EvidenceCountOrderByAggregateInput
    _avg?: EvidenceAvgOrderByAggregateInput
    _max?: EvidenceMaxOrderByAggregateInput
    _min?: EvidenceMinOrderByAggregateInput
    _sum?: EvidenceSumOrderByAggregateInput
  }

  export type EvidenceScalarWhereWithAggregatesInput = {
    AND?: EvidenceScalarWhereWithAggregatesInput | EvidenceScalarWhereWithAggregatesInput[]
    OR?: EvidenceScalarWhereWithAggregatesInput[]
    NOT?: EvidenceScalarWhereWithAggregatesInput | EvidenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Evidence"> | string
    delayEventId?: StringNullableWithAggregatesFilter<"Evidence"> | string | null
    claimId?: StringNullableWithAggregatesFilter<"Evidence"> | string | null
    type?: EnumEvidenceTypeWithAggregatesFilter<"Evidence"> | $Enums.EvidenceType
    title?: StringWithAggregatesFilter<"Evidence"> | string
    description?: StringNullableWithAggregatesFilter<"Evidence"> | string | null
    sourceSystem?: StringNullableWithAggregatesFilter<"Evidence"> | string | null
    filePath?: StringNullableWithAggregatesFilter<"Evidence"> | string | null
    fileId?: StringNullableWithAggregatesFilter<"Evidence"> | string | null
    relevanceScore?: IntNullableWithAggregatesFilter<"Evidence"> | number | null
    extractedText?: StringNullableWithAggregatesFilter<"Evidence"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Evidence">
    uploadedById?: StringWithAggregatesFilter<"Evidence"> | string
    isDeleted?: BoolWithAggregatesFilter<"Evidence"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Evidence"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Evidence"> | Date | string
  }

  export type ScheduleWhereInput = {
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    id?: StringFilter<"Schedule"> | string
    projectId?: StringFilter<"Schedule"> | string
    name?: StringFilter<"Schedule"> | string
    description?: StringNullableFilter<"Schedule"> | string | null
    format?: EnumScheduleFormatFilter<"Schedule"> | $Enums.ScheduleFormat
    version?: StringNullableFilter<"Schedule"> | string | null
    baselineDate?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    statusDate?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    filePath?: StringNullableFilter<"Schedule"> | string | null
    fileId?: StringNullableFilter<"Schedule"> | string | null
    metadata?: JsonNullableFilter<"Schedule">
    isBaseline?: BoolFilter<"Schedule"> | boolean
    isDeleted?: BoolFilter<"Schedule"> | boolean
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    file?: XOR<FileMetadataNullableScalarRelationFilter, FileMetadataWhereInput> | null
  }

  export type ScheduleOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    format?: SortOrder
    version?: SortOrderInput | SortOrder
    baselineDate?: SortOrderInput | SortOrder
    statusDate?: SortOrderInput | SortOrder
    filePath?: SortOrderInput | SortOrder
    fileId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    isBaseline?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    file?: FileMetadataOrderByWithRelationInput
  }

  export type ScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    projectId?: StringFilter<"Schedule"> | string
    name?: StringFilter<"Schedule"> | string
    description?: StringNullableFilter<"Schedule"> | string | null
    format?: EnumScheduleFormatFilter<"Schedule"> | $Enums.ScheduleFormat
    version?: StringNullableFilter<"Schedule"> | string | null
    baselineDate?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    statusDate?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    filePath?: StringNullableFilter<"Schedule"> | string | null
    fileId?: StringNullableFilter<"Schedule"> | string | null
    metadata?: JsonNullableFilter<"Schedule">
    isBaseline?: BoolFilter<"Schedule"> | boolean
    isDeleted?: BoolFilter<"Schedule"> | boolean
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    file?: XOR<FileMetadataNullableScalarRelationFilter, FileMetadataWhereInput> | null
  }, "id">

  export type ScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    format?: SortOrder
    version?: SortOrderInput | SortOrder
    baselineDate?: SortOrderInput | SortOrder
    statusDate?: SortOrderInput | SortOrder
    filePath?: SortOrderInput | SortOrder
    fileId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    isBaseline?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduleCountOrderByAggregateInput
    _max?: ScheduleMaxOrderByAggregateInput
    _min?: ScheduleMinOrderByAggregateInput
  }

  export type ScheduleScalarWhereWithAggregatesInput = {
    AND?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    OR?: ScheduleScalarWhereWithAggregatesInput[]
    NOT?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Schedule"> | string
    projectId?: StringWithAggregatesFilter<"Schedule"> | string
    name?: StringWithAggregatesFilter<"Schedule"> | string
    description?: StringNullableWithAggregatesFilter<"Schedule"> | string | null
    format?: EnumScheduleFormatWithAggregatesFilter<"Schedule"> | $Enums.ScheduleFormat
    version?: StringNullableWithAggregatesFilter<"Schedule"> | string | null
    baselineDate?: DateTimeNullableWithAggregatesFilter<"Schedule"> | Date | string | null
    statusDate?: DateTimeNullableWithAggregatesFilter<"Schedule"> | Date | string | null
    filePath?: StringNullableWithAggregatesFilter<"Schedule"> | string | null
    fileId?: StringNullableWithAggregatesFilter<"Schedule"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Schedule">
    isBaseline?: BoolWithAggregatesFilter<"Schedule"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"Schedule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
  }

  export type ActionItemWhereInput = {
    AND?: ActionItemWhereInput | ActionItemWhereInput[]
    OR?: ActionItemWhereInput[]
    NOT?: ActionItemWhereInput | ActionItemWhereInput[]
    id?: StringFilter<"ActionItem"> | string
    title?: StringFilter<"ActionItem"> | string
    description?: StringNullableFilter<"ActionItem"> | string | null
    priority?: EnumPriorityFilter<"ActionItem"> | $Enums.Priority
    dueDate?: DateTimeFilter<"ActionItem"> | Date | string
    projectId?: StringFilter<"ActionItem"> | string
    assignedToId?: StringFilter<"ActionItem"> | string
    status?: EnumActionItemStatusFilter<"ActionItem"> | $Enums.ActionItemStatus
    completedAt?: DateTimeNullableFilter<"ActionItem"> | Date | string | null
    metadata?: JsonNullableFilter<"ActionItem">
    isDeleted?: BoolFilter<"ActionItem"> | boolean
    createdAt?: DateTimeFilter<"ActionItem"> | Date | string
    updatedAt?: DateTimeFilter<"ActionItem"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    assignedTo?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ActionItemOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    projectId?: SortOrder
    assignedToId?: SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    assignedTo?: UserOrderByWithRelationInput
  }

  export type ActionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActionItemWhereInput | ActionItemWhereInput[]
    OR?: ActionItemWhereInput[]
    NOT?: ActionItemWhereInput | ActionItemWhereInput[]
    title?: StringFilter<"ActionItem"> | string
    description?: StringNullableFilter<"ActionItem"> | string | null
    priority?: EnumPriorityFilter<"ActionItem"> | $Enums.Priority
    dueDate?: DateTimeFilter<"ActionItem"> | Date | string
    projectId?: StringFilter<"ActionItem"> | string
    assignedToId?: StringFilter<"ActionItem"> | string
    status?: EnumActionItemStatusFilter<"ActionItem"> | $Enums.ActionItemStatus
    completedAt?: DateTimeNullableFilter<"ActionItem"> | Date | string | null
    metadata?: JsonNullableFilter<"ActionItem">
    isDeleted?: BoolFilter<"ActionItem"> | boolean
    createdAt?: DateTimeFilter<"ActionItem"> | Date | string
    updatedAt?: DateTimeFilter<"ActionItem"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    assignedTo?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ActionItemOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    projectId?: SortOrder
    assignedToId?: SortOrder
    status?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ActionItemCountOrderByAggregateInput
    _max?: ActionItemMaxOrderByAggregateInput
    _min?: ActionItemMinOrderByAggregateInput
  }

  export type ActionItemScalarWhereWithAggregatesInput = {
    AND?: ActionItemScalarWhereWithAggregatesInput | ActionItemScalarWhereWithAggregatesInput[]
    OR?: ActionItemScalarWhereWithAggregatesInput[]
    NOT?: ActionItemScalarWhereWithAggregatesInput | ActionItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActionItem"> | string
    title?: StringWithAggregatesFilter<"ActionItem"> | string
    description?: StringNullableWithAggregatesFilter<"ActionItem"> | string | null
    priority?: EnumPriorityWithAggregatesFilter<"ActionItem"> | $Enums.Priority
    dueDate?: DateTimeWithAggregatesFilter<"ActionItem"> | Date | string
    projectId?: StringWithAggregatesFilter<"ActionItem"> | string
    assignedToId?: StringWithAggregatesFilter<"ActionItem"> | string
    status?: EnumActionItemStatusWithAggregatesFilter<"ActionItem"> | $Enums.ActionItemStatus
    completedAt?: DateTimeNullableWithAggregatesFilter<"ActionItem"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"ActionItem">
    isDeleted?: BoolWithAggregatesFilter<"ActionItem"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ActionItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ActionItem"> | Date | string
  }

  export type FileMetadataWhereInput = {
    AND?: FileMetadataWhereInput | FileMetadataWhereInput[]
    OR?: FileMetadataWhereInput[]
    NOT?: FileMetadataWhereInput | FileMetadataWhereInput[]
    id?: StringFilter<"FileMetadata"> | string
    filename?: StringFilter<"FileMetadata"> | string
    originalName?: StringFilter<"FileMetadata"> | string
    mimeType?: StringFilter<"FileMetadata"> | string
    size?: BigIntFilter<"FileMetadata"> | bigint | number
    checksum?: StringNullableFilter<"FileMetadata"> | string | null
    organizationId?: StringFilter<"FileMetadata"> | string
    uploadedById?: StringFilter<"FileMetadata"> | string
    path?: StringFilter<"FileMetadata"> | string
    isPublic?: BoolFilter<"FileMetadata"> | boolean
    tags?: StringNullableListFilter<"FileMetadata">
    metadata?: JsonNullableFilter<"FileMetadata">
    isDeleted?: BoolFilter<"FileMetadata"> | boolean
    createdAt?: DateTimeFilter<"FileMetadata"> | Date | string
    updatedAt?: DateTimeFilter<"FileMetadata"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    evidence?: EvidenceListRelationFilter
    schedules?: ScheduleListRelationFilter
  }

  export type FileMetadataOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    checksum?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    uploadedById?: SortOrder
    path?: SortOrder
    isPublic?: SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    uploadedBy?: UserOrderByWithRelationInput
    evidence?: EvidenceOrderByRelationAggregateInput
    schedules?: ScheduleOrderByRelationAggregateInput
  }

  export type FileMetadataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileMetadataWhereInput | FileMetadataWhereInput[]
    OR?: FileMetadataWhereInput[]
    NOT?: FileMetadataWhereInput | FileMetadataWhereInput[]
    filename?: StringFilter<"FileMetadata"> | string
    originalName?: StringFilter<"FileMetadata"> | string
    mimeType?: StringFilter<"FileMetadata"> | string
    size?: BigIntFilter<"FileMetadata"> | bigint | number
    checksum?: StringNullableFilter<"FileMetadata"> | string | null
    organizationId?: StringFilter<"FileMetadata"> | string
    uploadedById?: StringFilter<"FileMetadata"> | string
    path?: StringFilter<"FileMetadata"> | string
    isPublic?: BoolFilter<"FileMetadata"> | boolean
    tags?: StringNullableListFilter<"FileMetadata">
    metadata?: JsonNullableFilter<"FileMetadata">
    isDeleted?: BoolFilter<"FileMetadata"> | boolean
    createdAt?: DateTimeFilter<"FileMetadata"> | Date | string
    updatedAt?: DateTimeFilter<"FileMetadata"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    uploadedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    evidence?: EvidenceListRelationFilter
    schedules?: ScheduleListRelationFilter
  }, "id">

  export type FileMetadataOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    checksum?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    uploadedById?: SortOrder
    path?: SortOrder
    isPublic?: SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FileMetadataCountOrderByAggregateInput
    _avg?: FileMetadataAvgOrderByAggregateInput
    _max?: FileMetadataMaxOrderByAggregateInput
    _min?: FileMetadataMinOrderByAggregateInput
    _sum?: FileMetadataSumOrderByAggregateInput
  }

  export type FileMetadataScalarWhereWithAggregatesInput = {
    AND?: FileMetadataScalarWhereWithAggregatesInput | FileMetadataScalarWhereWithAggregatesInput[]
    OR?: FileMetadataScalarWhereWithAggregatesInput[]
    NOT?: FileMetadataScalarWhereWithAggregatesInput | FileMetadataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FileMetadata"> | string
    filename?: StringWithAggregatesFilter<"FileMetadata"> | string
    originalName?: StringWithAggregatesFilter<"FileMetadata"> | string
    mimeType?: StringWithAggregatesFilter<"FileMetadata"> | string
    size?: BigIntWithAggregatesFilter<"FileMetadata"> | bigint | number
    checksum?: StringNullableWithAggregatesFilter<"FileMetadata"> | string | null
    organizationId?: StringWithAggregatesFilter<"FileMetadata"> | string
    uploadedById?: StringWithAggregatesFilter<"FileMetadata"> | string
    path?: StringWithAggregatesFilter<"FileMetadata"> | string
    isPublic?: BoolWithAggregatesFilter<"FileMetadata"> | boolean
    tags?: StringNullableListFilter<"FileMetadata">
    metadata?: JsonNullableWithAggregatesFilter<"FileMetadata">
    isDeleted?: BoolWithAggregatesFilter<"FileMetadata"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FileMetadata"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FileMetadata"> | Date | string
  }

  export type StorageQuotaWhereInput = {
    AND?: StorageQuotaWhereInput | StorageQuotaWhereInput[]
    OR?: StorageQuotaWhereInput[]
    NOT?: StorageQuotaWhereInput | StorageQuotaWhereInput[]
    id?: StringFilter<"StorageQuota"> | string
    organizationId?: StringFilter<"StorageQuota"> | string
    usedBytes?: BigIntFilter<"StorageQuota"> | bigint | number
    limitBytes?: BigIntFilter<"StorageQuota"> | bigint | number
    fileCount?: IntFilter<"StorageQuota"> | number
    maxFileCount?: IntFilter<"StorageQuota"> | number
    createdAt?: DateTimeFilter<"StorageQuota"> | Date | string
    updatedAt?: DateTimeFilter<"StorageQuota"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type StorageQuotaOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    usedBytes?: SortOrder
    limitBytes?: SortOrder
    fileCount?: SortOrder
    maxFileCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type StorageQuotaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    organizationId?: string
    AND?: StorageQuotaWhereInput | StorageQuotaWhereInput[]
    OR?: StorageQuotaWhereInput[]
    NOT?: StorageQuotaWhereInput | StorageQuotaWhereInput[]
    usedBytes?: BigIntFilter<"StorageQuota"> | bigint | number
    limitBytes?: BigIntFilter<"StorageQuota"> | bigint | number
    fileCount?: IntFilter<"StorageQuota"> | number
    maxFileCount?: IntFilter<"StorageQuota"> | number
    createdAt?: DateTimeFilter<"StorageQuota"> | Date | string
    updatedAt?: DateTimeFilter<"StorageQuota"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id" | "organizationId">

  export type StorageQuotaOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    usedBytes?: SortOrder
    limitBytes?: SortOrder
    fileCount?: SortOrder
    maxFileCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StorageQuotaCountOrderByAggregateInput
    _avg?: StorageQuotaAvgOrderByAggregateInput
    _max?: StorageQuotaMaxOrderByAggregateInput
    _min?: StorageQuotaMinOrderByAggregateInput
    _sum?: StorageQuotaSumOrderByAggregateInput
  }

  export type StorageQuotaScalarWhereWithAggregatesInput = {
    AND?: StorageQuotaScalarWhereWithAggregatesInput | StorageQuotaScalarWhereWithAggregatesInput[]
    OR?: StorageQuotaScalarWhereWithAggregatesInput[]
    NOT?: StorageQuotaScalarWhereWithAggregatesInput | StorageQuotaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StorageQuota"> | string
    organizationId?: StringWithAggregatesFilter<"StorageQuota"> | string
    usedBytes?: BigIntWithAggregatesFilter<"StorageQuota"> | bigint | number
    limitBytes?: BigIntWithAggregatesFilter<"StorageQuota"> | bigint | number
    fileCount?: IntWithAggregatesFilter<"StorageQuota"> | number
    maxFileCount?: IntWithAggregatesFilter<"StorageQuota"> | number
    createdAt?: DateTimeWithAggregatesFilter<"StorageQuota"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StorageQuota"> | Date | string
  }

  export type SessionDataWhereInput = {
    AND?: SessionDataWhereInput | SessionDataWhereInput[]
    OR?: SessionDataWhereInput[]
    NOT?: SessionDataWhereInput | SessionDataWhereInput[]
    id?: StringFilter<"SessionData"> | string
    userId?: StringFilter<"SessionData"> | string
    deviceInfo?: JsonFilter<"SessionData">
    location?: JsonNullableFilter<"SessionData">
    expiresAt?: DateTimeFilter<"SessionData"> | Date | string
    lastActivityAt?: DateTimeFilter<"SessionData"> | Date | string
    isActive?: BoolFilter<"SessionData"> | boolean
    createdAt?: DateTimeFilter<"SessionData"> | Date | string
    updatedAt?: DateTimeFilter<"SessionData"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionDataOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceInfo?: SortOrder
    location?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionDataWhereInput | SessionDataWhereInput[]
    OR?: SessionDataWhereInput[]
    NOT?: SessionDataWhereInput | SessionDataWhereInput[]
    userId?: StringFilter<"SessionData"> | string
    deviceInfo?: JsonFilter<"SessionData">
    location?: JsonNullableFilter<"SessionData">
    expiresAt?: DateTimeFilter<"SessionData"> | Date | string
    lastActivityAt?: DateTimeFilter<"SessionData"> | Date | string
    isActive?: BoolFilter<"SessionData"> | boolean
    createdAt?: DateTimeFilter<"SessionData"> | Date | string
    updatedAt?: DateTimeFilter<"SessionData"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SessionDataOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceInfo?: SortOrder
    location?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SessionDataCountOrderByAggregateInput
    _max?: SessionDataMaxOrderByAggregateInput
    _min?: SessionDataMinOrderByAggregateInput
  }

  export type SessionDataScalarWhereWithAggregatesInput = {
    AND?: SessionDataScalarWhereWithAggregatesInput | SessionDataScalarWhereWithAggregatesInput[]
    OR?: SessionDataScalarWhereWithAggregatesInput[]
    NOT?: SessionDataScalarWhereWithAggregatesInput | SessionDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SessionData"> | string
    userId?: StringWithAggregatesFilter<"SessionData"> | string
    deviceInfo?: JsonWithAggregatesFilter<"SessionData">
    location?: JsonNullableWithAggregatesFilter<"SessionData">
    expiresAt?: DateTimeWithAggregatesFilter<"SessionData"> | Date | string
    lastActivityAt?: DateTimeWithAggregatesFilter<"SessionData"> | Date | string
    isActive?: BoolWithAggregatesFilter<"SessionData"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SessionData"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SessionData"> | Date | string
  }

  export type MfaSettingsWhereInput = {
    AND?: MfaSettingsWhereInput | MfaSettingsWhereInput[]
    OR?: MfaSettingsWhereInput[]
    NOT?: MfaSettingsWhereInput | MfaSettingsWhereInput[]
    id?: StringFilter<"MfaSettings"> | string
    userId?: StringFilter<"MfaSettings"> | string
    isEnabled?: BoolFilter<"MfaSettings"> | boolean
    method?: EnumMfaMethodFilter<"MfaSettings"> | $Enums.MfaMethod
    secret?: StringNullableFilter<"MfaSettings"> | string | null
    backupCodes?: StringNullableListFilter<"MfaSettings">
    lastUsedAt?: DateTimeNullableFilter<"MfaSettings"> | Date | string | null
    createdAt?: DateTimeFilter<"MfaSettings"> | Date | string
    updatedAt?: DateTimeFilter<"MfaSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MfaSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    isEnabled?: SortOrder
    method?: SortOrder
    secret?: SortOrderInput | SortOrder
    backupCodes?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MfaSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: MfaSettingsWhereInput | MfaSettingsWhereInput[]
    OR?: MfaSettingsWhereInput[]
    NOT?: MfaSettingsWhereInput | MfaSettingsWhereInput[]
    isEnabled?: BoolFilter<"MfaSettings"> | boolean
    method?: EnumMfaMethodFilter<"MfaSettings"> | $Enums.MfaMethod
    secret?: StringNullableFilter<"MfaSettings"> | string | null
    backupCodes?: StringNullableListFilter<"MfaSettings">
    lastUsedAt?: DateTimeNullableFilter<"MfaSettings"> | Date | string | null
    createdAt?: DateTimeFilter<"MfaSettings"> | Date | string
    updatedAt?: DateTimeFilter<"MfaSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type MfaSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    isEnabled?: SortOrder
    method?: SortOrder
    secret?: SortOrderInput | SortOrder
    backupCodes?: SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MfaSettingsCountOrderByAggregateInput
    _max?: MfaSettingsMaxOrderByAggregateInput
    _min?: MfaSettingsMinOrderByAggregateInput
  }

  export type MfaSettingsScalarWhereWithAggregatesInput = {
    AND?: MfaSettingsScalarWhereWithAggregatesInput | MfaSettingsScalarWhereWithAggregatesInput[]
    OR?: MfaSettingsScalarWhereWithAggregatesInput[]
    NOT?: MfaSettingsScalarWhereWithAggregatesInput | MfaSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MfaSettings"> | string
    userId?: StringWithAggregatesFilter<"MfaSettings"> | string
    isEnabled?: BoolWithAggregatesFilter<"MfaSettings"> | boolean
    method?: EnumMfaMethodWithAggregatesFilter<"MfaSettings"> | $Enums.MfaMethod
    secret?: StringNullableWithAggregatesFilter<"MfaSettings"> | string | null
    backupCodes?: StringNullableListFilter<"MfaSettings">
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"MfaSettings"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MfaSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MfaSettings"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    isUsed?: BoolFilter<"PasswordResetToken"> | boolean
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    updatedAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    userId?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    isUsed?: BoolFilter<"PasswordResetToken"> | boolean
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    updatedAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    userId?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    isUsed?: BoolWithAggregatesFilter<"PasswordResetToken"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type AnalyticsEventWhereInput = {
    AND?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    OR?: AnalyticsEventWhereInput[]
    NOT?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    id?: StringFilter<"AnalyticsEvent"> | string
    eventType?: StringFilter<"AnalyticsEvent"> | string
    userId?: StringNullableFilter<"AnalyticsEvent"> | string | null
    organizationId?: StringFilter<"AnalyticsEvent"> | string
    properties?: JsonFilter<"AnalyticsEvent">
    timestamp?: DateTimeFilter<"AnalyticsEvent"> | Date | string
    createdAt?: DateTimeFilter<"AnalyticsEvent"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type AnalyticsEventOrderByWithRelationInput = {
    id?: SortOrder
    eventType?: SortOrder
    userId?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    properties?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type AnalyticsEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    OR?: AnalyticsEventWhereInput[]
    NOT?: AnalyticsEventWhereInput | AnalyticsEventWhereInput[]
    eventType?: StringFilter<"AnalyticsEvent"> | string
    userId?: StringNullableFilter<"AnalyticsEvent"> | string | null
    organizationId?: StringFilter<"AnalyticsEvent"> | string
    properties?: JsonFilter<"AnalyticsEvent">
    timestamp?: DateTimeFilter<"AnalyticsEvent"> | Date | string
    createdAt?: DateTimeFilter<"AnalyticsEvent"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id">

  export type AnalyticsEventOrderByWithAggregationInput = {
    id?: SortOrder
    eventType?: SortOrder
    userId?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    properties?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    _count?: AnalyticsEventCountOrderByAggregateInput
    _max?: AnalyticsEventMaxOrderByAggregateInput
    _min?: AnalyticsEventMinOrderByAggregateInput
  }

  export type AnalyticsEventScalarWhereWithAggregatesInput = {
    AND?: AnalyticsEventScalarWhereWithAggregatesInput | AnalyticsEventScalarWhereWithAggregatesInput[]
    OR?: AnalyticsEventScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsEventScalarWhereWithAggregatesInput | AnalyticsEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    eventType?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    userId?: StringNullableWithAggregatesFilter<"AnalyticsEvent"> | string | null
    organizationId?: StringWithAggregatesFilter<"AnalyticsEvent"> | string
    properties?: JsonWithAggregatesFilter<"AnalyticsEvent">
    timestamp?: DateTimeWithAggregatesFilter<"AnalyticsEvent"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AnalyticsEvent"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    organizationId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    changes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    organizationId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    changes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    organizationId?: StringWithAggregatesFilter<"AuditLog"> | string
    changes?: JsonNullableWithAggregatesFilter<"AuditLog">
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type OrganizationCreateInput = {
    id?: string
    name: string
    domain: string
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    files?: FileMetadataCreateNestedManyWithoutOrganizationInput
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput
    events?: AnalyticsEventCreateNestedManyWithoutOrganizationInput
    quotas?: StorageQuotaCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    name: string
    domain: string
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    files?: FileMetadataUncheckedCreateNestedManyWithoutOrganizationInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput
    events?: AnalyticsEventUncheckedCreateNestedManyWithoutOrganizationInput
    quotas?: StorageQuotaUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    files?: FileMetadataUpdateManyWithoutOrganizationNestedInput
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput
    events?: AnalyticsEventUpdateManyWithoutOrganizationNestedInput
    quotas?: StorageQuotaUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    files?: FileMetadataUncheckedUpdateManyWithoutOrganizationNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput
    events?: AnalyticsEventUncheckedUpdateManyWithoutOrganizationNestedInput
    quotas?: StorageQuotaUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    name: string
    domain: string
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUsersInput
    assignedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    delayEvents?: DelayEventCreateNestedManyWithoutDetectedByInput
    claims?: ClaimCreateNestedManyWithoutSubmittedByInput
    evidence?: EvidenceCreateNestedManyWithoutUploadedByInput
    actionItems?: ActionItemCreateNestedManyWithoutAssignedToInput
    filesUploaded?: FileMetadataCreateNestedManyWithoutUploadedByInput
    sessions?: SessionDataCreateNestedManyWithoutUserInput
    mfaSettings?: MfaSettingsCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    organizationId: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    delayEvents?: DelayEventUncheckedCreateNestedManyWithoutDetectedByInput
    claims?: ClaimUncheckedCreateNestedManyWithoutSubmittedByInput
    evidence?: EvidenceUncheckedCreateNestedManyWithoutUploadedByInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutAssignedToInput
    filesUploaded?: FileMetadataUncheckedCreateNestedManyWithoutUploadedByInput
    sessions?: SessionDataUncheckedCreateNestedManyWithoutUserInput
    mfaSettings?: MfaSettingsUncheckedCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    assignedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    delayEvents?: DelayEventUpdateManyWithoutDetectedByNestedInput
    claims?: ClaimUpdateManyWithoutSubmittedByNestedInput
    evidence?: EvidenceUpdateManyWithoutUploadedByNestedInput
    actionItems?: ActionItemUpdateManyWithoutAssignedToNestedInput
    filesUploaded?: FileMetadataUpdateManyWithoutUploadedByNestedInput
    sessions?: SessionDataUpdateManyWithoutUserNestedInput
    mfaSettings?: MfaSettingsUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    organizationId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    delayEvents?: DelayEventUncheckedUpdateManyWithoutDetectedByNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutSubmittedByNestedInput
    evidence?: EvidenceUncheckedUpdateManyWithoutUploadedByNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutAssignedToNestedInput
    filesUploaded?: FileMetadataUncheckedUpdateManyWithoutUploadedByNestedInput
    sessions?: SessionDataUncheckedUpdateManyWithoutUserNestedInput
    mfaSettings?: MfaSettingsUncheckedUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    organizationId: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    organizationId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    status?: $Enums.ProjectStatus
    contractValue?: Decimal | DecimalJsLike | number | string | null
    contractType?: $Enums.ContractType | null
    startDate: Date | string
    plannedCompletion?: Date | string | null
    currentCompletion?: Date | string | null
    healthScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    projectManager?: UserCreateNestedOneWithoutAssignedProjectsInput
    delayEvents?: DelayEventCreateNestedManyWithoutProjectInput
    claims?: ClaimCreateNestedManyWithoutProjectInput
    actionItems?: ActionItemCreateNestedManyWithoutProjectInput
    schedules?: ScheduleCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    organizationId: string
    status?: $Enums.ProjectStatus
    contractValue?: Decimal | DecimalJsLike | number | string | null
    contractType?: $Enums.ContractType | null
    startDate: Date | string
    plannedCompletion?: Date | string | null
    currentCompletion?: Date | string | null
    healthScore?: number | null
    projectManagerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    delayEvents?: DelayEventUncheckedCreateNestedManyWithoutProjectInput
    claims?: ClaimUncheckedCreateNestedManyWithoutProjectInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutProjectInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    contractValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractType?: NullableEnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    projectManager?: UserUpdateOneWithoutAssignedProjectsNestedInput
    delayEvents?: DelayEventUpdateManyWithoutProjectNestedInput
    claims?: ClaimUpdateManyWithoutProjectNestedInput
    actionItems?: ActionItemUpdateManyWithoutProjectNestedInput
    schedules?: ScheduleUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    contractValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractType?: NullableEnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: NullableIntFieldUpdateOperationsInput | number | null
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delayEvents?: DelayEventUncheckedUpdateManyWithoutProjectNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutProjectNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutProjectNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    organizationId: string
    status?: $Enums.ProjectStatus
    contractValue?: Decimal | DecimalJsLike | number | string | null
    contractType?: $Enums.ContractType | null
    startDate: Date | string
    plannedCompletion?: Date | string | null
    currentCompletion?: Date | string | null
    healthScore?: number | null
    projectManagerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    contractValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractType?: NullableEnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    contractValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractType?: NullableEnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: NullableIntFieldUpdateOperationsInput | number | null
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DelayEventCreateInput = {
    id?: string
    activityId?: string | null
    activityName: string
    detectionDate: Date | string
    delayDays: number
    causeType: $Enums.DelayType
    probabilityScore?: number | null
    evidenceStrength?: number | null
    status?: $Enums.DelayStatus
    description?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    criticalPath?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDelayEventsInput
    detectedBy: UserCreateNestedOneWithoutDelayEventsInput
    claims?: ClaimCreateNestedManyWithoutDelayEventInput
    evidence?: EvidenceCreateNestedManyWithoutDelayEventInput
  }

  export type DelayEventUncheckedCreateInput = {
    id?: string
    projectId: string
    activityId?: string | null
    activityName: string
    detectionDate: Date | string
    delayDays: number
    causeType: $Enums.DelayType
    probabilityScore?: number | null
    evidenceStrength?: number | null
    status?: $Enums.DelayStatus
    description?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    criticalPath?: boolean
    detectedById: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    claims?: ClaimUncheckedCreateNestedManyWithoutDelayEventInput
    evidence?: EvidenceUncheckedCreateNestedManyWithoutDelayEventInput
  }

  export type DelayEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: StringFieldUpdateOperationsInput | string
    detectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    delayDays?: IntFieldUpdateOperationsInput | number
    causeType?: EnumDelayTypeFieldUpdateOperationsInput | $Enums.DelayType
    probabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    evidenceStrength?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDelayStatusFieldUpdateOperationsInput | $Enums.DelayStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    criticalPath?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDelayEventsNestedInput
    detectedBy?: UserUpdateOneRequiredWithoutDelayEventsNestedInput
    claims?: ClaimUpdateManyWithoutDelayEventNestedInput
    evidence?: EvidenceUpdateManyWithoutDelayEventNestedInput
  }

  export type DelayEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: StringFieldUpdateOperationsInput | string
    detectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    delayDays?: IntFieldUpdateOperationsInput | number
    causeType?: EnumDelayTypeFieldUpdateOperationsInput | $Enums.DelayType
    probabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    evidenceStrength?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDelayStatusFieldUpdateOperationsInput | $Enums.DelayStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    criticalPath?: BoolFieldUpdateOperationsInput | boolean
    detectedById?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claims?: ClaimUncheckedUpdateManyWithoutDelayEventNestedInput
    evidence?: EvidenceUncheckedUpdateManyWithoutDelayEventNestedInput
  }

  export type DelayEventCreateManyInput = {
    id?: string
    projectId: string
    activityId?: string | null
    activityName: string
    detectionDate: Date | string
    delayDays: number
    causeType: $Enums.DelayType
    probabilityScore?: number | null
    evidenceStrength?: number | null
    status?: $Enums.DelayStatus
    description?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    criticalPath?: boolean
    detectedById: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DelayEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: StringFieldUpdateOperationsInput | string
    detectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    delayDays?: IntFieldUpdateOperationsInput | number
    causeType?: EnumDelayTypeFieldUpdateOperationsInput | $Enums.DelayType
    probabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    evidenceStrength?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDelayStatusFieldUpdateOperationsInput | $Enums.DelayStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    criticalPath?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DelayEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: StringFieldUpdateOperationsInput | string
    detectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    delayDays?: IntFieldUpdateOperationsInput | number
    causeType?: EnumDelayTypeFieldUpdateOperationsInput | $Enums.DelayType
    probabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    evidenceStrength?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDelayStatusFieldUpdateOperationsInput | $Enums.DelayStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    criticalPath?: BoolFieldUpdateOperationsInput | boolean
    detectedById?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimCreateInput = {
    id?: string
    referenceNumber: string
    title: string
    description?: string | null
    submissionDate?: Date | string | null
    noticeDate?: Date | string | null
    claimAmount?: Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: number | null
    status?: $Enums.ClaimStatus
    responseDueDate?: Date | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutClaimsInput
    delayEvent?: DelayEventCreateNestedOneWithoutClaimsInput
    submittedBy?: UserCreateNestedOneWithoutClaimsInput
    evidence?: EvidenceCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateInput = {
    id?: string
    projectId: string
    delayEventId?: string | null
    referenceNumber: string
    title: string
    description?: string | null
    submissionDate?: Date | string | null
    noticeDate?: Date | string | null
    claimAmount?: Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: number | null
    status?: $Enums.ClaimStatus
    responseDueDate?: Date | string | null
    submittedById?: string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evidence?: EvidenceUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noticeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    responseDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutClaimsNestedInput
    delayEvent?: DelayEventUpdateOneWithoutClaimsNestedInput
    submittedBy?: UserUpdateOneWithoutClaimsNestedInput
    evidence?: EvidenceUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    delayEventId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noticeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    responseDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedById?: NullableStringFieldUpdateOperationsInput | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evidence?: EvidenceUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimCreateManyInput = {
    id?: string
    projectId: string
    delayEventId?: string | null
    referenceNumber: string
    title: string
    description?: string | null
    submissionDate?: Date | string | null
    noticeDate?: Date | string | null
    claimAmount?: Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: number | null
    status?: $Enums.ClaimStatus
    responseDueDate?: Date | string | null
    submittedById?: string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClaimUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noticeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    responseDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    delayEventId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noticeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    responseDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedById?: NullableStringFieldUpdateOperationsInput | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceCreateInput = {
    id?: string
    type: $Enums.EvidenceType
    title: string
    description?: string | null
    sourceSystem?: string | null
    filePath?: string | null
    relevanceScore?: number | null
    extractedText?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    delayEvent?: DelayEventCreateNestedOneWithoutEvidenceInput
    claim?: ClaimCreateNestedOneWithoutEvidenceInput
    uploadedBy: UserCreateNestedOneWithoutEvidenceInput
    file?: FileMetadataCreateNestedOneWithoutEvidenceInput
  }

  export type EvidenceUncheckedCreateInput = {
    id?: string
    delayEventId?: string | null
    claimId?: string | null
    type: $Enums.EvidenceType
    title: string
    description?: string | null
    sourceSystem?: string | null
    filePath?: string | null
    fileId?: string | null
    relevanceScore?: number | null
    extractedText?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploadedById: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvidenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSystem?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delayEvent?: DelayEventUpdateOneWithoutEvidenceNestedInput
    claim?: ClaimUpdateOneWithoutEvidenceNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutEvidenceNestedInput
    file?: FileMetadataUpdateOneWithoutEvidenceNestedInput
  }

  export type EvidenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    delayEventId?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSystem?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploadedById?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceCreateManyInput = {
    id?: string
    delayEventId?: string | null
    claimId?: string | null
    type: $Enums.EvidenceType
    title: string
    description?: string | null
    sourceSystem?: string | null
    filePath?: string | null
    fileId?: string | null
    relevanceScore?: number | null
    extractedText?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploadedById: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvidenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSystem?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    delayEventId?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSystem?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploadedById?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleCreateInput = {
    id?: string
    name: string
    description?: string | null
    format: $Enums.ScheduleFormat
    version?: string | null
    baselineDate?: Date | string | null
    statusDate?: Date | string | null
    filePath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isBaseline?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSchedulesInput
    file?: FileMetadataCreateNestedOneWithoutSchedulesInput
  }

  export type ScheduleUncheckedCreateInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    format: $Enums.ScheduleFormat
    version?: string | null
    baselineDate?: Date | string | null
    statusDate?: Date | string | null
    filePath?: string | null
    fileId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isBaseline?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumScheduleFormatFieldUpdateOperationsInput | $Enums.ScheduleFormat
    version?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isBaseline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSchedulesNestedInput
    file?: FileMetadataUpdateOneWithoutSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumScheduleFormatFieldUpdateOperationsInput | $Enums.ScheduleFormat
    version?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isBaseline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleCreateManyInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    format: $Enums.ScheduleFormat
    version?: string | null
    baselineDate?: Date | string | null
    statusDate?: Date | string | null
    filePath?: string | null
    fileId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isBaseline?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumScheduleFormatFieldUpdateOperationsInput | $Enums.ScheduleFormat
    version?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isBaseline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumScheduleFormatFieldUpdateOperationsInput | $Enums.ScheduleFormat
    version?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isBaseline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionItemCreateInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    dueDate: Date | string
    status?: $Enums.ActionItemStatus
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutActionItemsInput
    assignedTo: UserCreateNestedOneWithoutActionItemsInput
  }

  export type ActionItemUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    dueDate: Date | string
    projectId: string
    assignedToId: string
    status?: $Enums.ActionItemStatus
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumActionItemStatusFieldUpdateOperationsInput | $Enums.ActionItemStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutActionItemsNestedInput
    assignedTo?: UserUpdateOneRequiredWithoutActionItemsNestedInput
  }

  export type ActionItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    status?: EnumActionItemStatusFieldUpdateOperationsInput | $Enums.ActionItemStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionItemCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    dueDate: Date | string
    projectId: string
    assignedToId: string
    status?: $Enums.ActionItemStatus
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumActionItemStatusFieldUpdateOperationsInput | $Enums.ActionItemStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    status?: EnumActionItemStatusFieldUpdateOperationsInput | $Enums.ActionItemStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileMetadataCreateInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint | number
    checksum?: string | null
    path: string
    isPublic?: boolean
    tags?: FileMetadataCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutFilesInput
    uploadedBy: UserCreateNestedOneWithoutFilesUploadedInput
    evidence?: EvidenceCreateNestedManyWithoutFileInput
    schedules?: ScheduleCreateNestedManyWithoutFileInput
  }

  export type FileMetadataUncheckedCreateInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint | number
    checksum?: string | null
    organizationId: string
    uploadedById: string
    path: string
    isPublic?: boolean
    tags?: FileMetadataCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evidence?: EvidenceUncheckedCreateNestedManyWithoutFileInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileMetadataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: FileMetadataUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutFilesNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutFilesUploadedNestedInput
    evidence?: EvidenceUpdateManyWithoutFileNestedInput
    schedules?: ScheduleUpdateManyWithoutFileNestedInput
  }

  export type FileMetadataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: FileMetadataUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evidence?: EvidenceUncheckedUpdateManyWithoutFileNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutFileNestedInput
  }

  export type FileMetadataCreateManyInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint | number
    checksum?: string | null
    organizationId: string
    uploadedById: string
    path: string
    isPublic?: boolean
    tags?: FileMetadataCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileMetadataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: FileMetadataUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileMetadataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: FileMetadataUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageQuotaCreateInput = {
    id?: string
    usedBytes?: bigint | number
    limitBytes: bigint | number
    fileCount?: number
    maxFileCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutQuotasInput
  }

  export type StorageQuotaUncheckedCreateInput = {
    id?: string
    organizationId: string
    usedBytes?: bigint | number
    limitBytes: bigint | number
    fileCount?: number
    maxFileCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorageQuotaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    limitBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    fileCount?: IntFieldUpdateOperationsInput | number
    maxFileCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutQuotasNestedInput
  }

  export type StorageQuotaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    usedBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    limitBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    fileCount?: IntFieldUpdateOperationsInput | number
    maxFileCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageQuotaCreateManyInput = {
    id?: string
    organizationId: string
    usedBytes?: bigint | number
    limitBytes: bigint | number
    fileCount?: number
    maxFileCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorageQuotaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    limitBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    fileCount?: IntFieldUpdateOperationsInput | number
    maxFileCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageQuotaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    usedBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    limitBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    fileCount?: IntFieldUpdateOperationsInput | number
    maxFileCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionDataCreateInput = {
    id?: string
    deviceInfo: JsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    lastActivityAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionDataUncheckedCreateInput = {
    id?: string
    userId: string
    deviceInfo: JsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    lastActivityAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceInfo?: JsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceInfo?: JsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionDataCreateManyInput = {
    id?: string
    userId: string
    deviceInfo: JsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    lastActivityAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceInfo?: JsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceInfo?: JsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MfaSettingsCreateInput = {
    id?: string
    isEnabled?: boolean
    method: $Enums.MfaMethod
    secret?: string | null
    backupCodes?: MfaSettingsCreatebackupCodesInput | string[]
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMfaSettingsInput
  }

  export type MfaSettingsUncheckedCreateInput = {
    id?: string
    userId: string
    isEnabled?: boolean
    method: $Enums.MfaMethod
    secret?: string | null
    backupCodes?: MfaSettingsCreatebackupCodesInput | string[]
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MfaSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    method?: EnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: MfaSettingsUpdatebackupCodesInput | string[]
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMfaSettingsNestedInput
  }

  export type MfaSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    method?: EnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: MfaSettingsUpdatebackupCodesInput | string[]
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MfaSettingsCreateManyInput = {
    id?: string
    userId: string
    isEnabled?: boolean
    method: $Enums.MfaMethod
    secret?: string | null
    backupCodes?: MfaSettingsCreatebackupCodesInput | string[]
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MfaSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    method?: EnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: MfaSettingsUpdatebackupCodesInput | string[]
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MfaSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    method?: EnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: MfaSettingsUpdatebackupCodesInput | string[]
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    isUsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordResetsInput
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    isUsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetsNestedInput
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    isUsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventCreateInput = {
    id?: string
    eventType: string
    userId?: string | null
    properties?: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutEventsInput
  }

  export type AnalyticsEventUncheckedCreateInput = {
    id?: string
    eventType: string
    userId?: string | null
    organizationId: string
    properties?: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type AnalyticsEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutEventsNestedInput
  }

  export type AnalyticsEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    properties?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventCreateManyInput = {
    id?: string
    eventType: string
    userId?: string | null
    organizationId: string
    properties?: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type AnalyticsEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    properties?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
    organization: OrganizationCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    userId: string
    organizationId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    userId: string
    organizationId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type FileMetadataListRelationFilter = {
    every?: FileMetadataWhereInput
    some?: FileMetadataWhereInput
    none?: FileMetadataWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type AnalyticsEventListRelationFilter = {
    every?: AnalyticsEventWhereInput
    some?: AnalyticsEventWhereInput
    none?: AnalyticsEventWhereInput
  }

  export type StorageQuotaListRelationFilter = {
    every?: StorageQuotaWhereInput
    some?: StorageQuotaWhereInput
    none?: StorageQuotaWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileMetadataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalyticsEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StorageQuotaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    isActive?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    domain?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type DelayEventListRelationFilter = {
    every?: DelayEventWhereInput
    some?: DelayEventWhereInput
    none?: DelayEventWhereInput
  }

  export type ClaimListRelationFilter = {
    every?: ClaimWhereInput
    some?: ClaimWhereInput
    none?: ClaimWhereInput
  }

  export type EvidenceListRelationFilter = {
    every?: EvidenceWhereInput
    some?: EvidenceWhereInput
    none?: EvidenceWhereInput
  }

  export type ActionItemListRelationFilter = {
    every?: ActionItemWhereInput
    some?: ActionItemWhereInput
    none?: ActionItemWhereInput
  }

  export type SessionDataListRelationFilter = {
    every?: SessionDataWhereInput
    some?: SessionDataWhereInput
    none?: SessionDataWhereInput
  }

  export type MfaSettingsNullableScalarRelationFilter = {
    is?: MfaSettingsWhereInput | null
    isNot?: MfaSettingsWhereInput | null
  }

  export type PasswordResetTokenListRelationFilter = {
    every?: PasswordResetTokenWhereInput
    some?: PasswordResetTokenWhereInput
    none?: PasswordResetTokenWhereInput
  }

  export type DelayEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClaimOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EvidenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordResetTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    organizationId?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    organizationId?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    organizationId?: SortOrder
    isActive?: SortOrder
    lastLoginAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumContractTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContractTypeNullableFilter<$PrismaModel> | $Enums.ContractType | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ScheduleListRelationFilter = {
    every?: ScheduleWhereInput
    some?: ScheduleWhereInput
    none?: ScheduleWhereInput
  }

  export type ScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    organizationId?: SortOrder
    status?: SortOrder
    contractValue?: SortOrder
    contractType?: SortOrder
    startDate?: SortOrder
    plannedCompletion?: SortOrder
    currentCompletion?: SortOrder
    healthScore?: SortOrder
    projectManagerId?: SortOrder
    metadata?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    contractValue?: SortOrder
    healthScore?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    organizationId?: SortOrder
    status?: SortOrder
    contractValue?: SortOrder
    contractType?: SortOrder
    startDate?: SortOrder
    plannedCompletion?: SortOrder
    currentCompletion?: SortOrder
    healthScore?: SortOrder
    projectManagerId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    location?: SortOrder
    organizationId?: SortOrder
    status?: SortOrder
    contractValue?: SortOrder
    contractType?: SortOrder
    startDate?: SortOrder
    plannedCompletion?: SortOrder
    currentCompletion?: SortOrder
    healthScore?: SortOrder
    projectManagerId?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    contractValue?: SortOrder
    healthScore?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumContractTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContractTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ContractType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumContractTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumContractTypeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumDelayTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DelayType | EnumDelayTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DelayType[] | ListEnumDelayTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DelayType[] | ListEnumDelayTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDelayTypeFilter<$PrismaModel> | $Enums.DelayType
  }

  export type EnumDelayStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DelayStatus | EnumDelayStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DelayStatus[] | ListEnumDelayStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DelayStatus[] | ListEnumDelayStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDelayStatusFilter<$PrismaModel> | $Enums.DelayStatus
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DelayEventCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    activityId?: SortOrder
    activityName?: SortOrder
    detectionDate?: SortOrder
    delayDays?: SortOrder
    causeType?: SortOrder
    probabilityScore?: SortOrder
    evidenceStrength?: SortOrder
    status?: SortOrder
    description?: SortOrder
    estimatedCost?: SortOrder
    criticalPath?: SortOrder
    detectedById?: SortOrder
    metadata?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DelayEventAvgOrderByAggregateInput = {
    delayDays?: SortOrder
    probabilityScore?: SortOrder
    evidenceStrength?: SortOrder
    estimatedCost?: SortOrder
  }

  export type DelayEventMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    activityId?: SortOrder
    activityName?: SortOrder
    detectionDate?: SortOrder
    delayDays?: SortOrder
    causeType?: SortOrder
    probabilityScore?: SortOrder
    evidenceStrength?: SortOrder
    status?: SortOrder
    description?: SortOrder
    estimatedCost?: SortOrder
    criticalPath?: SortOrder
    detectedById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DelayEventMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    activityId?: SortOrder
    activityName?: SortOrder
    detectionDate?: SortOrder
    delayDays?: SortOrder
    causeType?: SortOrder
    probabilityScore?: SortOrder
    evidenceStrength?: SortOrder
    status?: SortOrder
    description?: SortOrder
    estimatedCost?: SortOrder
    criticalPath?: SortOrder
    detectedById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DelayEventSumOrderByAggregateInput = {
    delayDays?: SortOrder
    probabilityScore?: SortOrder
    evidenceStrength?: SortOrder
    estimatedCost?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumDelayTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DelayType | EnumDelayTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DelayType[] | ListEnumDelayTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DelayType[] | ListEnumDelayTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDelayTypeWithAggregatesFilter<$PrismaModel> | $Enums.DelayType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDelayTypeFilter<$PrismaModel>
    _max?: NestedEnumDelayTypeFilter<$PrismaModel>
  }

  export type EnumDelayStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DelayStatus | EnumDelayStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DelayStatus[] | ListEnumDelayStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DelayStatus[] | ListEnumDelayStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDelayStatusWithAggregatesFilter<$PrismaModel> | $Enums.DelayStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDelayStatusFilter<$PrismaModel>
    _max?: NestedEnumDelayStatusFilter<$PrismaModel>
  }

  export type EnumClaimStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusFilter<$PrismaModel> | $Enums.ClaimStatus
  }

  export type DelayEventNullableScalarRelationFilter = {
    is?: DelayEventWhereInput | null
    isNot?: DelayEventWhereInput | null
  }

  export type ClaimCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    delayEventId?: SortOrder
    referenceNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    submissionDate?: SortOrder
    noticeDate?: SortOrder
    claimAmount?: SortOrder
    timeImpactDays?: SortOrder
    status?: SortOrder
    responseDueDate?: SortOrder
    submittedById?: SortOrder
    workflow?: SortOrder
    metadata?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClaimAvgOrderByAggregateInput = {
    claimAmount?: SortOrder
    timeImpactDays?: SortOrder
  }

  export type ClaimMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    delayEventId?: SortOrder
    referenceNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    submissionDate?: SortOrder
    noticeDate?: SortOrder
    claimAmount?: SortOrder
    timeImpactDays?: SortOrder
    status?: SortOrder
    responseDueDate?: SortOrder
    submittedById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClaimMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    delayEventId?: SortOrder
    referenceNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    submissionDate?: SortOrder
    noticeDate?: SortOrder
    claimAmount?: SortOrder
    timeImpactDays?: SortOrder
    status?: SortOrder
    responseDueDate?: SortOrder
    submittedById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClaimSumOrderByAggregateInput = {
    claimAmount?: SortOrder
    timeImpactDays?: SortOrder
  }

  export type EnumClaimStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClaimStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClaimStatusFilter<$PrismaModel>
    _max?: NestedEnumClaimStatusFilter<$PrismaModel>
  }

  export type EnumEvidenceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EvidenceType | EnumEvidenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EvidenceType[] | ListEnumEvidenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvidenceType[] | ListEnumEvidenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEvidenceTypeFilter<$PrismaModel> | $Enums.EvidenceType
  }

  export type ClaimNullableScalarRelationFilter = {
    is?: ClaimWhereInput | null
    isNot?: ClaimWhereInput | null
  }

  export type FileMetadataNullableScalarRelationFilter = {
    is?: FileMetadataWhereInput | null
    isNot?: FileMetadataWhereInput | null
  }

  export type EvidenceCountOrderByAggregateInput = {
    id?: SortOrder
    delayEventId?: SortOrder
    claimId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sourceSystem?: SortOrder
    filePath?: SortOrder
    fileId?: SortOrder
    relevanceScore?: SortOrder
    extractedText?: SortOrder
    metadata?: SortOrder
    uploadedById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvidenceAvgOrderByAggregateInput = {
    relevanceScore?: SortOrder
  }

  export type EvidenceMaxOrderByAggregateInput = {
    id?: SortOrder
    delayEventId?: SortOrder
    claimId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sourceSystem?: SortOrder
    filePath?: SortOrder
    fileId?: SortOrder
    relevanceScore?: SortOrder
    extractedText?: SortOrder
    uploadedById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvidenceMinOrderByAggregateInput = {
    id?: SortOrder
    delayEventId?: SortOrder
    claimId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    sourceSystem?: SortOrder
    filePath?: SortOrder
    fileId?: SortOrder
    relevanceScore?: SortOrder
    extractedText?: SortOrder
    uploadedById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EvidenceSumOrderByAggregateInput = {
    relevanceScore?: SortOrder
  }

  export type EnumEvidenceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EvidenceType | EnumEvidenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EvidenceType[] | ListEnumEvidenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvidenceType[] | ListEnumEvidenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEvidenceTypeWithAggregatesFilter<$PrismaModel> | $Enums.EvidenceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEvidenceTypeFilter<$PrismaModel>
    _max?: NestedEnumEvidenceTypeFilter<$PrismaModel>
  }

  export type EnumScheduleFormatFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleFormat | EnumScheduleFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleFormat[] | ListEnumScheduleFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleFormat[] | ListEnumScheduleFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleFormatFilter<$PrismaModel> | $Enums.ScheduleFormat
  }

  export type ScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    format?: SortOrder
    version?: SortOrder
    baselineDate?: SortOrder
    statusDate?: SortOrder
    filePath?: SortOrder
    fileId?: SortOrder
    metadata?: SortOrder
    isBaseline?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    format?: SortOrder
    version?: SortOrder
    baselineDate?: SortOrder
    statusDate?: SortOrder
    filePath?: SortOrder
    fileId?: SortOrder
    isBaseline?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    format?: SortOrder
    version?: SortOrder
    baselineDate?: SortOrder
    statusDate?: SortOrder
    filePath?: SortOrder
    fileId?: SortOrder
    isBaseline?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumScheduleFormatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleFormat | EnumScheduleFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleFormat[] | ListEnumScheduleFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleFormat[] | ListEnumScheduleFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleFormatWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleFormat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduleFormatFilter<$PrismaModel>
    _max?: NestedEnumScheduleFormatFilter<$PrismaModel>
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type EnumActionItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionItemStatus | EnumActionItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActionItemStatus[] | ListEnumActionItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionItemStatus[] | ListEnumActionItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActionItemStatusFilter<$PrismaModel> | $Enums.ActionItemStatus
  }

  export type ActionItemCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    projectId?: SortOrder
    assignedToId?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    metadata?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    projectId?: SortOrder
    assignedToId?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ActionItemMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    dueDate?: SortOrder
    projectId?: SortOrder
    assignedToId?: SortOrder
    status?: SortOrder
    completedAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type EnumActionItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionItemStatus | EnumActionItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActionItemStatus[] | ListEnumActionItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionItemStatus[] | ListEnumActionItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActionItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.ActionItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionItemStatusFilter<$PrismaModel>
    _max?: NestedEnumActionItemStatusFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type FileMetadataCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    checksum?: SortOrder
    organizationId?: SortOrder
    uploadedById?: SortOrder
    path?: SortOrder
    isPublic?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileMetadataAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type FileMetadataMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    checksum?: SortOrder
    organizationId?: SortOrder
    uploadedById?: SortOrder
    path?: SortOrder
    isPublic?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileMetadataMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    checksum?: SortOrder
    organizationId?: SortOrder
    uploadedById?: SortOrder
    path?: SortOrder
    isPublic?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileMetadataSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StorageQuotaCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    usedBytes?: SortOrder
    limitBytes?: SortOrder
    fileCount?: SortOrder
    maxFileCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageQuotaAvgOrderByAggregateInput = {
    usedBytes?: SortOrder
    limitBytes?: SortOrder
    fileCount?: SortOrder
    maxFileCount?: SortOrder
  }

  export type StorageQuotaMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    usedBytes?: SortOrder
    limitBytes?: SortOrder
    fileCount?: SortOrder
    maxFileCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageQuotaMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    usedBytes?: SortOrder
    limitBytes?: SortOrder
    fileCount?: SortOrder
    maxFileCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StorageQuotaSumOrderByAggregateInput = {
    usedBytes?: SortOrder
    limitBytes?: SortOrder
    fileCount?: SortOrder
    maxFileCount?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SessionDataCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceInfo?: SortOrder
    location?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionDataMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionDataMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    lastActivityAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumMfaMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.MfaMethod | EnumMfaMethodFieldRefInput<$PrismaModel>
    in?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumMfaMethodFilter<$PrismaModel> | $Enums.MfaMethod
  }

  export type MfaSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    isEnabled?: SortOrder
    method?: SortOrder
    secret?: SortOrder
    backupCodes?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MfaSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    isEnabled?: SortOrder
    method?: SortOrder
    secret?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MfaSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    isEnabled?: SortOrder
    method?: SortOrder
    secret?: SortOrder
    lastUsedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMfaMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MfaMethod | EnumMfaMethodFieldRefInput<$PrismaModel>
    in?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumMfaMethodWithAggregatesFilter<$PrismaModel> | $Enums.MfaMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMfaMethodFilter<$PrismaModel>
    _max?: NestedEnumMfaMethodFilter<$PrismaModel>
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    isUsed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsEventCountOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    properties?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsEventMaxOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsEventMinOrderByAggregateInput = {
    id?: SortOrder
    eventType?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    changes?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
  }

  export type UserCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput> | ProjectCreateWithoutOrganizationInput[] | ProjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrganizationInput | ProjectCreateOrConnectWithoutOrganizationInput[]
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type FileMetadataCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<FileMetadataCreateWithoutOrganizationInput, FileMetadataUncheckedCreateWithoutOrganizationInput> | FileMetadataCreateWithoutOrganizationInput[] | FileMetadataUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutOrganizationInput | FileMetadataCreateOrConnectWithoutOrganizationInput[]
    createMany?: FileMetadataCreateManyOrganizationInputEnvelope
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<AuditLogCreateWithoutOrganizationInput, AuditLogUncheckedCreateWithoutOrganizationInput> | AuditLogCreateWithoutOrganizationInput[] | AuditLogUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutOrganizationInput | AuditLogCreateOrConnectWithoutOrganizationInput[]
    createMany?: AuditLogCreateManyOrganizationInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AnalyticsEventCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<AnalyticsEventCreateWithoutOrganizationInput, AnalyticsEventUncheckedCreateWithoutOrganizationInput> | AnalyticsEventCreateWithoutOrganizationInput[] | AnalyticsEventUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AnalyticsEventCreateOrConnectWithoutOrganizationInput | AnalyticsEventCreateOrConnectWithoutOrganizationInput[]
    createMany?: AnalyticsEventCreateManyOrganizationInputEnvelope
    connect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
  }

  export type StorageQuotaCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<StorageQuotaCreateWithoutOrganizationInput, StorageQuotaUncheckedCreateWithoutOrganizationInput> | StorageQuotaCreateWithoutOrganizationInput[] | StorageQuotaUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: StorageQuotaCreateOrConnectWithoutOrganizationInput | StorageQuotaCreateOrConnectWithoutOrganizationInput[]
    createMany?: StorageQuotaCreateManyOrganizationInputEnvelope
    connect?: StorageQuotaWhereUniqueInput | StorageQuotaWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput> | ProjectCreateWithoutOrganizationInput[] | ProjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrganizationInput | ProjectCreateOrConnectWithoutOrganizationInput[]
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type FileMetadataUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<FileMetadataCreateWithoutOrganizationInput, FileMetadataUncheckedCreateWithoutOrganizationInput> | FileMetadataCreateWithoutOrganizationInput[] | FileMetadataUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutOrganizationInput | FileMetadataCreateOrConnectWithoutOrganizationInput[]
    createMany?: FileMetadataCreateManyOrganizationInputEnvelope
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<AuditLogCreateWithoutOrganizationInput, AuditLogUncheckedCreateWithoutOrganizationInput> | AuditLogCreateWithoutOrganizationInput[] | AuditLogUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutOrganizationInput | AuditLogCreateOrConnectWithoutOrganizationInput[]
    createMany?: AuditLogCreateManyOrganizationInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AnalyticsEventUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<AnalyticsEventCreateWithoutOrganizationInput, AnalyticsEventUncheckedCreateWithoutOrganizationInput> | AnalyticsEventCreateWithoutOrganizationInput[] | AnalyticsEventUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AnalyticsEventCreateOrConnectWithoutOrganizationInput | AnalyticsEventCreateOrConnectWithoutOrganizationInput[]
    createMany?: AnalyticsEventCreateManyOrganizationInputEnvelope
    connect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
  }

  export type StorageQuotaUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<StorageQuotaCreateWithoutOrganizationInput, StorageQuotaUncheckedCreateWithoutOrganizationInput> | StorageQuotaCreateWithoutOrganizationInput[] | StorageQuotaUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: StorageQuotaCreateOrConnectWithoutOrganizationInput | StorageQuotaCreateOrConnectWithoutOrganizationInput[]
    createMany?: StorageQuotaCreateManyOrganizationInputEnvelope
    connect?: StorageQuotaWhereUniqueInput | StorageQuotaWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput> | ProjectCreateWithoutOrganizationInput[] | ProjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrganizationInput | ProjectCreateOrConnectWithoutOrganizationInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOrganizationInput | ProjectUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOrganizationInput | ProjectUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOrganizationInput | ProjectUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type FileMetadataUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<FileMetadataCreateWithoutOrganizationInput, FileMetadataUncheckedCreateWithoutOrganizationInput> | FileMetadataCreateWithoutOrganizationInput[] | FileMetadataUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutOrganizationInput | FileMetadataCreateOrConnectWithoutOrganizationInput[]
    upsert?: FileMetadataUpsertWithWhereUniqueWithoutOrganizationInput | FileMetadataUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: FileMetadataCreateManyOrganizationInputEnvelope
    set?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    disconnect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    delete?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    update?: FileMetadataUpdateWithWhereUniqueWithoutOrganizationInput | FileMetadataUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: FileMetadataUpdateManyWithWhereWithoutOrganizationInput | FileMetadataUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<AuditLogCreateWithoutOrganizationInput, AuditLogUncheckedCreateWithoutOrganizationInput> | AuditLogCreateWithoutOrganizationInput[] | AuditLogUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutOrganizationInput | AuditLogCreateOrConnectWithoutOrganizationInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutOrganizationInput | AuditLogUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: AuditLogCreateManyOrganizationInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutOrganizationInput | AuditLogUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutOrganizationInput | AuditLogUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AnalyticsEventUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<AnalyticsEventCreateWithoutOrganizationInput, AnalyticsEventUncheckedCreateWithoutOrganizationInput> | AnalyticsEventCreateWithoutOrganizationInput[] | AnalyticsEventUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AnalyticsEventCreateOrConnectWithoutOrganizationInput | AnalyticsEventCreateOrConnectWithoutOrganizationInput[]
    upsert?: AnalyticsEventUpsertWithWhereUniqueWithoutOrganizationInput | AnalyticsEventUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: AnalyticsEventCreateManyOrganizationInputEnvelope
    set?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    disconnect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    delete?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    connect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    update?: AnalyticsEventUpdateWithWhereUniqueWithoutOrganizationInput | AnalyticsEventUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: AnalyticsEventUpdateManyWithWhereWithoutOrganizationInput | AnalyticsEventUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: AnalyticsEventScalarWhereInput | AnalyticsEventScalarWhereInput[]
  }

  export type StorageQuotaUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<StorageQuotaCreateWithoutOrganizationInput, StorageQuotaUncheckedCreateWithoutOrganizationInput> | StorageQuotaCreateWithoutOrganizationInput[] | StorageQuotaUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: StorageQuotaCreateOrConnectWithoutOrganizationInput | StorageQuotaCreateOrConnectWithoutOrganizationInput[]
    upsert?: StorageQuotaUpsertWithWhereUniqueWithoutOrganizationInput | StorageQuotaUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: StorageQuotaCreateManyOrganizationInputEnvelope
    set?: StorageQuotaWhereUniqueInput | StorageQuotaWhereUniqueInput[]
    disconnect?: StorageQuotaWhereUniqueInput | StorageQuotaWhereUniqueInput[]
    delete?: StorageQuotaWhereUniqueInput | StorageQuotaWhereUniqueInput[]
    connect?: StorageQuotaWhereUniqueInput | StorageQuotaWhereUniqueInput[]
    update?: StorageQuotaUpdateWithWhereUniqueWithoutOrganizationInput | StorageQuotaUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: StorageQuotaUpdateManyWithWhereWithoutOrganizationInput | StorageQuotaUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: StorageQuotaScalarWhereInput | StorageQuotaScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput> | ProjectCreateWithoutOrganizationInput[] | ProjectUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutOrganizationInput | ProjectCreateOrConnectWithoutOrganizationInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutOrganizationInput | ProjectUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ProjectCreateManyOrganizationInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutOrganizationInput | ProjectUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutOrganizationInput | ProjectUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type FileMetadataUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<FileMetadataCreateWithoutOrganizationInput, FileMetadataUncheckedCreateWithoutOrganizationInput> | FileMetadataCreateWithoutOrganizationInput[] | FileMetadataUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutOrganizationInput | FileMetadataCreateOrConnectWithoutOrganizationInput[]
    upsert?: FileMetadataUpsertWithWhereUniqueWithoutOrganizationInput | FileMetadataUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: FileMetadataCreateManyOrganizationInputEnvelope
    set?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    disconnect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    delete?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    update?: FileMetadataUpdateWithWhereUniqueWithoutOrganizationInput | FileMetadataUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: FileMetadataUpdateManyWithWhereWithoutOrganizationInput | FileMetadataUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<AuditLogCreateWithoutOrganizationInput, AuditLogUncheckedCreateWithoutOrganizationInput> | AuditLogCreateWithoutOrganizationInput[] | AuditLogUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutOrganizationInput | AuditLogCreateOrConnectWithoutOrganizationInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutOrganizationInput | AuditLogUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: AuditLogCreateManyOrganizationInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutOrganizationInput | AuditLogUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutOrganizationInput | AuditLogUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AnalyticsEventUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<AnalyticsEventCreateWithoutOrganizationInput, AnalyticsEventUncheckedCreateWithoutOrganizationInput> | AnalyticsEventCreateWithoutOrganizationInput[] | AnalyticsEventUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AnalyticsEventCreateOrConnectWithoutOrganizationInput | AnalyticsEventCreateOrConnectWithoutOrganizationInput[]
    upsert?: AnalyticsEventUpsertWithWhereUniqueWithoutOrganizationInput | AnalyticsEventUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: AnalyticsEventCreateManyOrganizationInputEnvelope
    set?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    disconnect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    delete?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    connect?: AnalyticsEventWhereUniqueInput | AnalyticsEventWhereUniqueInput[]
    update?: AnalyticsEventUpdateWithWhereUniqueWithoutOrganizationInput | AnalyticsEventUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: AnalyticsEventUpdateManyWithWhereWithoutOrganizationInput | AnalyticsEventUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: AnalyticsEventScalarWhereInput | AnalyticsEventScalarWhereInput[]
  }

  export type StorageQuotaUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<StorageQuotaCreateWithoutOrganizationInput, StorageQuotaUncheckedCreateWithoutOrganizationInput> | StorageQuotaCreateWithoutOrganizationInput[] | StorageQuotaUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: StorageQuotaCreateOrConnectWithoutOrganizationInput | StorageQuotaCreateOrConnectWithoutOrganizationInput[]
    upsert?: StorageQuotaUpsertWithWhereUniqueWithoutOrganizationInput | StorageQuotaUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: StorageQuotaCreateManyOrganizationInputEnvelope
    set?: StorageQuotaWhereUniqueInput | StorageQuotaWhereUniqueInput[]
    disconnect?: StorageQuotaWhereUniqueInput | StorageQuotaWhereUniqueInput[]
    delete?: StorageQuotaWhereUniqueInput | StorageQuotaWhereUniqueInput[]
    connect?: StorageQuotaWhereUniqueInput | StorageQuotaWhereUniqueInput[]
    update?: StorageQuotaUpdateWithWhereUniqueWithoutOrganizationInput | StorageQuotaUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: StorageQuotaUpdateManyWithWhereWithoutOrganizationInput | StorageQuotaUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: StorageQuotaScalarWhereInput | StorageQuotaScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutUsersInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type ProjectCreateNestedManyWithoutProjectManagerInput = {
    create?: XOR<ProjectCreateWithoutProjectManagerInput, ProjectUncheckedCreateWithoutProjectManagerInput> | ProjectCreateWithoutProjectManagerInput[] | ProjectUncheckedCreateWithoutProjectManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectManagerInput | ProjectCreateOrConnectWithoutProjectManagerInput[]
    createMany?: ProjectCreateManyProjectManagerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type DelayEventCreateNestedManyWithoutDetectedByInput = {
    create?: XOR<DelayEventCreateWithoutDetectedByInput, DelayEventUncheckedCreateWithoutDetectedByInput> | DelayEventCreateWithoutDetectedByInput[] | DelayEventUncheckedCreateWithoutDetectedByInput[]
    connectOrCreate?: DelayEventCreateOrConnectWithoutDetectedByInput | DelayEventCreateOrConnectWithoutDetectedByInput[]
    createMany?: DelayEventCreateManyDetectedByInputEnvelope
    connect?: DelayEventWhereUniqueInput | DelayEventWhereUniqueInput[]
  }

  export type ClaimCreateNestedManyWithoutSubmittedByInput = {
    create?: XOR<ClaimCreateWithoutSubmittedByInput, ClaimUncheckedCreateWithoutSubmittedByInput> | ClaimCreateWithoutSubmittedByInput[] | ClaimUncheckedCreateWithoutSubmittedByInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutSubmittedByInput | ClaimCreateOrConnectWithoutSubmittedByInput[]
    createMany?: ClaimCreateManySubmittedByInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type EvidenceCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<EvidenceCreateWithoutUploadedByInput, EvidenceUncheckedCreateWithoutUploadedByInput> | EvidenceCreateWithoutUploadedByInput[] | EvidenceUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutUploadedByInput | EvidenceCreateOrConnectWithoutUploadedByInput[]
    createMany?: EvidenceCreateManyUploadedByInputEnvelope
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
  }

  export type ActionItemCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<ActionItemCreateWithoutAssignedToInput, ActionItemUncheckedCreateWithoutAssignedToInput> | ActionItemCreateWithoutAssignedToInput[] | ActionItemUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ActionItemCreateOrConnectWithoutAssignedToInput | ActionItemCreateOrConnectWithoutAssignedToInput[]
    createMany?: ActionItemCreateManyAssignedToInputEnvelope
    connect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
  }

  export type FileMetadataCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<FileMetadataCreateWithoutUploadedByInput, FileMetadataUncheckedCreateWithoutUploadedByInput> | FileMetadataCreateWithoutUploadedByInput[] | FileMetadataUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutUploadedByInput | FileMetadataCreateOrConnectWithoutUploadedByInput[]
    createMany?: FileMetadataCreateManyUploadedByInputEnvelope
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
  }

  export type SessionDataCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionDataCreateWithoutUserInput, SessionDataUncheckedCreateWithoutUserInput> | SessionDataCreateWithoutUserInput[] | SessionDataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionDataCreateOrConnectWithoutUserInput | SessionDataCreateOrConnectWithoutUserInput[]
    createMany?: SessionDataCreateManyUserInputEnvelope
    connect?: SessionDataWhereUniqueInput | SessionDataWhereUniqueInput[]
  }

  export type MfaSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<MfaSettingsCreateWithoutUserInput, MfaSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: MfaSettingsCreateOrConnectWithoutUserInput
    connect?: MfaSettingsWhereUniqueInput
  }

  export type PasswordResetTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutProjectManagerInput = {
    create?: XOR<ProjectCreateWithoutProjectManagerInput, ProjectUncheckedCreateWithoutProjectManagerInput> | ProjectCreateWithoutProjectManagerInput[] | ProjectUncheckedCreateWithoutProjectManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectManagerInput | ProjectCreateOrConnectWithoutProjectManagerInput[]
    createMany?: ProjectCreateManyProjectManagerInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type DelayEventUncheckedCreateNestedManyWithoutDetectedByInput = {
    create?: XOR<DelayEventCreateWithoutDetectedByInput, DelayEventUncheckedCreateWithoutDetectedByInput> | DelayEventCreateWithoutDetectedByInput[] | DelayEventUncheckedCreateWithoutDetectedByInput[]
    connectOrCreate?: DelayEventCreateOrConnectWithoutDetectedByInput | DelayEventCreateOrConnectWithoutDetectedByInput[]
    createMany?: DelayEventCreateManyDetectedByInputEnvelope
    connect?: DelayEventWhereUniqueInput | DelayEventWhereUniqueInput[]
  }

  export type ClaimUncheckedCreateNestedManyWithoutSubmittedByInput = {
    create?: XOR<ClaimCreateWithoutSubmittedByInput, ClaimUncheckedCreateWithoutSubmittedByInput> | ClaimCreateWithoutSubmittedByInput[] | ClaimUncheckedCreateWithoutSubmittedByInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutSubmittedByInput | ClaimCreateOrConnectWithoutSubmittedByInput[]
    createMany?: ClaimCreateManySubmittedByInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type EvidenceUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<EvidenceCreateWithoutUploadedByInput, EvidenceUncheckedCreateWithoutUploadedByInput> | EvidenceCreateWithoutUploadedByInput[] | EvidenceUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutUploadedByInput | EvidenceCreateOrConnectWithoutUploadedByInput[]
    createMany?: EvidenceCreateManyUploadedByInputEnvelope
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
  }

  export type ActionItemUncheckedCreateNestedManyWithoutAssignedToInput = {
    create?: XOR<ActionItemCreateWithoutAssignedToInput, ActionItemUncheckedCreateWithoutAssignedToInput> | ActionItemCreateWithoutAssignedToInput[] | ActionItemUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ActionItemCreateOrConnectWithoutAssignedToInput | ActionItemCreateOrConnectWithoutAssignedToInput[]
    createMany?: ActionItemCreateManyAssignedToInputEnvelope
    connect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
  }

  export type FileMetadataUncheckedCreateNestedManyWithoutUploadedByInput = {
    create?: XOR<FileMetadataCreateWithoutUploadedByInput, FileMetadataUncheckedCreateWithoutUploadedByInput> | FileMetadataCreateWithoutUploadedByInput[] | FileMetadataUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutUploadedByInput | FileMetadataCreateOrConnectWithoutUploadedByInput[]
    createMany?: FileMetadataCreateManyUploadedByInputEnvelope
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
  }

  export type SessionDataUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionDataCreateWithoutUserInput, SessionDataUncheckedCreateWithoutUserInput> | SessionDataCreateWithoutUserInput[] | SessionDataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionDataCreateOrConnectWithoutUserInput | SessionDataCreateOrConnectWithoutUserInput[]
    createMany?: SessionDataCreateManyUserInputEnvelope
    connect?: SessionDataWhereUniqueInput | SessionDataWhereUniqueInput[]
  }

  export type MfaSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<MfaSettingsCreateWithoutUserInput, MfaSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: MfaSettingsCreateOrConnectWithoutUserInput
    connect?: MfaSettingsWhereUniqueInput
  }

  export type PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type OrganizationUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    upsert?: OrganizationUpsertWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUsersInput, OrganizationUpdateWithoutUsersInput>, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type ProjectUpdateManyWithoutProjectManagerNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectManagerInput, ProjectUncheckedCreateWithoutProjectManagerInput> | ProjectCreateWithoutProjectManagerInput[] | ProjectUncheckedCreateWithoutProjectManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectManagerInput | ProjectCreateOrConnectWithoutProjectManagerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProjectManagerInput | ProjectUpsertWithWhereUniqueWithoutProjectManagerInput[]
    createMany?: ProjectCreateManyProjectManagerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProjectManagerInput | ProjectUpdateWithWhereUniqueWithoutProjectManagerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProjectManagerInput | ProjectUpdateManyWithWhereWithoutProjectManagerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type DelayEventUpdateManyWithoutDetectedByNestedInput = {
    create?: XOR<DelayEventCreateWithoutDetectedByInput, DelayEventUncheckedCreateWithoutDetectedByInput> | DelayEventCreateWithoutDetectedByInput[] | DelayEventUncheckedCreateWithoutDetectedByInput[]
    connectOrCreate?: DelayEventCreateOrConnectWithoutDetectedByInput | DelayEventCreateOrConnectWithoutDetectedByInput[]
    upsert?: DelayEventUpsertWithWhereUniqueWithoutDetectedByInput | DelayEventUpsertWithWhereUniqueWithoutDetectedByInput[]
    createMany?: DelayEventCreateManyDetectedByInputEnvelope
    set?: DelayEventWhereUniqueInput | DelayEventWhereUniqueInput[]
    disconnect?: DelayEventWhereUniqueInput | DelayEventWhereUniqueInput[]
    delete?: DelayEventWhereUniqueInput | DelayEventWhereUniqueInput[]
    connect?: DelayEventWhereUniqueInput | DelayEventWhereUniqueInput[]
    update?: DelayEventUpdateWithWhereUniqueWithoutDetectedByInput | DelayEventUpdateWithWhereUniqueWithoutDetectedByInput[]
    updateMany?: DelayEventUpdateManyWithWhereWithoutDetectedByInput | DelayEventUpdateManyWithWhereWithoutDetectedByInput[]
    deleteMany?: DelayEventScalarWhereInput | DelayEventScalarWhereInput[]
  }

  export type ClaimUpdateManyWithoutSubmittedByNestedInput = {
    create?: XOR<ClaimCreateWithoutSubmittedByInput, ClaimUncheckedCreateWithoutSubmittedByInput> | ClaimCreateWithoutSubmittedByInput[] | ClaimUncheckedCreateWithoutSubmittedByInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutSubmittedByInput | ClaimCreateOrConnectWithoutSubmittedByInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutSubmittedByInput | ClaimUpsertWithWhereUniqueWithoutSubmittedByInput[]
    createMany?: ClaimCreateManySubmittedByInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutSubmittedByInput | ClaimUpdateWithWhereUniqueWithoutSubmittedByInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutSubmittedByInput | ClaimUpdateManyWithWhereWithoutSubmittedByInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type EvidenceUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<EvidenceCreateWithoutUploadedByInput, EvidenceUncheckedCreateWithoutUploadedByInput> | EvidenceCreateWithoutUploadedByInput[] | EvidenceUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutUploadedByInput | EvidenceCreateOrConnectWithoutUploadedByInput[]
    upsert?: EvidenceUpsertWithWhereUniqueWithoutUploadedByInput | EvidenceUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: EvidenceCreateManyUploadedByInputEnvelope
    set?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    disconnect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    delete?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    update?: EvidenceUpdateWithWhereUniqueWithoutUploadedByInput | EvidenceUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: EvidenceUpdateManyWithWhereWithoutUploadedByInput | EvidenceUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
  }

  export type ActionItemUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<ActionItemCreateWithoutAssignedToInput, ActionItemUncheckedCreateWithoutAssignedToInput> | ActionItemCreateWithoutAssignedToInput[] | ActionItemUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ActionItemCreateOrConnectWithoutAssignedToInput | ActionItemCreateOrConnectWithoutAssignedToInput[]
    upsert?: ActionItemUpsertWithWhereUniqueWithoutAssignedToInput | ActionItemUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: ActionItemCreateManyAssignedToInputEnvelope
    set?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    disconnect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    delete?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    connect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    update?: ActionItemUpdateWithWhereUniqueWithoutAssignedToInput | ActionItemUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: ActionItemUpdateManyWithWhereWithoutAssignedToInput | ActionItemUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: ActionItemScalarWhereInput | ActionItemScalarWhereInput[]
  }

  export type FileMetadataUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<FileMetadataCreateWithoutUploadedByInput, FileMetadataUncheckedCreateWithoutUploadedByInput> | FileMetadataCreateWithoutUploadedByInput[] | FileMetadataUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutUploadedByInput | FileMetadataCreateOrConnectWithoutUploadedByInput[]
    upsert?: FileMetadataUpsertWithWhereUniqueWithoutUploadedByInput | FileMetadataUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: FileMetadataCreateManyUploadedByInputEnvelope
    set?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    disconnect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    delete?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    update?: FileMetadataUpdateWithWhereUniqueWithoutUploadedByInput | FileMetadataUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: FileMetadataUpdateManyWithWhereWithoutUploadedByInput | FileMetadataUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
  }

  export type SessionDataUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionDataCreateWithoutUserInput, SessionDataUncheckedCreateWithoutUserInput> | SessionDataCreateWithoutUserInput[] | SessionDataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionDataCreateOrConnectWithoutUserInput | SessionDataCreateOrConnectWithoutUserInput[]
    upsert?: SessionDataUpsertWithWhereUniqueWithoutUserInput | SessionDataUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionDataCreateManyUserInputEnvelope
    set?: SessionDataWhereUniqueInput | SessionDataWhereUniqueInput[]
    disconnect?: SessionDataWhereUniqueInput | SessionDataWhereUniqueInput[]
    delete?: SessionDataWhereUniqueInput | SessionDataWhereUniqueInput[]
    connect?: SessionDataWhereUniqueInput | SessionDataWhereUniqueInput[]
    update?: SessionDataUpdateWithWhereUniqueWithoutUserInput | SessionDataUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionDataUpdateManyWithWhereWithoutUserInput | SessionDataUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionDataScalarWhereInput | SessionDataScalarWhereInput[]
  }

  export type MfaSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<MfaSettingsCreateWithoutUserInput, MfaSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: MfaSettingsCreateOrConnectWithoutUserInput
    upsert?: MfaSettingsUpsertWithoutUserInput
    disconnect?: MfaSettingsWhereInput | boolean
    delete?: MfaSettingsWhereInput | boolean
    connect?: MfaSettingsWhereUniqueInput
    update?: XOR<XOR<MfaSettingsUpdateToOneWithWhereWithoutUserInput, MfaSettingsUpdateWithoutUserInput>, MfaSettingsUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectManagerInput, ProjectUncheckedCreateWithoutProjectManagerInput> | ProjectCreateWithoutProjectManagerInput[] | ProjectUncheckedCreateWithoutProjectManagerInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectManagerInput | ProjectCreateOrConnectWithoutProjectManagerInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutProjectManagerInput | ProjectUpsertWithWhereUniqueWithoutProjectManagerInput[]
    createMany?: ProjectCreateManyProjectManagerInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutProjectManagerInput | ProjectUpdateWithWhereUniqueWithoutProjectManagerInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutProjectManagerInput | ProjectUpdateManyWithWhereWithoutProjectManagerInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type DelayEventUncheckedUpdateManyWithoutDetectedByNestedInput = {
    create?: XOR<DelayEventCreateWithoutDetectedByInput, DelayEventUncheckedCreateWithoutDetectedByInput> | DelayEventCreateWithoutDetectedByInput[] | DelayEventUncheckedCreateWithoutDetectedByInput[]
    connectOrCreate?: DelayEventCreateOrConnectWithoutDetectedByInput | DelayEventCreateOrConnectWithoutDetectedByInput[]
    upsert?: DelayEventUpsertWithWhereUniqueWithoutDetectedByInput | DelayEventUpsertWithWhereUniqueWithoutDetectedByInput[]
    createMany?: DelayEventCreateManyDetectedByInputEnvelope
    set?: DelayEventWhereUniqueInput | DelayEventWhereUniqueInput[]
    disconnect?: DelayEventWhereUniqueInput | DelayEventWhereUniqueInput[]
    delete?: DelayEventWhereUniqueInput | DelayEventWhereUniqueInput[]
    connect?: DelayEventWhereUniqueInput | DelayEventWhereUniqueInput[]
    update?: DelayEventUpdateWithWhereUniqueWithoutDetectedByInput | DelayEventUpdateWithWhereUniqueWithoutDetectedByInput[]
    updateMany?: DelayEventUpdateManyWithWhereWithoutDetectedByInput | DelayEventUpdateManyWithWhereWithoutDetectedByInput[]
    deleteMany?: DelayEventScalarWhereInput | DelayEventScalarWhereInput[]
  }

  export type ClaimUncheckedUpdateManyWithoutSubmittedByNestedInput = {
    create?: XOR<ClaimCreateWithoutSubmittedByInput, ClaimUncheckedCreateWithoutSubmittedByInput> | ClaimCreateWithoutSubmittedByInput[] | ClaimUncheckedCreateWithoutSubmittedByInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutSubmittedByInput | ClaimCreateOrConnectWithoutSubmittedByInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutSubmittedByInput | ClaimUpsertWithWhereUniqueWithoutSubmittedByInput[]
    createMany?: ClaimCreateManySubmittedByInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutSubmittedByInput | ClaimUpdateWithWhereUniqueWithoutSubmittedByInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutSubmittedByInput | ClaimUpdateManyWithWhereWithoutSubmittedByInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type EvidenceUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<EvidenceCreateWithoutUploadedByInput, EvidenceUncheckedCreateWithoutUploadedByInput> | EvidenceCreateWithoutUploadedByInput[] | EvidenceUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutUploadedByInput | EvidenceCreateOrConnectWithoutUploadedByInput[]
    upsert?: EvidenceUpsertWithWhereUniqueWithoutUploadedByInput | EvidenceUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: EvidenceCreateManyUploadedByInputEnvelope
    set?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    disconnect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    delete?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    update?: EvidenceUpdateWithWhereUniqueWithoutUploadedByInput | EvidenceUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: EvidenceUpdateManyWithWhereWithoutUploadedByInput | EvidenceUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
  }

  export type ActionItemUncheckedUpdateManyWithoutAssignedToNestedInput = {
    create?: XOR<ActionItemCreateWithoutAssignedToInput, ActionItemUncheckedCreateWithoutAssignedToInput> | ActionItemCreateWithoutAssignedToInput[] | ActionItemUncheckedCreateWithoutAssignedToInput[]
    connectOrCreate?: ActionItemCreateOrConnectWithoutAssignedToInput | ActionItemCreateOrConnectWithoutAssignedToInput[]
    upsert?: ActionItemUpsertWithWhereUniqueWithoutAssignedToInput | ActionItemUpsertWithWhereUniqueWithoutAssignedToInput[]
    createMany?: ActionItemCreateManyAssignedToInputEnvelope
    set?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    disconnect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    delete?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    connect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    update?: ActionItemUpdateWithWhereUniqueWithoutAssignedToInput | ActionItemUpdateWithWhereUniqueWithoutAssignedToInput[]
    updateMany?: ActionItemUpdateManyWithWhereWithoutAssignedToInput | ActionItemUpdateManyWithWhereWithoutAssignedToInput[]
    deleteMany?: ActionItemScalarWhereInput | ActionItemScalarWhereInput[]
  }

  export type FileMetadataUncheckedUpdateManyWithoutUploadedByNestedInput = {
    create?: XOR<FileMetadataCreateWithoutUploadedByInput, FileMetadataUncheckedCreateWithoutUploadedByInput> | FileMetadataCreateWithoutUploadedByInput[] | FileMetadataUncheckedCreateWithoutUploadedByInput[]
    connectOrCreate?: FileMetadataCreateOrConnectWithoutUploadedByInput | FileMetadataCreateOrConnectWithoutUploadedByInput[]
    upsert?: FileMetadataUpsertWithWhereUniqueWithoutUploadedByInput | FileMetadataUpsertWithWhereUniqueWithoutUploadedByInput[]
    createMany?: FileMetadataCreateManyUploadedByInputEnvelope
    set?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    disconnect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    delete?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    connect?: FileMetadataWhereUniqueInput | FileMetadataWhereUniqueInput[]
    update?: FileMetadataUpdateWithWhereUniqueWithoutUploadedByInput | FileMetadataUpdateWithWhereUniqueWithoutUploadedByInput[]
    updateMany?: FileMetadataUpdateManyWithWhereWithoutUploadedByInput | FileMetadataUpdateManyWithWhereWithoutUploadedByInput[]
    deleteMany?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
  }

  export type SessionDataUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionDataCreateWithoutUserInput, SessionDataUncheckedCreateWithoutUserInput> | SessionDataCreateWithoutUserInput[] | SessionDataUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionDataCreateOrConnectWithoutUserInput | SessionDataCreateOrConnectWithoutUserInput[]
    upsert?: SessionDataUpsertWithWhereUniqueWithoutUserInput | SessionDataUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionDataCreateManyUserInputEnvelope
    set?: SessionDataWhereUniqueInput | SessionDataWhereUniqueInput[]
    disconnect?: SessionDataWhereUniqueInput | SessionDataWhereUniqueInput[]
    delete?: SessionDataWhereUniqueInput | SessionDataWhereUniqueInput[]
    connect?: SessionDataWhereUniqueInput | SessionDataWhereUniqueInput[]
    update?: SessionDataUpdateWithWhereUniqueWithoutUserInput | SessionDataUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionDataUpdateManyWithWhereWithoutUserInput | SessionDataUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionDataScalarWhereInput | SessionDataScalarWhereInput[]
  }

  export type MfaSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<MfaSettingsCreateWithoutUserInput, MfaSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: MfaSettingsCreateOrConnectWithoutUserInput
    upsert?: MfaSettingsUpsertWithoutUserInput
    disconnect?: MfaSettingsWhereInput | boolean
    delete?: MfaSettingsWhereInput | boolean
    connect?: MfaSettingsWhereUniqueInput
    update?: XOR<XOR<MfaSettingsUpdateToOneWithWhereWithoutUserInput, MfaSettingsUpdateWithoutUserInput>, MfaSettingsUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput> | PasswordResetTokenCreateWithoutUserInput[] | PasswordResetTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetTokenCreateOrConnectWithoutUserInput | PasswordResetTokenCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput | PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetTokenCreateManyUserInputEnvelope
    set?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    disconnect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    delete?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    connect?: PasswordResetTokenWhereUniqueInput | PasswordResetTokenWhereUniqueInput[]
    update?: PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput | PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetTokenUpdateManyWithWhereWithoutUserInput | PasswordResetTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutProjectsInput = {
    create?: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProjectsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAssignedProjectsInput = {
    create?: XOR<UserCreateWithoutAssignedProjectsInput, UserUncheckedCreateWithoutAssignedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type DelayEventCreateNestedManyWithoutProjectInput = {
    create?: XOR<DelayEventCreateWithoutProjectInput, DelayEventUncheckedCreateWithoutProjectInput> | DelayEventCreateWithoutProjectInput[] | DelayEventUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DelayEventCreateOrConnectWithoutProjectInput | DelayEventCreateOrConnectWithoutProjectInput[]
    createMany?: DelayEventCreateManyProjectInputEnvelope
    connect?: DelayEventWhereUniqueInput | DelayEventWhereUniqueInput[]
  }

  export type ClaimCreateNestedManyWithoutProjectInput = {
    create?: XOR<ClaimCreateWithoutProjectInput, ClaimUncheckedCreateWithoutProjectInput> | ClaimCreateWithoutProjectInput[] | ClaimUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutProjectInput | ClaimCreateOrConnectWithoutProjectInput[]
    createMany?: ClaimCreateManyProjectInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type ActionItemCreateNestedManyWithoutProjectInput = {
    create?: XOR<ActionItemCreateWithoutProjectInput, ActionItemUncheckedCreateWithoutProjectInput> | ActionItemCreateWithoutProjectInput[] | ActionItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ActionItemCreateOrConnectWithoutProjectInput | ActionItemCreateOrConnectWithoutProjectInput[]
    createMany?: ActionItemCreateManyProjectInputEnvelope
    connect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
  }

  export type ScheduleCreateNestedManyWithoutProjectInput = {
    create?: XOR<ScheduleCreateWithoutProjectInput, ScheduleUncheckedCreateWithoutProjectInput> | ScheduleCreateWithoutProjectInput[] | ScheduleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutProjectInput | ScheduleCreateOrConnectWithoutProjectInput[]
    createMany?: ScheduleCreateManyProjectInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type DelayEventUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<DelayEventCreateWithoutProjectInput, DelayEventUncheckedCreateWithoutProjectInput> | DelayEventCreateWithoutProjectInput[] | DelayEventUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DelayEventCreateOrConnectWithoutProjectInput | DelayEventCreateOrConnectWithoutProjectInput[]
    createMany?: DelayEventCreateManyProjectInputEnvelope
    connect?: DelayEventWhereUniqueInput | DelayEventWhereUniqueInput[]
  }

  export type ClaimUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ClaimCreateWithoutProjectInput, ClaimUncheckedCreateWithoutProjectInput> | ClaimCreateWithoutProjectInput[] | ClaimUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutProjectInput | ClaimCreateOrConnectWithoutProjectInput[]
    createMany?: ClaimCreateManyProjectInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type ActionItemUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ActionItemCreateWithoutProjectInput, ActionItemUncheckedCreateWithoutProjectInput> | ActionItemCreateWithoutProjectInput[] | ActionItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ActionItemCreateOrConnectWithoutProjectInput | ActionItemCreateOrConnectWithoutProjectInput[]
    createMany?: ActionItemCreateManyProjectInputEnvelope
    connect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ScheduleCreateWithoutProjectInput, ScheduleUncheckedCreateWithoutProjectInput> | ScheduleCreateWithoutProjectInput[] | ScheduleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutProjectInput | ScheduleCreateOrConnectWithoutProjectInput[]
    createMany?: ScheduleCreateManyProjectInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumProjectStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectStatus
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableEnumContractTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContractType | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrganizationUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutProjectsInput
    upsert?: OrganizationUpsertWithoutProjectsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutProjectsInput, OrganizationUpdateWithoutProjectsInput>, OrganizationUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateOneWithoutAssignedProjectsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedProjectsInput, UserUncheckedCreateWithoutAssignedProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedProjectsInput
    upsert?: UserUpsertWithoutAssignedProjectsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedProjectsInput, UserUpdateWithoutAssignedProjectsInput>, UserUncheckedUpdateWithoutAssignedProjectsInput>
  }

  export type DelayEventUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DelayEventCreateWithoutProjectInput, DelayEventUncheckedCreateWithoutProjectInput> | DelayEventCreateWithoutProjectInput[] | DelayEventUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DelayEventCreateOrConnectWithoutProjectInput | DelayEventCreateOrConnectWithoutProjectInput[]
    upsert?: DelayEventUpsertWithWhereUniqueWithoutProjectInput | DelayEventUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DelayEventCreateManyProjectInputEnvelope
    set?: DelayEventWhereUniqueInput | DelayEventWhereUniqueInput[]
    disconnect?: DelayEventWhereUniqueInput | DelayEventWhereUniqueInput[]
    delete?: DelayEventWhereUniqueInput | DelayEventWhereUniqueInput[]
    connect?: DelayEventWhereUniqueInput | DelayEventWhereUniqueInput[]
    update?: DelayEventUpdateWithWhereUniqueWithoutProjectInput | DelayEventUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DelayEventUpdateManyWithWhereWithoutProjectInput | DelayEventUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DelayEventScalarWhereInput | DelayEventScalarWhereInput[]
  }

  export type ClaimUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ClaimCreateWithoutProjectInput, ClaimUncheckedCreateWithoutProjectInput> | ClaimCreateWithoutProjectInput[] | ClaimUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutProjectInput | ClaimCreateOrConnectWithoutProjectInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutProjectInput | ClaimUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ClaimCreateManyProjectInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutProjectInput | ClaimUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutProjectInput | ClaimUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type ActionItemUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ActionItemCreateWithoutProjectInput, ActionItemUncheckedCreateWithoutProjectInput> | ActionItemCreateWithoutProjectInput[] | ActionItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ActionItemCreateOrConnectWithoutProjectInput | ActionItemCreateOrConnectWithoutProjectInput[]
    upsert?: ActionItemUpsertWithWhereUniqueWithoutProjectInput | ActionItemUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ActionItemCreateManyProjectInputEnvelope
    set?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    disconnect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    delete?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    connect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    update?: ActionItemUpdateWithWhereUniqueWithoutProjectInput | ActionItemUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ActionItemUpdateManyWithWhereWithoutProjectInput | ActionItemUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ActionItemScalarWhereInput | ActionItemScalarWhereInput[]
  }

  export type ScheduleUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ScheduleCreateWithoutProjectInput, ScheduleUncheckedCreateWithoutProjectInput> | ScheduleCreateWithoutProjectInput[] | ScheduleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutProjectInput | ScheduleCreateOrConnectWithoutProjectInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutProjectInput | ScheduleUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ScheduleCreateManyProjectInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutProjectInput | ScheduleUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutProjectInput | ScheduleUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type DelayEventUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<DelayEventCreateWithoutProjectInput, DelayEventUncheckedCreateWithoutProjectInput> | DelayEventCreateWithoutProjectInput[] | DelayEventUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: DelayEventCreateOrConnectWithoutProjectInput | DelayEventCreateOrConnectWithoutProjectInput[]
    upsert?: DelayEventUpsertWithWhereUniqueWithoutProjectInput | DelayEventUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: DelayEventCreateManyProjectInputEnvelope
    set?: DelayEventWhereUniqueInput | DelayEventWhereUniqueInput[]
    disconnect?: DelayEventWhereUniqueInput | DelayEventWhereUniqueInput[]
    delete?: DelayEventWhereUniqueInput | DelayEventWhereUniqueInput[]
    connect?: DelayEventWhereUniqueInput | DelayEventWhereUniqueInput[]
    update?: DelayEventUpdateWithWhereUniqueWithoutProjectInput | DelayEventUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: DelayEventUpdateManyWithWhereWithoutProjectInput | DelayEventUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: DelayEventScalarWhereInput | DelayEventScalarWhereInput[]
  }

  export type ClaimUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ClaimCreateWithoutProjectInput, ClaimUncheckedCreateWithoutProjectInput> | ClaimCreateWithoutProjectInput[] | ClaimUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutProjectInput | ClaimCreateOrConnectWithoutProjectInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutProjectInput | ClaimUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ClaimCreateManyProjectInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutProjectInput | ClaimUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutProjectInput | ClaimUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type ActionItemUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ActionItemCreateWithoutProjectInput, ActionItemUncheckedCreateWithoutProjectInput> | ActionItemCreateWithoutProjectInput[] | ActionItemUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ActionItemCreateOrConnectWithoutProjectInput | ActionItemCreateOrConnectWithoutProjectInput[]
    upsert?: ActionItemUpsertWithWhereUniqueWithoutProjectInput | ActionItemUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ActionItemCreateManyProjectInputEnvelope
    set?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    disconnect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    delete?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    connect?: ActionItemWhereUniqueInput | ActionItemWhereUniqueInput[]
    update?: ActionItemUpdateWithWhereUniqueWithoutProjectInput | ActionItemUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ActionItemUpdateManyWithWhereWithoutProjectInput | ActionItemUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ActionItemScalarWhereInput | ActionItemScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ScheduleCreateWithoutProjectInput, ScheduleUncheckedCreateWithoutProjectInput> | ScheduleCreateWithoutProjectInput[] | ScheduleUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutProjectInput | ScheduleCreateOrConnectWithoutProjectInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutProjectInput | ScheduleUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ScheduleCreateManyProjectInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutProjectInput | ScheduleUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutProjectInput | ScheduleUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutDelayEventsInput = {
    create?: XOR<ProjectCreateWithoutDelayEventsInput, ProjectUncheckedCreateWithoutDelayEventsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDelayEventsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDelayEventsInput = {
    create?: XOR<UserCreateWithoutDelayEventsInput, UserUncheckedCreateWithoutDelayEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDelayEventsInput
    connect?: UserWhereUniqueInput
  }

  export type ClaimCreateNestedManyWithoutDelayEventInput = {
    create?: XOR<ClaimCreateWithoutDelayEventInput, ClaimUncheckedCreateWithoutDelayEventInput> | ClaimCreateWithoutDelayEventInput[] | ClaimUncheckedCreateWithoutDelayEventInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutDelayEventInput | ClaimCreateOrConnectWithoutDelayEventInput[]
    createMany?: ClaimCreateManyDelayEventInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type EvidenceCreateNestedManyWithoutDelayEventInput = {
    create?: XOR<EvidenceCreateWithoutDelayEventInput, EvidenceUncheckedCreateWithoutDelayEventInput> | EvidenceCreateWithoutDelayEventInput[] | EvidenceUncheckedCreateWithoutDelayEventInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutDelayEventInput | EvidenceCreateOrConnectWithoutDelayEventInput[]
    createMany?: EvidenceCreateManyDelayEventInputEnvelope
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
  }

  export type ClaimUncheckedCreateNestedManyWithoutDelayEventInput = {
    create?: XOR<ClaimCreateWithoutDelayEventInput, ClaimUncheckedCreateWithoutDelayEventInput> | ClaimCreateWithoutDelayEventInput[] | ClaimUncheckedCreateWithoutDelayEventInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutDelayEventInput | ClaimCreateOrConnectWithoutDelayEventInput[]
    createMany?: ClaimCreateManyDelayEventInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type EvidenceUncheckedCreateNestedManyWithoutDelayEventInput = {
    create?: XOR<EvidenceCreateWithoutDelayEventInput, EvidenceUncheckedCreateWithoutDelayEventInput> | EvidenceCreateWithoutDelayEventInput[] | EvidenceUncheckedCreateWithoutDelayEventInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutDelayEventInput | EvidenceCreateOrConnectWithoutDelayEventInput[]
    createMany?: EvidenceCreateManyDelayEventInputEnvelope
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumDelayTypeFieldUpdateOperationsInput = {
    set?: $Enums.DelayType
  }

  export type EnumDelayStatusFieldUpdateOperationsInput = {
    set?: $Enums.DelayStatus
  }

  export type ProjectUpdateOneRequiredWithoutDelayEventsNestedInput = {
    create?: XOR<ProjectCreateWithoutDelayEventsInput, ProjectUncheckedCreateWithoutDelayEventsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutDelayEventsInput
    upsert?: ProjectUpsertWithoutDelayEventsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutDelayEventsInput, ProjectUpdateWithoutDelayEventsInput>, ProjectUncheckedUpdateWithoutDelayEventsInput>
  }

  export type UserUpdateOneRequiredWithoutDelayEventsNestedInput = {
    create?: XOR<UserCreateWithoutDelayEventsInput, UserUncheckedCreateWithoutDelayEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDelayEventsInput
    upsert?: UserUpsertWithoutDelayEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDelayEventsInput, UserUpdateWithoutDelayEventsInput>, UserUncheckedUpdateWithoutDelayEventsInput>
  }

  export type ClaimUpdateManyWithoutDelayEventNestedInput = {
    create?: XOR<ClaimCreateWithoutDelayEventInput, ClaimUncheckedCreateWithoutDelayEventInput> | ClaimCreateWithoutDelayEventInput[] | ClaimUncheckedCreateWithoutDelayEventInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutDelayEventInput | ClaimCreateOrConnectWithoutDelayEventInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutDelayEventInput | ClaimUpsertWithWhereUniqueWithoutDelayEventInput[]
    createMany?: ClaimCreateManyDelayEventInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutDelayEventInput | ClaimUpdateWithWhereUniqueWithoutDelayEventInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutDelayEventInput | ClaimUpdateManyWithWhereWithoutDelayEventInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type EvidenceUpdateManyWithoutDelayEventNestedInput = {
    create?: XOR<EvidenceCreateWithoutDelayEventInput, EvidenceUncheckedCreateWithoutDelayEventInput> | EvidenceCreateWithoutDelayEventInput[] | EvidenceUncheckedCreateWithoutDelayEventInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutDelayEventInput | EvidenceCreateOrConnectWithoutDelayEventInput[]
    upsert?: EvidenceUpsertWithWhereUniqueWithoutDelayEventInput | EvidenceUpsertWithWhereUniqueWithoutDelayEventInput[]
    createMany?: EvidenceCreateManyDelayEventInputEnvelope
    set?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    disconnect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    delete?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    update?: EvidenceUpdateWithWhereUniqueWithoutDelayEventInput | EvidenceUpdateWithWhereUniqueWithoutDelayEventInput[]
    updateMany?: EvidenceUpdateManyWithWhereWithoutDelayEventInput | EvidenceUpdateManyWithWhereWithoutDelayEventInput[]
    deleteMany?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
  }

  export type ClaimUncheckedUpdateManyWithoutDelayEventNestedInput = {
    create?: XOR<ClaimCreateWithoutDelayEventInput, ClaimUncheckedCreateWithoutDelayEventInput> | ClaimCreateWithoutDelayEventInput[] | ClaimUncheckedCreateWithoutDelayEventInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutDelayEventInput | ClaimCreateOrConnectWithoutDelayEventInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutDelayEventInput | ClaimUpsertWithWhereUniqueWithoutDelayEventInput[]
    createMany?: ClaimCreateManyDelayEventInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutDelayEventInput | ClaimUpdateWithWhereUniqueWithoutDelayEventInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutDelayEventInput | ClaimUpdateManyWithWhereWithoutDelayEventInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type EvidenceUncheckedUpdateManyWithoutDelayEventNestedInput = {
    create?: XOR<EvidenceCreateWithoutDelayEventInput, EvidenceUncheckedCreateWithoutDelayEventInput> | EvidenceCreateWithoutDelayEventInput[] | EvidenceUncheckedCreateWithoutDelayEventInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutDelayEventInput | EvidenceCreateOrConnectWithoutDelayEventInput[]
    upsert?: EvidenceUpsertWithWhereUniqueWithoutDelayEventInput | EvidenceUpsertWithWhereUniqueWithoutDelayEventInput[]
    createMany?: EvidenceCreateManyDelayEventInputEnvelope
    set?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    disconnect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    delete?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    update?: EvidenceUpdateWithWhereUniqueWithoutDelayEventInput | EvidenceUpdateWithWhereUniqueWithoutDelayEventInput[]
    updateMany?: EvidenceUpdateManyWithWhereWithoutDelayEventInput | EvidenceUpdateManyWithWhereWithoutDelayEventInput[]
    deleteMany?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutClaimsInput = {
    create?: XOR<ProjectCreateWithoutClaimsInput, ProjectUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutClaimsInput
    connect?: ProjectWhereUniqueInput
  }

  export type DelayEventCreateNestedOneWithoutClaimsInput = {
    create?: XOR<DelayEventCreateWithoutClaimsInput, DelayEventUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: DelayEventCreateOrConnectWithoutClaimsInput
    connect?: DelayEventWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutClaimsInput = {
    create?: XOR<UserCreateWithoutClaimsInput, UserUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClaimsInput
    connect?: UserWhereUniqueInput
  }

  export type EvidenceCreateNestedManyWithoutClaimInput = {
    create?: XOR<EvidenceCreateWithoutClaimInput, EvidenceUncheckedCreateWithoutClaimInput> | EvidenceCreateWithoutClaimInput[] | EvidenceUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutClaimInput | EvidenceCreateOrConnectWithoutClaimInput[]
    createMany?: EvidenceCreateManyClaimInputEnvelope
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
  }

  export type EvidenceUncheckedCreateNestedManyWithoutClaimInput = {
    create?: XOR<EvidenceCreateWithoutClaimInput, EvidenceUncheckedCreateWithoutClaimInput> | EvidenceCreateWithoutClaimInput[] | EvidenceUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutClaimInput | EvidenceCreateOrConnectWithoutClaimInput[]
    createMany?: EvidenceCreateManyClaimInputEnvelope
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
  }

  export type EnumClaimStatusFieldUpdateOperationsInput = {
    set?: $Enums.ClaimStatus
  }

  export type ProjectUpdateOneRequiredWithoutClaimsNestedInput = {
    create?: XOR<ProjectCreateWithoutClaimsInput, ProjectUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutClaimsInput
    upsert?: ProjectUpsertWithoutClaimsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutClaimsInput, ProjectUpdateWithoutClaimsInput>, ProjectUncheckedUpdateWithoutClaimsInput>
  }

  export type DelayEventUpdateOneWithoutClaimsNestedInput = {
    create?: XOR<DelayEventCreateWithoutClaimsInput, DelayEventUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: DelayEventCreateOrConnectWithoutClaimsInput
    upsert?: DelayEventUpsertWithoutClaimsInput
    disconnect?: DelayEventWhereInput | boolean
    delete?: DelayEventWhereInput | boolean
    connect?: DelayEventWhereUniqueInput
    update?: XOR<XOR<DelayEventUpdateToOneWithWhereWithoutClaimsInput, DelayEventUpdateWithoutClaimsInput>, DelayEventUncheckedUpdateWithoutClaimsInput>
  }

  export type UserUpdateOneWithoutClaimsNestedInput = {
    create?: XOR<UserCreateWithoutClaimsInput, UserUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClaimsInput
    upsert?: UserUpsertWithoutClaimsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClaimsInput, UserUpdateWithoutClaimsInput>, UserUncheckedUpdateWithoutClaimsInput>
  }

  export type EvidenceUpdateManyWithoutClaimNestedInput = {
    create?: XOR<EvidenceCreateWithoutClaimInput, EvidenceUncheckedCreateWithoutClaimInput> | EvidenceCreateWithoutClaimInput[] | EvidenceUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutClaimInput | EvidenceCreateOrConnectWithoutClaimInput[]
    upsert?: EvidenceUpsertWithWhereUniqueWithoutClaimInput | EvidenceUpsertWithWhereUniqueWithoutClaimInput[]
    createMany?: EvidenceCreateManyClaimInputEnvelope
    set?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    disconnect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    delete?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    update?: EvidenceUpdateWithWhereUniqueWithoutClaimInput | EvidenceUpdateWithWhereUniqueWithoutClaimInput[]
    updateMany?: EvidenceUpdateManyWithWhereWithoutClaimInput | EvidenceUpdateManyWithWhereWithoutClaimInput[]
    deleteMany?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
  }

  export type EvidenceUncheckedUpdateManyWithoutClaimNestedInput = {
    create?: XOR<EvidenceCreateWithoutClaimInput, EvidenceUncheckedCreateWithoutClaimInput> | EvidenceCreateWithoutClaimInput[] | EvidenceUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutClaimInput | EvidenceCreateOrConnectWithoutClaimInput[]
    upsert?: EvidenceUpsertWithWhereUniqueWithoutClaimInput | EvidenceUpsertWithWhereUniqueWithoutClaimInput[]
    createMany?: EvidenceCreateManyClaimInputEnvelope
    set?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    disconnect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    delete?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    update?: EvidenceUpdateWithWhereUniqueWithoutClaimInput | EvidenceUpdateWithWhereUniqueWithoutClaimInput[]
    updateMany?: EvidenceUpdateManyWithWhereWithoutClaimInput | EvidenceUpdateManyWithWhereWithoutClaimInput[]
    deleteMany?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
  }

  export type DelayEventCreateNestedOneWithoutEvidenceInput = {
    create?: XOR<DelayEventCreateWithoutEvidenceInput, DelayEventUncheckedCreateWithoutEvidenceInput>
    connectOrCreate?: DelayEventCreateOrConnectWithoutEvidenceInput
    connect?: DelayEventWhereUniqueInput
  }

  export type ClaimCreateNestedOneWithoutEvidenceInput = {
    create?: XOR<ClaimCreateWithoutEvidenceInput, ClaimUncheckedCreateWithoutEvidenceInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutEvidenceInput
    connect?: ClaimWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEvidenceInput = {
    create?: XOR<UserCreateWithoutEvidenceInput, UserUncheckedCreateWithoutEvidenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutEvidenceInput
    connect?: UserWhereUniqueInput
  }

  export type FileMetadataCreateNestedOneWithoutEvidenceInput = {
    create?: XOR<FileMetadataCreateWithoutEvidenceInput, FileMetadataUncheckedCreateWithoutEvidenceInput>
    connectOrCreate?: FileMetadataCreateOrConnectWithoutEvidenceInput
    connect?: FileMetadataWhereUniqueInput
  }

  export type EnumEvidenceTypeFieldUpdateOperationsInput = {
    set?: $Enums.EvidenceType
  }

  export type DelayEventUpdateOneWithoutEvidenceNestedInput = {
    create?: XOR<DelayEventCreateWithoutEvidenceInput, DelayEventUncheckedCreateWithoutEvidenceInput>
    connectOrCreate?: DelayEventCreateOrConnectWithoutEvidenceInput
    upsert?: DelayEventUpsertWithoutEvidenceInput
    disconnect?: DelayEventWhereInput | boolean
    delete?: DelayEventWhereInput | boolean
    connect?: DelayEventWhereUniqueInput
    update?: XOR<XOR<DelayEventUpdateToOneWithWhereWithoutEvidenceInput, DelayEventUpdateWithoutEvidenceInput>, DelayEventUncheckedUpdateWithoutEvidenceInput>
  }

  export type ClaimUpdateOneWithoutEvidenceNestedInput = {
    create?: XOR<ClaimCreateWithoutEvidenceInput, ClaimUncheckedCreateWithoutEvidenceInput>
    connectOrCreate?: ClaimCreateOrConnectWithoutEvidenceInput
    upsert?: ClaimUpsertWithoutEvidenceInput
    disconnect?: ClaimWhereInput | boolean
    delete?: ClaimWhereInput | boolean
    connect?: ClaimWhereUniqueInput
    update?: XOR<XOR<ClaimUpdateToOneWithWhereWithoutEvidenceInput, ClaimUpdateWithoutEvidenceInput>, ClaimUncheckedUpdateWithoutEvidenceInput>
  }

  export type UserUpdateOneRequiredWithoutEvidenceNestedInput = {
    create?: XOR<UserCreateWithoutEvidenceInput, UserUncheckedCreateWithoutEvidenceInput>
    connectOrCreate?: UserCreateOrConnectWithoutEvidenceInput
    upsert?: UserUpsertWithoutEvidenceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEvidenceInput, UserUpdateWithoutEvidenceInput>, UserUncheckedUpdateWithoutEvidenceInput>
  }

  export type FileMetadataUpdateOneWithoutEvidenceNestedInput = {
    create?: XOR<FileMetadataCreateWithoutEvidenceInput, FileMetadataUncheckedCreateWithoutEvidenceInput>
    connectOrCreate?: FileMetadataCreateOrConnectWithoutEvidenceInput
    upsert?: FileMetadataUpsertWithoutEvidenceInput
    disconnect?: FileMetadataWhereInput | boolean
    delete?: FileMetadataWhereInput | boolean
    connect?: FileMetadataWhereUniqueInput
    update?: XOR<XOR<FileMetadataUpdateToOneWithWhereWithoutEvidenceInput, FileMetadataUpdateWithoutEvidenceInput>, FileMetadataUncheckedUpdateWithoutEvidenceInput>
  }

  export type ProjectCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<ProjectCreateWithoutSchedulesInput, ProjectUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSchedulesInput
    connect?: ProjectWhereUniqueInput
  }

  export type FileMetadataCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<FileMetadataCreateWithoutSchedulesInput, FileMetadataUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: FileMetadataCreateOrConnectWithoutSchedulesInput
    connect?: FileMetadataWhereUniqueInput
  }

  export type EnumScheduleFormatFieldUpdateOperationsInput = {
    set?: $Enums.ScheduleFormat
  }

  export type ProjectUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<ProjectCreateWithoutSchedulesInput, ProjectUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSchedulesInput
    upsert?: ProjectUpsertWithoutSchedulesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSchedulesInput, ProjectUpdateWithoutSchedulesInput>, ProjectUncheckedUpdateWithoutSchedulesInput>
  }

  export type FileMetadataUpdateOneWithoutSchedulesNestedInput = {
    create?: XOR<FileMetadataCreateWithoutSchedulesInput, FileMetadataUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: FileMetadataCreateOrConnectWithoutSchedulesInput
    upsert?: FileMetadataUpsertWithoutSchedulesInput
    disconnect?: FileMetadataWhereInput | boolean
    delete?: FileMetadataWhereInput | boolean
    connect?: FileMetadataWhereUniqueInput
    update?: XOR<XOR<FileMetadataUpdateToOneWithWhereWithoutSchedulesInput, FileMetadataUpdateWithoutSchedulesInput>, FileMetadataUncheckedUpdateWithoutSchedulesInput>
  }

  export type ProjectCreateNestedOneWithoutActionItemsInput = {
    create?: XOR<ProjectCreateWithoutActionItemsInput, ProjectUncheckedCreateWithoutActionItemsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutActionItemsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutActionItemsInput = {
    create?: XOR<UserCreateWithoutActionItemsInput, UserUncheckedCreateWithoutActionItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActionItemsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type EnumActionItemStatusFieldUpdateOperationsInput = {
    set?: $Enums.ActionItemStatus
  }

  export type ProjectUpdateOneRequiredWithoutActionItemsNestedInput = {
    create?: XOR<ProjectCreateWithoutActionItemsInput, ProjectUncheckedCreateWithoutActionItemsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutActionItemsInput
    upsert?: ProjectUpsertWithoutActionItemsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutActionItemsInput, ProjectUpdateWithoutActionItemsInput>, ProjectUncheckedUpdateWithoutActionItemsInput>
  }

  export type UserUpdateOneRequiredWithoutActionItemsNestedInput = {
    create?: XOR<UserCreateWithoutActionItemsInput, UserUncheckedCreateWithoutActionItemsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActionItemsInput
    upsert?: UserUpsertWithoutActionItemsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActionItemsInput, UserUpdateWithoutActionItemsInput>, UserUncheckedUpdateWithoutActionItemsInput>
  }

  export type FileMetadataCreatetagsInput = {
    set: string[]
  }

  export type OrganizationCreateNestedOneWithoutFilesInput = {
    create?: XOR<OrganizationCreateWithoutFilesInput, OrganizationUncheckedCreateWithoutFilesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutFilesInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFilesUploadedInput = {
    create?: XOR<UserCreateWithoutFilesUploadedInput, UserUncheckedCreateWithoutFilesUploadedInput>
    connectOrCreate?: UserCreateOrConnectWithoutFilesUploadedInput
    connect?: UserWhereUniqueInput
  }

  export type EvidenceCreateNestedManyWithoutFileInput = {
    create?: XOR<EvidenceCreateWithoutFileInput, EvidenceUncheckedCreateWithoutFileInput> | EvidenceCreateWithoutFileInput[] | EvidenceUncheckedCreateWithoutFileInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutFileInput | EvidenceCreateOrConnectWithoutFileInput[]
    createMany?: EvidenceCreateManyFileInputEnvelope
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
  }

  export type ScheduleCreateNestedManyWithoutFileInput = {
    create?: XOR<ScheduleCreateWithoutFileInput, ScheduleUncheckedCreateWithoutFileInput> | ScheduleCreateWithoutFileInput[] | ScheduleUncheckedCreateWithoutFileInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutFileInput | ScheduleCreateOrConnectWithoutFileInput[]
    createMany?: ScheduleCreateManyFileInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type EvidenceUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<EvidenceCreateWithoutFileInput, EvidenceUncheckedCreateWithoutFileInput> | EvidenceCreateWithoutFileInput[] | EvidenceUncheckedCreateWithoutFileInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutFileInput | EvidenceCreateOrConnectWithoutFileInput[]
    createMany?: EvidenceCreateManyFileInputEnvelope
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<ScheduleCreateWithoutFileInput, ScheduleUncheckedCreateWithoutFileInput> | ScheduleCreateWithoutFileInput[] | ScheduleUncheckedCreateWithoutFileInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutFileInput | ScheduleCreateOrConnectWithoutFileInput[]
    createMany?: ScheduleCreateManyFileInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type FileMetadataUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OrganizationUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<OrganizationCreateWithoutFilesInput, OrganizationUncheckedCreateWithoutFilesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutFilesInput
    upsert?: OrganizationUpsertWithoutFilesInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutFilesInput, OrganizationUpdateWithoutFilesInput>, OrganizationUncheckedUpdateWithoutFilesInput>
  }

  export type UserUpdateOneRequiredWithoutFilesUploadedNestedInput = {
    create?: XOR<UserCreateWithoutFilesUploadedInput, UserUncheckedCreateWithoutFilesUploadedInput>
    connectOrCreate?: UserCreateOrConnectWithoutFilesUploadedInput
    upsert?: UserUpsertWithoutFilesUploadedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFilesUploadedInput, UserUpdateWithoutFilesUploadedInput>, UserUncheckedUpdateWithoutFilesUploadedInput>
  }

  export type EvidenceUpdateManyWithoutFileNestedInput = {
    create?: XOR<EvidenceCreateWithoutFileInput, EvidenceUncheckedCreateWithoutFileInput> | EvidenceCreateWithoutFileInput[] | EvidenceUncheckedCreateWithoutFileInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutFileInput | EvidenceCreateOrConnectWithoutFileInput[]
    upsert?: EvidenceUpsertWithWhereUniqueWithoutFileInput | EvidenceUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: EvidenceCreateManyFileInputEnvelope
    set?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    disconnect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    delete?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    update?: EvidenceUpdateWithWhereUniqueWithoutFileInput | EvidenceUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: EvidenceUpdateManyWithWhereWithoutFileInput | EvidenceUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
  }

  export type ScheduleUpdateManyWithoutFileNestedInput = {
    create?: XOR<ScheduleCreateWithoutFileInput, ScheduleUncheckedCreateWithoutFileInput> | ScheduleCreateWithoutFileInput[] | ScheduleUncheckedCreateWithoutFileInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutFileInput | ScheduleCreateOrConnectWithoutFileInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutFileInput | ScheduleUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: ScheduleCreateManyFileInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutFileInput | ScheduleUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutFileInput | ScheduleUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type EvidenceUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<EvidenceCreateWithoutFileInput, EvidenceUncheckedCreateWithoutFileInput> | EvidenceCreateWithoutFileInput[] | EvidenceUncheckedCreateWithoutFileInput[]
    connectOrCreate?: EvidenceCreateOrConnectWithoutFileInput | EvidenceCreateOrConnectWithoutFileInput[]
    upsert?: EvidenceUpsertWithWhereUniqueWithoutFileInput | EvidenceUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: EvidenceCreateManyFileInputEnvelope
    set?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    disconnect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    delete?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    connect?: EvidenceWhereUniqueInput | EvidenceWhereUniqueInput[]
    update?: EvidenceUpdateWithWhereUniqueWithoutFileInput | EvidenceUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: EvidenceUpdateManyWithWhereWithoutFileInput | EvidenceUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<ScheduleCreateWithoutFileInput, ScheduleUncheckedCreateWithoutFileInput> | ScheduleCreateWithoutFileInput[] | ScheduleUncheckedCreateWithoutFileInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutFileInput | ScheduleCreateOrConnectWithoutFileInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutFileInput | ScheduleUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: ScheduleCreateManyFileInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutFileInput | ScheduleUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutFileInput | ScheduleUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutQuotasInput = {
    create?: XOR<OrganizationCreateWithoutQuotasInput, OrganizationUncheckedCreateWithoutQuotasInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutQuotasInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutQuotasNestedInput = {
    create?: XOR<OrganizationCreateWithoutQuotasInput, OrganizationUncheckedCreateWithoutQuotasInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutQuotasInput
    upsert?: OrganizationUpsertWithoutQuotasInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutQuotasInput, OrganizationUpdateWithoutQuotasInput>, OrganizationUncheckedUpdateWithoutQuotasInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type MfaSettingsCreatebackupCodesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutMfaSettingsInput = {
    create?: XOR<UserCreateWithoutMfaSettingsInput, UserUncheckedCreateWithoutMfaSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMfaSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMfaMethodFieldUpdateOperationsInput = {
    set?: $Enums.MfaMethod
  }

  export type MfaSettingsUpdatebackupCodesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutMfaSettingsNestedInput = {
    create?: XOR<UserCreateWithoutMfaSettingsInput, UserUncheckedCreateWithoutMfaSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMfaSettingsInput
    upsert?: UserUpsertWithoutMfaSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMfaSettingsInput, UserUpdateWithoutMfaSettingsInput>, UserUncheckedUpdateWithoutMfaSettingsInput>
  }

  export type UserCreateNestedOneWithoutPasswordResetsInput = {
    create?: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPasswordResetsNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetsInput
    upsert?: UserUpsertWithoutPasswordResetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetsInput, UserUpdateWithoutPasswordResetsInput>, UserUncheckedUpdateWithoutPasswordResetsInput>
  }

  export type OrganizationCreateNestedOneWithoutEventsInput = {
    create?: XOR<OrganizationCreateWithoutEventsInput, OrganizationUncheckedCreateWithoutEventsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutEventsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<OrganizationCreateWithoutEventsInput, OrganizationUncheckedCreateWithoutEventsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutEventsInput
    upsert?: OrganizationUpsertWithoutEventsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutEventsInput, OrganizationUpdateWithoutEventsInput>, OrganizationUncheckedUpdateWithoutEventsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<OrganizationCreateWithoutAuditLogsInput, OrganizationUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAuditLogsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type OrganizationUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<OrganizationCreateWithoutAuditLogsInput, OrganizationUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAuditLogsInput
    upsert?: OrganizationUpsertWithoutAuditLogsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutAuditLogsInput, OrganizationUpdateWithoutAuditLogsInput>, OrganizationUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumContractTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContractTypeNullableFilter<$PrismaModel> | $Enums.ContractType | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumContractTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContractType | EnumContractTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContractType[] | ListEnumContractTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContractTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ContractType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumContractTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumContractTypeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumDelayTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DelayType | EnumDelayTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DelayType[] | ListEnumDelayTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DelayType[] | ListEnumDelayTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDelayTypeFilter<$PrismaModel> | $Enums.DelayType
  }

  export type NestedEnumDelayStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DelayStatus | EnumDelayStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DelayStatus[] | ListEnumDelayStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DelayStatus[] | ListEnumDelayStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDelayStatusFilter<$PrismaModel> | $Enums.DelayStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumDelayTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DelayType | EnumDelayTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DelayType[] | ListEnumDelayTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DelayType[] | ListEnumDelayTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDelayTypeWithAggregatesFilter<$PrismaModel> | $Enums.DelayType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDelayTypeFilter<$PrismaModel>
    _max?: NestedEnumDelayTypeFilter<$PrismaModel>
  }

  export type NestedEnumDelayStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DelayStatus | EnumDelayStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DelayStatus[] | ListEnumDelayStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DelayStatus[] | ListEnumDelayStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDelayStatusWithAggregatesFilter<$PrismaModel> | $Enums.DelayStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDelayStatusFilter<$PrismaModel>
    _max?: NestedEnumDelayStatusFilter<$PrismaModel>
  }

  export type NestedEnumClaimStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusFilter<$PrismaModel> | $Enums.ClaimStatus
  }

  export type NestedEnumClaimStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClaimStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClaimStatusFilter<$PrismaModel>
    _max?: NestedEnumClaimStatusFilter<$PrismaModel>
  }

  export type NestedEnumEvidenceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EvidenceType | EnumEvidenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EvidenceType[] | ListEnumEvidenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvidenceType[] | ListEnumEvidenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEvidenceTypeFilter<$PrismaModel> | $Enums.EvidenceType
  }

  export type NestedEnumEvidenceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EvidenceType | EnumEvidenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EvidenceType[] | ListEnumEvidenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EvidenceType[] | ListEnumEvidenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEvidenceTypeWithAggregatesFilter<$PrismaModel> | $Enums.EvidenceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEvidenceTypeFilter<$PrismaModel>
    _max?: NestedEnumEvidenceTypeFilter<$PrismaModel>
  }

  export type NestedEnumScheduleFormatFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleFormat | EnumScheduleFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleFormat[] | ListEnumScheduleFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleFormat[] | ListEnumScheduleFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleFormatFilter<$PrismaModel> | $Enums.ScheduleFormat
  }

  export type NestedEnumScheduleFormatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ScheduleFormat | EnumScheduleFormatFieldRefInput<$PrismaModel>
    in?: $Enums.ScheduleFormat[] | ListEnumScheduleFormatFieldRefInput<$PrismaModel>
    notIn?: $Enums.ScheduleFormat[] | ListEnumScheduleFormatFieldRefInput<$PrismaModel>
    not?: NestedEnumScheduleFormatWithAggregatesFilter<$PrismaModel> | $Enums.ScheduleFormat
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumScheduleFormatFilter<$PrismaModel>
    _max?: NestedEnumScheduleFormatFilter<$PrismaModel>
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumActionItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionItemStatus | EnumActionItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActionItemStatus[] | ListEnumActionItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionItemStatus[] | ListEnumActionItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActionItemStatusFilter<$PrismaModel> | $Enums.ActionItemStatus
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumActionItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionItemStatus | EnumActionItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ActionItemStatus[] | ListEnumActionItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionItemStatus[] | ListEnumActionItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumActionItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.ActionItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionItemStatusFilter<$PrismaModel>
    _max?: NestedEnumActionItemStatusFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumMfaMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.MfaMethod | EnumMfaMethodFieldRefInput<$PrismaModel>
    in?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumMfaMethodFilter<$PrismaModel> | $Enums.MfaMethod
  }

  export type NestedEnumMfaMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MfaMethod | EnumMfaMethodFieldRefInput<$PrismaModel>
    in?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.MfaMethod[] | ListEnumMfaMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumMfaMethodWithAggregatesFilter<$PrismaModel> | $Enums.MfaMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMfaMethodFilter<$PrismaModel>
    _max?: NestedEnumMfaMethodFilter<$PrismaModel>
  }

  export type UserCreateWithoutOrganizationInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    delayEvents?: DelayEventCreateNestedManyWithoutDetectedByInput
    claims?: ClaimCreateNestedManyWithoutSubmittedByInput
    evidence?: EvidenceCreateNestedManyWithoutUploadedByInput
    actionItems?: ActionItemCreateNestedManyWithoutAssignedToInput
    filesUploaded?: FileMetadataCreateNestedManyWithoutUploadedByInput
    sessions?: SessionDataCreateNestedManyWithoutUserInput
    mfaSettings?: MfaSettingsCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    delayEvents?: DelayEventUncheckedCreateNestedManyWithoutDetectedByInput
    claims?: ClaimUncheckedCreateNestedManyWithoutSubmittedByInput
    evidence?: EvidenceUncheckedCreateNestedManyWithoutUploadedByInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutAssignedToInput
    filesUploaded?: FileMetadataUncheckedCreateNestedManyWithoutUploadedByInput
    sessions?: SessionDataUncheckedCreateNestedManyWithoutUserInput
    mfaSettings?: MfaSettingsUncheckedCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserCreateManyOrganizationInputEnvelope = {
    data: UserCreateManyOrganizationInput | UserCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    status?: $Enums.ProjectStatus
    contractValue?: Decimal | DecimalJsLike | number | string | null
    contractType?: $Enums.ContractType | null
    startDate: Date | string
    plannedCompletion?: Date | string | null
    currentCompletion?: Date | string | null
    healthScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    projectManager?: UserCreateNestedOneWithoutAssignedProjectsInput
    delayEvents?: DelayEventCreateNestedManyWithoutProjectInput
    claims?: ClaimCreateNestedManyWithoutProjectInput
    actionItems?: ActionItemCreateNestedManyWithoutProjectInput
    schedules?: ScheduleCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    status?: $Enums.ProjectStatus
    contractValue?: Decimal | DecimalJsLike | number | string | null
    contractType?: $Enums.ContractType | null
    startDate: Date | string
    plannedCompletion?: Date | string | null
    currentCompletion?: Date | string | null
    healthScore?: number | null
    projectManagerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    delayEvents?: DelayEventUncheckedCreateNestedManyWithoutProjectInput
    claims?: ClaimUncheckedCreateNestedManyWithoutProjectInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutProjectInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutOrganizationInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput>
  }

  export type ProjectCreateManyOrganizationInputEnvelope = {
    data: ProjectCreateManyOrganizationInput | ProjectCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type FileMetadataCreateWithoutOrganizationInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint | number
    checksum?: string | null
    path: string
    isPublic?: boolean
    tags?: FileMetadataCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    uploadedBy: UserCreateNestedOneWithoutFilesUploadedInput
    evidence?: EvidenceCreateNestedManyWithoutFileInput
    schedules?: ScheduleCreateNestedManyWithoutFileInput
  }

  export type FileMetadataUncheckedCreateWithoutOrganizationInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint | number
    checksum?: string | null
    uploadedById: string
    path: string
    isPublic?: boolean
    tags?: FileMetadataCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evidence?: EvidenceUncheckedCreateNestedManyWithoutFileInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileMetadataCreateOrConnectWithoutOrganizationInput = {
    where: FileMetadataWhereUniqueInput
    create: XOR<FileMetadataCreateWithoutOrganizationInput, FileMetadataUncheckedCreateWithoutOrganizationInput>
  }

  export type FileMetadataCreateManyOrganizationInputEnvelope = {
    data: FileMetadataCreateManyOrganizationInput | FileMetadataCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutOrganizationInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutOrganizationInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    userId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutOrganizationInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutOrganizationInput, AuditLogUncheckedCreateWithoutOrganizationInput>
  }

  export type AuditLogCreateManyOrganizationInputEnvelope = {
    data: AuditLogCreateManyOrganizationInput | AuditLogCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type AnalyticsEventCreateWithoutOrganizationInput = {
    id?: string
    eventType: string
    userId?: string | null
    properties?: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type AnalyticsEventUncheckedCreateWithoutOrganizationInput = {
    id?: string
    eventType: string
    userId?: string | null
    properties?: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type AnalyticsEventCreateOrConnectWithoutOrganizationInput = {
    where: AnalyticsEventWhereUniqueInput
    create: XOR<AnalyticsEventCreateWithoutOrganizationInput, AnalyticsEventUncheckedCreateWithoutOrganizationInput>
  }

  export type AnalyticsEventCreateManyOrganizationInputEnvelope = {
    data: AnalyticsEventCreateManyOrganizationInput | AnalyticsEventCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type StorageQuotaCreateWithoutOrganizationInput = {
    id?: string
    usedBytes?: bigint | number
    limitBytes: bigint | number
    fileCount?: number
    maxFileCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorageQuotaUncheckedCreateWithoutOrganizationInput = {
    id?: string
    usedBytes?: bigint | number
    limitBytes: bigint | number
    fileCount?: number
    maxFileCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StorageQuotaCreateOrConnectWithoutOrganizationInput = {
    where: StorageQuotaWhereUniqueInput
    create: XOR<StorageQuotaCreateWithoutOrganizationInput, StorageQuotaUncheckedCreateWithoutOrganizationInput>
  }

  export type StorageQuotaCreateManyOrganizationInputEnvelope = {
    data: StorageQuotaCreateManyOrganizationInput | StorageQuotaCreateManyOrganizationInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
  }

  export type UserUpdateManyWithWhereWithoutOrganizationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    organizationId?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutOrganizationInput, ProjectUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ProjectCreateWithoutOrganizationInput, ProjectUncheckedCreateWithoutOrganizationInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutOrganizationInput, ProjectUncheckedUpdateWithoutOrganizationInput>
  }

  export type ProjectUpdateManyWithWhereWithoutOrganizationInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    location?: StringNullableFilter<"Project"> | string | null
    organizationId?: StringFilter<"Project"> | string
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    contractValue?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    contractType?: EnumContractTypeNullableFilter<"Project"> | $Enums.ContractType | null
    startDate?: DateTimeFilter<"Project"> | Date | string
    plannedCompletion?: DateTimeNullableFilter<"Project"> | Date | string | null
    currentCompletion?: DateTimeNullableFilter<"Project"> | Date | string | null
    healthScore?: IntNullableFilter<"Project"> | number | null
    projectManagerId?: StringNullableFilter<"Project"> | string | null
    metadata?: JsonNullableFilter<"Project">
    isDeleted?: BoolFilter<"Project"> | boolean
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
  }

  export type FileMetadataUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: FileMetadataWhereUniqueInput
    update: XOR<FileMetadataUpdateWithoutOrganizationInput, FileMetadataUncheckedUpdateWithoutOrganizationInput>
    create: XOR<FileMetadataCreateWithoutOrganizationInput, FileMetadataUncheckedCreateWithoutOrganizationInput>
  }

  export type FileMetadataUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: FileMetadataWhereUniqueInput
    data: XOR<FileMetadataUpdateWithoutOrganizationInput, FileMetadataUncheckedUpdateWithoutOrganizationInput>
  }

  export type FileMetadataUpdateManyWithWhereWithoutOrganizationInput = {
    where: FileMetadataScalarWhereInput
    data: XOR<FileMetadataUpdateManyMutationInput, FileMetadataUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type FileMetadataScalarWhereInput = {
    AND?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
    OR?: FileMetadataScalarWhereInput[]
    NOT?: FileMetadataScalarWhereInput | FileMetadataScalarWhereInput[]
    id?: StringFilter<"FileMetadata"> | string
    filename?: StringFilter<"FileMetadata"> | string
    originalName?: StringFilter<"FileMetadata"> | string
    mimeType?: StringFilter<"FileMetadata"> | string
    size?: BigIntFilter<"FileMetadata"> | bigint | number
    checksum?: StringNullableFilter<"FileMetadata"> | string | null
    organizationId?: StringFilter<"FileMetadata"> | string
    uploadedById?: StringFilter<"FileMetadata"> | string
    path?: StringFilter<"FileMetadata"> | string
    isPublic?: BoolFilter<"FileMetadata"> | boolean
    tags?: StringNullableListFilter<"FileMetadata">
    metadata?: JsonNullableFilter<"FileMetadata">
    isDeleted?: BoolFilter<"FileMetadata"> | boolean
    createdAt?: DateTimeFilter<"FileMetadata"> | Date | string
    updatedAt?: DateTimeFilter<"FileMetadata"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutOrganizationInput, AuditLogUncheckedUpdateWithoutOrganizationInput>
    create: XOR<AuditLogCreateWithoutOrganizationInput, AuditLogUncheckedCreateWithoutOrganizationInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutOrganizationInput, AuditLogUncheckedUpdateWithoutOrganizationInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutOrganizationInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    organizationId?: StringFilter<"AuditLog"> | string
    changes?: JsonNullableFilter<"AuditLog">
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AnalyticsEventUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: AnalyticsEventWhereUniqueInput
    update: XOR<AnalyticsEventUpdateWithoutOrganizationInput, AnalyticsEventUncheckedUpdateWithoutOrganizationInput>
    create: XOR<AnalyticsEventCreateWithoutOrganizationInput, AnalyticsEventUncheckedCreateWithoutOrganizationInput>
  }

  export type AnalyticsEventUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: AnalyticsEventWhereUniqueInput
    data: XOR<AnalyticsEventUpdateWithoutOrganizationInput, AnalyticsEventUncheckedUpdateWithoutOrganizationInput>
  }

  export type AnalyticsEventUpdateManyWithWhereWithoutOrganizationInput = {
    where: AnalyticsEventScalarWhereInput
    data: XOR<AnalyticsEventUpdateManyMutationInput, AnalyticsEventUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type AnalyticsEventScalarWhereInput = {
    AND?: AnalyticsEventScalarWhereInput | AnalyticsEventScalarWhereInput[]
    OR?: AnalyticsEventScalarWhereInput[]
    NOT?: AnalyticsEventScalarWhereInput | AnalyticsEventScalarWhereInput[]
    id?: StringFilter<"AnalyticsEvent"> | string
    eventType?: StringFilter<"AnalyticsEvent"> | string
    userId?: StringNullableFilter<"AnalyticsEvent"> | string | null
    organizationId?: StringFilter<"AnalyticsEvent"> | string
    properties?: JsonFilter<"AnalyticsEvent">
    timestamp?: DateTimeFilter<"AnalyticsEvent"> | Date | string
    createdAt?: DateTimeFilter<"AnalyticsEvent"> | Date | string
  }

  export type StorageQuotaUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: StorageQuotaWhereUniqueInput
    update: XOR<StorageQuotaUpdateWithoutOrganizationInput, StorageQuotaUncheckedUpdateWithoutOrganizationInput>
    create: XOR<StorageQuotaCreateWithoutOrganizationInput, StorageQuotaUncheckedCreateWithoutOrganizationInput>
  }

  export type StorageQuotaUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: StorageQuotaWhereUniqueInput
    data: XOR<StorageQuotaUpdateWithoutOrganizationInput, StorageQuotaUncheckedUpdateWithoutOrganizationInput>
  }

  export type StorageQuotaUpdateManyWithWhereWithoutOrganizationInput = {
    where: StorageQuotaScalarWhereInput
    data: XOR<StorageQuotaUpdateManyMutationInput, StorageQuotaUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type StorageQuotaScalarWhereInput = {
    AND?: StorageQuotaScalarWhereInput | StorageQuotaScalarWhereInput[]
    OR?: StorageQuotaScalarWhereInput[]
    NOT?: StorageQuotaScalarWhereInput | StorageQuotaScalarWhereInput[]
    id?: StringFilter<"StorageQuota"> | string
    organizationId?: StringFilter<"StorageQuota"> | string
    usedBytes?: BigIntFilter<"StorageQuota"> | bigint | number
    limitBytes?: BigIntFilter<"StorageQuota"> | bigint | number
    fileCount?: IntFilter<"StorageQuota"> | number
    maxFileCount?: IntFilter<"StorageQuota"> | number
    createdAt?: DateTimeFilter<"StorageQuota"> | Date | string
    updatedAt?: DateTimeFilter<"StorageQuota"> | Date | string
  }

  export type OrganizationCreateWithoutUsersInput = {
    id?: string
    name: string
    domain: string
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    files?: FileMetadataCreateNestedManyWithoutOrganizationInput
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput
    events?: AnalyticsEventCreateNestedManyWithoutOrganizationInput
    quotas?: StorageQuotaCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    domain: string
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    files?: FileMetadataUncheckedCreateNestedManyWithoutOrganizationInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput
    events?: AnalyticsEventUncheckedCreateNestedManyWithoutOrganizationInput
    quotas?: StorageQuotaUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutUsersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
  }

  export type ProjectCreateWithoutProjectManagerInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    status?: $Enums.ProjectStatus
    contractValue?: Decimal | DecimalJsLike | number | string | null
    contractType?: $Enums.ContractType | null
    startDate: Date | string
    plannedCompletion?: Date | string | null
    currentCompletion?: Date | string | null
    healthScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    delayEvents?: DelayEventCreateNestedManyWithoutProjectInput
    claims?: ClaimCreateNestedManyWithoutProjectInput
    actionItems?: ActionItemCreateNestedManyWithoutProjectInput
    schedules?: ScheduleCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProjectManagerInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    organizationId: string
    status?: $Enums.ProjectStatus
    contractValue?: Decimal | DecimalJsLike | number | string | null
    contractType?: $Enums.ContractType | null
    startDate: Date | string
    plannedCompletion?: Date | string | null
    currentCompletion?: Date | string | null
    healthScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    delayEvents?: DelayEventUncheckedCreateNestedManyWithoutProjectInput
    claims?: ClaimUncheckedCreateNestedManyWithoutProjectInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutProjectInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectManagerInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectManagerInput, ProjectUncheckedCreateWithoutProjectManagerInput>
  }

  export type ProjectCreateManyProjectManagerInputEnvelope = {
    data: ProjectCreateManyProjectManagerInput | ProjectCreateManyProjectManagerInput[]
    skipDuplicates?: boolean
  }

  export type DelayEventCreateWithoutDetectedByInput = {
    id?: string
    activityId?: string | null
    activityName: string
    detectionDate: Date | string
    delayDays: number
    causeType: $Enums.DelayType
    probabilityScore?: number | null
    evidenceStrength?: number | null
    status?: $Enums.DelayStatus
    description?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    criticalPath?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDelayEventsInput
    claims?: ClaimCreateNestedManyWithoutDelayEventInput
    evidence?: EvidenceCreateNestedManyWithoutDelayEventInput
  }

  export type DelayEventUncheckedCreateWithoutDetectedByInput = {
    id?: string
    projectId: string
    activityId?: string | null
    activityName: string
    detectionDate: Date | string
    delayDays: number
    causeType: $Enums.DelayType
    probabilityScore?: number | null
    evidenceStrength?: number | null
    status?: $Enums.DelayStatus
    description?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    criticalPath?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    claims?: ClaimUncheckedCreateNestedManyWithoutDelayEventInput
    evidence?: EvidenceUncheckedCreateNestedManyWithoutDelayEventInput
  }

  export type DelayEventCreateOrConnectWithoutDetectedByInput = {
    where: DelayEventWhereUniqueInput
    create: XOR<DelayEventCreateWithoutDetectedByInput, DelayEventUncheckedCreateWithoutDetectedByInput>
  }

  export type DelayEventCreateManyDetectedByInputEnvelope = {
    data: DelayEventCreateManyDetectedByInput | DelayEventCreateManyDetectedByInput[]
    skipDuplicates?: boolean
  }

  export type ClaimCreateWithoutSubmittedByInput = {
    id?: string
    referenceNumber: string
    title: string
    description?: string | null
    submissionDate?: Date | string | null
    noticeDate?: Date | string | null
    claimAmount?: Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: number | null
    status?: $Enums.ClaimStatus
    responseDueDate?: Date | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutClaimsInput
    delayEvent?: DelayEventCreateNestedOneWithoutClaimsInput
    evidence?: EvidenceCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutSubmittedByInput = {
    id?: string
    projectId: string
    delayEventId?: string | null
    referenceNumber: string
    title: string
    description?: string | null
    submissionDate?: Date | string | null
    noticeDate?: Date | string | null
    claimAmount?: Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: number | null
    status?: $Enums.ClaimStatus
    responseDueDate?: Date | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evidence?: EvidenceUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutSubmittedByInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutSubmittedByInput, ClaimUncheckedCreateWithoutSubmittedByInput>
  }

  export type ClaimCreateManySubmittedByInputEnvelope = {
    data: ClaimCreateManySubmittedByInput | ClaimCreateManySubmittedByInput[]
    skipDuplicates?: boolean
  }

  export type EvidenceCreateWithoutUploadedByInput = {
    id?: string
    type: $Enums.EvidenceType
    title: string
    description?: string | null
    sourceSystem?: string | null
    filePath?: string | null
    relevanceScore?: number | null
    extractedText?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    delayEvent?: DelayEventCreateNestedOneWithoutEvidenceInput
    claim?: ClaimCreateNestedOneWithoutEvidenceInput
    file?: FileMetadataCreateNestedOneWithoutEvidenceInput
  }

  export type EvidenceUncheckedCreateWithoutUploadedByInput = {
    id?: string
    delayEventId?: string | null
    claimId?: string | null
    type: $Enums.EvidenceType
    title: string
    description?: string | null
    sourceSystem?: string | null
    filePath?: string | null
    fileId?: string | null
    relevanceScore?: number | null
    extractedText?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvidenceCreateOrConnectWithoutUploadedByInput = {
    where: EvidenceWhereUniqueInput
    create: XOR<EvidenceCreateWithoutUploadedByInput, EvidenceUncheckedCreateWithoutUploadedByInput>
  }

  export type EvidenceCreateManyUploadedByInputEnvelope = {
    data: EvidenceCreateManyUploadedByInput | EvidenceCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type ActionItemCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    dueDate: Date | string
    status?: $Enums.ActionItemStatus
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutActionItemsInput
  }

  export type ActionItemUncheckedCreateWithoutAssignedToInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    dueDate: Date | string
    projectId: string
    status?: $Enums.ActionItemStatus
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionItemCreateOrConnectWithoutAssignedToInput = {
    where: ActionItemWhereUniqueInput
    create: XOR<ActionItemCreateWithoutAssignedToInput, ActionItemUncheckedCreateWithoutAssignedToInput>
  }

  export type ActionItemCreateManyAssignedToInputEnvelope = {
    data: ActionItemCreateManyAssignedToInput | ActionItemCreateManyAssignedToInput[]
    skipDuplicates?: boolean
  }

  export type FileMetadataCreateWithoutUploadedByInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint | number
    checksum?: string | null
    path: string
    isPublic?: boolean
    tags?: FileMetadataCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutFilesInput
    evidence?: EvidenceCreateNestedManyWithoutFileInput
    schedules?: ScheduleCreateNestedManyWithoutFileInput
  }

  export type FileMetadataUncheckedCreateWithoutUploadedByInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint | number
    checksum?: string | null
    organizationId: string
    path: string
    isPublic?: boolean
    tags?: FileMetadataCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evidence?: EvidenceUncheckedCreateNestedManyWithoutFileInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileMetadataCreateOrConnectWithoutUploadedByInput = {
    where: FileMetadataWhereUniqueInput
    create: XOR<FileMetadataCreateWithoutUploadedByInput, FileMetadataUncheckedCreateWithoutUploadedByInput>
  }

  export type FileMetadataCreateManyUploadedByInputEnvelope = {
    data: FileMetadataCreateManyUploadedByInput | FileMetadataCreateManyUploadedByInput[]
    skipDuplicates?: boolean
  }

  export type SessionDataCreateWithoutUserInput = {
    id?: string
    deviceInfo: JsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    lastActivityAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionDataUncheckedCreateWithoutUserInput = {
    id?: string
    deviceInfo: JsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    lastActivityAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionDataCreateOrConnectWithoutUserInput = {
    where: SessionDataWhereUniqueInput
    create: XOR<SessionDataCreateWithoutUserInput, SessionDataUncheckedCreateWithoutUserInput>
  }

  export type SessionDataCreateManyUserInputEnvelope = {
    data: SessionDataCreateManyUserInput | SessionDataCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MfaSettingsCreateWithoutUserInput = {
    id?: string
    isEnabled?: boolean
    method: $Enums.MfaMethod
    secret?: string | null
    backupCodes?: MfaSettingsCreatebackupCodesInput | string[]
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MfaSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    isEnabled?: boolean
    method: $Enums.MfaMethod
    secret?: string | null
    backupCodes?: MfaSettingsCreatebackupCodesInput | string[]
    lastUsedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MfaSettingsCreateOrConnectWithoutUserInput = {
    where: MfaSettingsWhereUniqueInput
    create: XOR<MfaSettingsCreateWithoutUserInput, MfaSettingsUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    isUsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordResetTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    isUsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordResetTokenCreateOrConnectWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenCreateManyUserInputEnvelope = {
    data: PasswordResetTokenCreateManyUserInput | PasswordResetTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    organizationId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutUsersInput = {
    update: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUsersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type OrganizationUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    files?: FileMetadataUpdateManyWithoutOrganizationNestedInput
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput
    events?: AnalyticsEventUpdateManyWithoutOrganizationNestedInput
    quotas?: StorageQuotaUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    files?: FileMetadataUncheckedUpdateManyWithoutOrganizationNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput
    events?: AnalyticsEventUncheckedUpdateManyWithoutOrganizationNestedInput
    quotas?: StorageQuotaUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ProjectUpsertWithWhereUniqueWithoutProjectManagerInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutProjectManagerInput, ProjectUncheckedUpdateWithoutProjectManagerInput>
    create: XOR<ProjectCreateWithoutProjectManagerInput, ProjectUncheckedCreateWithoutProjectManagerInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutProjectManagerInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutProjectManagerInput, ProjectUncheckedUpdateWithoutProjectManagerInput>
  }

  export type ProjectUpdateManyWithWhereWithoutProjectManagerInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutProjectManagerInput>
  }

  export type DelayEventUpsertWithWhereUniqueWithoutDetectedByInput = {
    where: DelayEventWhereUniqueInput
    update: XOR<DelayEventUpdateWithoutDetectedByInput, DelayEventUncheckedUpdateWithoutDetectedByInput>
    create: XOR<DelayEventCreateWithoutDetectedByInput, DelayEventUncheckedCreateWithoutDetectedByInput>
  }

  export type DelayEventUpdateWithWhereUniqueWithoutDetectedByInput = {
    where: DelayEventWhereUniqueInput
    data: XOR<DelayEventUpdateWithoutDetectedByInput, DelayEventUncheckedUpdateWithoutDetectedByInput>
  }

  export type DelayEventUpdateManyWithWhereWithoutDetectedByInput = {
    where: DelayEventScalarWhereInput
    data: XOR<DelayEventUpdateManyMutationInput, DelayEventUncheckedUpdateManyWithoutDetectedByInput>
  }

  export type DelayEventScalarWhereInput = {
    AND?: DelayEventScalarWhereInput | DelayEventScalarWhereInput[]
    OR?: DelayEventScalarWhereInput[]
    NOT?: DelayEventScalarWhereInput | DelayEventScalarWhereInput[]
    id?: StringFilter<"DelayEvent"> | string
    projectId?: StringFilter<"DelayEvent"> | string
    activityId?: StringNullableFilter<"DelayEvent"> | string | null
    activityName?: StringFilter<"DelayEvent"> | string
    detectionDate?: DateTimeFilter<"DelayEvent"> | Date | string
    delayDays?: IntFilter<"DelayEvent"> | number
    causeType?: EnumDelayTypeFilter<"DelayEvent"> | $Enums.DelayType
    probabilityScore?: IntNullableFilter<"DelayEvent"> | number | null
    evidenceStrength?: IntNullableFilter<"DelayEvent"> | number | null
    status?: EnumDelayStatusFilter<"DelayEvent"> | $Enums.DelayStatus
    description?: StringNullableFilter<"DelayEvent"> | string | null
    estimatedCost?: DecimalNullableFilter<"DelayEvent"> | Decimal | DecimalJsLike | number | string | null
    criticalPath?: BoolFilter<"DelayEvent"> | boolean
    detectedById?: StringFilter<"DelayEvent"> | string
    metadata?: JsonNullableFilter<"DelayEvent">
    isDeleted?: BoolFilter<"DelayEvent"> | boolean
    createdAt?: DateTimeFilter<"DelayEvent"> | Date | string
    updatedAt?: DateTimeFilter<"DelayEvent"> | Date | string
  }

  export type ClaimUpsertWithWhereUniqueWithoutSubmittedByInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutSubmittedByInput, ClaimUncheckedUpdateWithoutSubmittedByInput>
    create: XOR<ClaimCreateWithoutSubmittedByInput, ClaimUncheckedCreateWithoutSubmittedByInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutSubmittedByInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutSubmittedByInput, ClaimUncheckedUpdateWithoutSubmittedByInput>
  }

  export type ClaimUpdateManyWithWhereWithoutSubmittedByInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutSubmittedByInput>
  }

  export type ClaimScalarWhereInput = {
    AND?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
    OR?: ClaimScalarWhereInput[]
    NOT?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
    id?: StringFilter<"Claim"> | string
    projectId?: StringFilter<"Claim"> | string
    delayEventId?: StringNullableFilter<"Claim"> | string | null
    referenceNumber?: StringFilter<"Claim"> | string
    title?: StringFilter<"Claim"> | string
    description?: StringNullableFilter<"Claim"> | string | null
    submissionDate?: DateTimeNullableFilter<"Claim"> | Date | string | null
    noticeDate?: DateTimeNullableFilter<"Claim"> | Date | string | null
    claimAmount?: DecimalNullableFilter<"Claim"> | Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: IntNullableFilter<"Claim"> | number | null
    status?: EnumClaimStatusFilter<"Claim"> | $Enums.ClaimStatus
    responseDueDate?: DateTimeNullableFilter<"Claim"> | Date | string | null
    submittedById?: StringNullableFilter<"Claim"> | string | null
    workflow?: JsonNullableFilter<"Claim">
    metadata?: JsonNullableFilter<"Claim">
    isDeleted?: BoolFilter<"Claim"> | boolean
    createdAt?: DateTimeFilter<"Claim"> | Date | string
    updatedAt?: DateTimeFilter<"Claim"> | Date | string
  }

  export type EvidenceUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: EvidenceWhereUniqueInput
    update: XOR<EvidenceUpdateWithoutUploadedByInput, EvidenceUncheckedUpdateWithoutUploadedByInput>
    create: XOR<EvidenceCreateWithoutUploadedByInput, EvidenceUncheckedCreateWithoutUploadedByInput>
  }

  export type EvidenceUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: EvidenceWhereUniqueInput
    data: XOR<EvidenceUpdateWithoutUploadedByInput, EvidenceUncheckedUpdateWithoutUploadedByInput>
  }

  export type EvidenceUpdateManyWithWhereWithoutUploadedByInput = {
    where: EvidenceScalarWhereInput
    data: XOR<EvidenceUpdateManyMutationInput, EvidenceUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type EvidenceScalarWhereInput = {
    AND?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
    OR?: EvidenceScalarWhereInput[]
    NOT?: EvidenceScalarWhereInput | EvidenceScalarWhereInput[]
    id?: StringFilter<"Evidence"> | string
    delayEventId?: StringNullableFilter<"Evidence"> | string | null
    claimId?: StringNullableFilter<"Evidence"> | string | null
    type?: EnumEvidenceTypeFilter<"Evidence"> | $Enums.EvidenceType
    title?: StringFilter<"Evidence"> | string
    description?: StringNullableFilter<"Evidence"> | string | null
    sourceSystem?: StringNullableFilter<"Evidence"> | string | null
    filePath?: StringNullableFilter<"Evidence"> | string | null
    fileId?: StringNullableFilter<"Evidence"> | string | null
    relevanceScore?: IntNullableFilter<"Evidence"> | number | null
    extractedText?: StringNullableFilter<"Evidence"> | string | null
    metadata?: JsonNullableFilter<"Evidence">
    uploadedById?: StringFilter<"Evidence"> | string
    isDeleted?: BoolFilter<"Evidence"> | boolean
    createdAt?: DateTimeFilter<"Evidence"> | Date | string
    updatedAt?: DateTimeFilter<"Evidence"> | Date | string
  }

  export type ActionItemUpsertWithWhereUniqueWithoutAssignedToInput = {
    where: ActionItemWhereUniqueInput
    update: XOR<ActionItemUpdateWithoutAssignedToInput, ActionItemUncheckedUpdateWithoutAssignedToInput>
    create: XOR<ActionItemCreateWithoutAssignedToInput, ActionItemUncheckedCreateWithoutAssignedToInput>
  }

  export type ActionItemUpdateWithWhereUniqueWithoutAssignedToInput = {
    where: ActionItemWhereUniqueInput
    data: XOR<ActionItemUpdateWithoutAssignedToInput, ActionItemUncheckedUpdateWithoutAssignedToInput>
  }

  export type ActionItemUpdateManyWithWhereWithoutAssignedToInput = {
    where: ActionItemScalarWhereInput
    data: XOR<ActionItemUpdateManyMutationInput, ActionItemUncheckedUpdateManyWithoutAssignedToInput>
  }

  export type ActionItemScalarWhereInput = {
    AND?: ActionItemScalarWhereInput | ActionItemScalarWhereInput[]
    OR?: ActionItemScalarWhereInput[]
    NOT?: ActionItemScalarWhereInput | ActionItemScalarWhereInput[]
    id?: StringFilter<"ActionItem"> | string
    title?: StringFilter<"ActionItem"> | string
    description?: StringNullableFilter<"ActionItem"> | string | null
    priority?: EnumPriorityFilter<"ActionItem"> | $Enums.Priority
    dueDate?: DateTimeFilter<"ActionItem"> | Date | string
    projectId?: StringFilter<"ActionItem"> | string
    assignedToId?: StringFilter<"ActionItem"> | string
    status?: EnumActionItemStatusFilter<"ActionItem"> | $Enums.ActionItemStatus
    completedAt?: DateTimeNullableFilter<"ActionItem"> | Date | string | null
    metadata?: JsonNullableFilter<"ActionItem">
    isDeleted?: BoolFilter<"ActionItem"> | boolean
    createdAt?: DateTimeFilter<"ActionItem"> | Date | string
    updatedAt?: DateTimeFilter<"ActionItem"> | Date | string
  }

  export type FileMetadataUpsertWithWhereUniqueWithoutUploadedByInput = {
    where: FileMetadataWhereUniqueInput
    update: XOR<FileMetadataUpdateWithoutUploadedByInput, FileMetadataUncheckedUpdateWithoutUploadedByInput>
    create: XOR<FileMetadataCreateWithoutUploadedByInput, FileMetadataUncheckedCreateWithoutUploadedByInput>
  }

  export type FileMetadataUpdateWithWhereUniqueWithoutUploadedByInput = {
    where: FileMetadataWhereUniqueInput
    data: XOR<FileMetadataUpdateWithoutUploadedByInput, FileMetadataUncheckedUpdateWithoutUploadedByInput>
  }

  export type FileMetadataUpdateManyWithWhereWithoutUploadedByInput = {
    where: FileMetadataScalarWhereInput
    data: XOR<FileMetadataUpdateManyMutationInput, FileMetadataUncheckedUpdateManyWithoutUploadedByInput>
  }

  export type SessionDataUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionDataWhereUniqueInput
    update: XOR<SessionDataUpdateWithoutUserInput, SessionDataUncheckedUpdateWithoutUserInput>
    create: XOR<SessionDataCreateWithoutUserInput, SessionDataUncheckedCreateWithoutUserInput>
  }

  export type SessionDataUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionDataWhereUniqueInput
    data: XOR<SessionDataUpdateWithoutUserInput, SessionDataUncheckedUpdateWithoutUserInput>
  }

  export type SessionDataUpdateManyWithWhereWithoutUserInput = {
    where: SessionDataScalarWhereInput
    data: XOR<SessionDataUpdateManyMutationInput, SessionDataUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionDataScalarWhereInput = {
    AND?: SessionDataScalarWhereInput | SessionDataScalarWhereInput[]
    OR?: SessionDataScalarWhereInput[]
    NOT?: SessionDataScalarWhereInput | SessionDataScalarWhereInput[]
    id?: StringFilter<"SessionData"> | string
    userId?: StringFilter<"SessionData"> | string
    deviceInfo?: JsonFilter<"SessionData">
    location?: JsonNullableFilter<"SessionData">
    expiresAt?: DateTimeFilter<"SessionData"> | Date | string
    lastActivityAt?: DateTimeFilter<"SessionData"> | Date | string
    isActive?: BoolFilter<"SessionData"> | boolean
    createdAt?: DateTimeFilter<"SessionData"> | Date | string
    updatedAt?: DateTimeFilter<"SessionData"> | Date | string
  }

  export type MfaSettingsUpsertWithoutUserInput = {
    update: XOR<MfaSettingsUpdateWithoutUserInput, MfaSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<MfaSettingsCreateWithoutUserInput, MfaSettingsUncheckedCreateWithoutUserInput>
    where?: MfaSettingsWhereInput
  }

  export type MfaSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: MfaSettingsWhereInput
    data: XOR<MfaSettingsUpdateWithoutUserInput, MfaSettingsUncheckedUpdateWithoutUserInput>
  }

  export type MfaSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    method?: EnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: MfaSettingsUpdatebackupCodesInput | string[]
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MfaSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    method?: EnumMfaMethodFieldUpdateOperationsInput | $Enums.MfaMethod
    secret?: NullableStringFieldUpdateOperationsInput | string | null
    backupCodes?: MfaSettingsUpdatebackupCodesInput | string[]
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    update: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetTokenCreateWithoutUserInput, PasswordResetTokenUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetTokenWhereUniqueInput
    data: XOR<PasswordResetTokenUpdateWithoutUserInput, PasswordResetTokenUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetTokenUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetTokenScalarWhereInput
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetTokenScalarWhereInput = {
    AND?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    OR?: PasswordResetTokenScalarWhereInput[]
    NOT?: PasswordResetTokenScalarWhereInput | PasswordResetTokenScalarWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    userId?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expiresAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    isUsed?: BoolFilter<"PasswordResetToken"> | boolean
    createdAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
    updatedAt?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type OrganizationCreateWithoutProjectsInput = {
    id?: string
    name: string
    domain: string
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    files?: FileMetadataCreateNestedManyWithoutOrganizationInput
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput
    events?: AnalyticsEventCreateNestedManyWithoutOrganizationInput
    quotas?: StorageQuotaCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    domain: string
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    files?: FileMetadataUncheckedCreateNestedManyWithoutOrganizationInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput
    events?: AnalyticsEventUncheckedCreateNestedManyWithoutOrganizationInput
    quotas?: StorageQuotaUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutProjectsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
  }

  export type UserCreateWithoutAssignedProjectsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUsersInput
    delayEvents?: DelayEventCreateNestedManyWithoutDetectedByInput
    claims?: ClaimCreateNestedManyWithoutSubmittedByInput
    evidence?: EvidenceCreateNestedManyWithoutUploadedByInput
    actionItems?: ActionItemCreateNestedManyWithoutAssignedToInput
    filesUploaded?: FileMetadataCreateNestedManyWithoutUploadedByInput
    sessions?: SessionDataCreateNestedManyWithoutUserInput
    mfaSettings?: MfaSettingsCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAssignedProjectsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    organizationId: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    delayEvents?: DelayEventUncheckedCreateNestedManyWithoutDetectedByInput
    claims?: ClaimUncheckedCreateNestedManyWithoutSubmittedByInput
    evidence?: EvidenceUncheckedCreateNestedManyWithoutUploadedByInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutAssignedToInput
    filesUploaded?: FileMetadataUncheckedCreateNestedManyWithoutUploadedByInput
    sessions?: SessionDataUncheckedCreateNestedManyWithoutUserInput
    mfaSettings?: MfaSettingsUncheckedCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAssignedProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedProjectsInput, UserUncheckedCreateWithoutAssignedProjectsInput>
  }

  export type DelayEventCreateWithoutProjectInput = {
    id?: string
    activityId?: string | null
    activityName: string
    detectionDate: Date | string
    delayDays: number
    causeType: $Enums.DelayType
    probabilityScore?: number | null
    evidenceStrength?: number | null
    status?: $Enums.DelayStatus
    description?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    criticalPath?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    detectedBy: UserCreateNestedOneWithoutDelayEventsInput
    claims?: ClaimCreateNestedManyWithoutDelayEventInput
    evidence?: EvidenceCreateNestedManyWithoutDelayEventInput
  }

  export type DelayEventUncheckedCreateWithoutProjectInput = {
    id?: string
    activityId?: string | null
    activityName: string
    detectionDate: Date | string
    delayDays: number
    causeType: $Enums.DelayType
    probabilityScore?: number | null
    evidenceStrength?: number | null
    status?: $Enums.DelayStatus
    description?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    criticalPath?: boolean
    detectedById: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    claims?: ClaimUncheckedCreateNestedManyWithoutDelayEventInput
    evidence?: EvidenceUncheckedCreateNestedManyWithoutDelayEventInput
  }

  export type DelayEventCreateOrConnectWithoutProjectInput = {
    where: DelayEventWhereUniqueInput
    create: XOR<DelayEventCreateWithoutProjectInput, DelayEventUncheckedCreateWithoutProjectInput>
  }

  export type DelayEventCreateManyProjectInputEnvelope = {
    data: DelayEventCreateManyProjectInput | DelayEventCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ClaimCreateWithoutProjectInput = {
    id?: string
    referenceNumber: string
    title: string
    description?: string | null
    submissionDate?: Date | string | null
    noticeDate?: Date | string | null
    claimAmount?: Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: number | null
    status?: $Enums.ClaimStatus
    responseDueDate?: Date | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    delayEvent?: DelayEventCreateNestedOneWithoutClaimsInput
    submittedBy?: UserCreateNestedOneWithoutClaimsInput
    evidence?: EvidenceCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutProjectInput = {
    id?: string
    delayEventId?: string | null
    referenceNumber: string
    title: string
    description?: string | null
    submissionDate?: Date | string | null
    noticeDate?: Date | string | null
    claimAmount?: Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: number | null
    status?: $Enums.ClaimStatus
    responseDueDate?: Date | string | null
    submittedById?: string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evidence?: EvidenceUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutProjectInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutProjectInput, ClaimUncheckedCreateWithoutProjectInput>
  }

  export type ClaimCreateManyProjectInputEnvelope = {
    data: ClaimCreateManyProjectInput | ClaimCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ActionItemCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    dueDate: Date | string
    status?: $Enums.ActionItemStatus
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedTo: UserCreateNestedOneWithoutActionItemsInput
  }

  export type ActionItemUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    dueDate: Date | string
    assignedToId: string
    status?: $Enums.ActionItemStatus
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionItemCreateOrConnectWithoutProjectInput = {
    where: ActionItemWhereUniqueInput
    create: XOR<ActionItemCreateWithoutProjectInput, ActionItemUncheckedCreateWithoutProjectInput>
  }

  export type ActionItemCreateManyProjectInputEnvelope = {
    data: ActionItemCreateManyProjectInput | ActionItemCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    format: $Enums.ScheduleFormat
    version?: string | null
    baselineDate?: Date | string | null
    statusDate?: Date | string | null
    filePath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isBaseline?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    file?: FileMetadataCreateNestedOneWithoutSchedulesInput
  }

  export type ScheduleUncheckedCreateWithoutProjectInput = {
    id?: string
    name: string
    description?: string | null
    format: $Enums.ScheduleFormat
    version?: string | null
    baselineDate?: Date | string | null
    statusDate?: Date | string | null
    filePath?: string | null
    fileId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isBaseline?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateOrConnectWithoutProjectInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutProjectInput, ScheduleUncheckedCreateWithoutProjectInput>
  }

  export type ScheduleCreateManyProjectInputEnvelope = {
    data: ScheduleCreateManyProjectInput | ScheduleCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutProjectsInput = {
    update: XOR<OrganizationUpdateWithoutProjectsInput, OrganizationUncheckedUpdateWithoutProjectsInput>
    create: XOR<OrganizationCreateWithoutProjectsInput, OrganizationUncheckedCreateWithoutProjectsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutProjectsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutProjectsInput, OrganizationUncheckedUpdateWithoutProjectsInput>
  }

  export type OrganizationUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    files?: FileMetadataUpdateManyWithoutOrganizationNestedInput
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput
    events?: AnalyticsEventUpdateManyWithoutOrganizationNestedInput
    quotas?: StorageQuotaUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    files?: FileMetadataUncheckedUpdateManyWithoutOrganizationNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput
    events?: AnalyticsEventUncheckedUpdateManyWithoutOrganizationNestedInput
    quotas?: StorageQuotaUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutAssignedProjectsInput = {
    update: XOR<UserUpdateWithoutAssignedProjectsInput, UserUncheckedUpdateWithoutAssignedProjectsInput>
    create: XOR<UserCreateWithoutAssignedProjectsInput, UserUncheckedCreateWithoutAssignedProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedProjectsInput, UserUncheckedUpdateWithoutAssignedProjectsInput>
  }

  export type UserUpdateWithoutAssignedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    delayEvents?: DelayEventUpdateManyWithoutDetectedByNestedInput
    claims?: ClaimUpdateManyWithoutSubmittedByNestedInput
    evidence?: EvidenceUpdateManyWithoutUploadedByNestedInput
    actionItems?: ActionItemUpdateManyWithoutAssignedToNestedInput
    filesUploaded?: FileMetadataUpdateManyWithoutUploadedByNestedInput
    sessions?: SessionDataUpdateManyWithoutUserNestedInput
    mfaSettings?: MfaSettingsUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    organizationId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delayEvents?: DelayEventUncheckedUpdateManyWithoutDetectedByNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutSubmittedByNestedInput
    evidence?: EvidenceUncheckedUpdateManyWithoutUploadedByNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutAssignedToNestedInput
    filesUploaded?: FileMetadataUncheckedUpdateManyWithoutUploadedByNestedInput
    sessions?: SessionDataUncheckedUpdateManyWithoutUserNestedInput
    mfaSettings?: MfaSettingsUncheckedUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DelayEventUpsertWithWhereUniqueWithoutProjectInput = {
    where: DelayEventWhereUniqueInput
    update: XOR<DelayEventUpdateWithoutProjectInput, DelayEventUncheckedUpdateWithoutProjectInput>
    create: XOR<DelayEventCreateWithoutProjectInput, DelayEventUncheckedCreateWithoutProjectInput>
  }

  export type DelayEventUpdateWithWhereUniqueWithoutProjectInput = {
    where: DelayEventWhereUniqueInput
    data: XOR<DelayEventUpdateWithoutProjectInput, DelayEventUncheckedUpdateWithoutProjectInput>
  }

  export type DelayEventUpdateManyWithWhereWithoutProjectInput = {
    where: DelayEventScalarWhereInput
    data: XOR<DelayEventUpdateManyMutationInput, DelayEventUncheckedUpdateManyWithoutProjectInput>
  }

  export type ClaimUpsertWithWhereUniqueWithoutProjectInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutProjectInput, ClaimUncheckedUpdateWithoutProjectInput>
    create: XOR<ClaimCreateWithoutProjectInput, ClaimUncheckedCreateWithoutProjectInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutProjectInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutProjectInput, ClaimUncheckedUpdateWithoutProjectInput>
  }

  export type ClaimUpdateManyWithWhereWithoutProjectInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutProjectInput>
  }

  export type ActionItemUpsertWithWhereUniqueWithoutProjectInput = {
    where: ActionItemWhereUniqueInput
    update: XOR<ActionItemUpdateWithoutProjectInput, ActionItemUncheckedUpdateWithoutProjectInput>
    create: XOR<ActionItemCreateWithoutProjectInput, ActionItemUncheckedCreateWithoutProjectInput>
  }

  export type ActionItemUpdateWithWhereUniqueWithoutProjectInput = {
    where: ActionItemWhereUniqueInput
    data: XOR<ActionItemUpdateWithoutProjectInput, ActionItemUncheckedUpdateWithoutProjectInput>
  }

  export type ActionItemUpdateManyWithWhereWithoutProjectInput = {
    where: ActionItemScalarWhereInput
    data: XOR<ActionItemUpdateManyMutationInput, ActionItemUncheckedUpdateManyWithoutProjectInput>
  }

  export type ScheduleUpsertWithWhereUniqueWithoutProjectInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutProjectInput, ScheduleUncheckedUpdateWithoutProjectInput>
    create: XOR<ScheduleCreateWithoutProjectInput, ScheduleUncheckedCreateWithoutProjectInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutProjectInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutProjectInput, ScheduleUncheckedUpdateWithoutProjectInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutProjectInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutProjectInput>
  }

  export type ScheduleScalarWhereInput = {
    AND?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    OR?: ScheduleScalarWhereInput[]
    NOT?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    id?: StringFilter<"Schedule"> | string
    projectId?: StringFilter<"Schedule"> | string
    name?: StringFilter<"Schedule"> | string
    description?: StringNullableFilter<"Schedule"> | string | null
    format?: EnumScheduleFormatFilter<"Schedule"> | $Enums.ScheduleFormat
    version?: StringNullableFilter<"Schedule"> | string | null
    baselineDate?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    statusDate?: DateTimeNullableFilter<"Schedule"> | Date | string | null
    filePath?: StringNullableFilter<"Schedule"> | string | null
    fileId?: StringNullableFilter<"Schedule"> | string | null
    metadata?: JsonNullableFilter<"Schedule">
    isBaseline?: BoolFilter<"Schedule"> | boolean
    isDeleted?: BoolFilter<"Schedule"> | boolean
    createdAt?: DateTimeFilter<"Schedule"> | Date | string
    updatedAt?: DateTimeFilter<"Schedule"> | Date | string
  }

  export type ProjectCreateWithoutDelayEventsInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    status?: $Enums.ProjectStatus
    contractValue?: Decimal | DecimalJsLike | number | string | null
    contractType?: $Enums.ContractType | null
    startDate: Date | string
    plannedCompletion?: Date | string | null
    currentCompletion?: Date | string | null
    healthScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    projectManager?: UserCreateNestedOneWithoutAssignedProjectsInput
    claims?: ClaimCreateNestedManyWithoutProjectInput
    actionItems?: ActionItemCreateNestedManyWithoutProjectInput
    schedules?: ScheduleCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutDelayEventsInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    organizationId: string
    status?: $Enums.ProjectStatus
    contractValue?: Decimal | DecimalJsLike | number | string | null
    contractType?: $Enums.ContractType | null
    startDate: Date | string
    plannedCompletion?: Date | string | null
    currentCompletion?: Date | string | null
    healthScore?: number | null
    projectManagerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    claims?: ClaimUncheckedCreateNestedManyWithoutProjectInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutProjectInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutDelayEventsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutDelayEventsInput, ProjectUncheckedCreateWithoutDelayEventsInput>
  }

  export type UserCreateWithoutDelayEventsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUsersInput
    assignedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    claims?: ClaimCreateNestedManyWithoutSubmittedByInput
    evidence?: EvidenceCreateNestedManyWithoutUploadedByInput
    actionItems?: ActionItemCreateNestedManyWithoutAssignedToInput
    filesUploaded?: FileMetadataCreateNestedManyWithoutUploadedByInput
    sessions?: SessionDataCreateNestedManyWithoutUserInput
    mfaSettings?: MfaSettingsCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDelayEventsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    organizationId: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    claims?: ClaimUncheckedCreateNestedManyWithoutSubmittedByInput
    evidence?: EvidenceUncheckedCreateNestedManyWithoutUploadedByInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutAssignedToInput
    filesUploaded?: FileMetadataUncheckedCreateNestedManyWithoutUploadedByInput
    sessions?: SessionDataUncheckedCreateNestedManyWithoutUserInput
    mfaSettings?: MfaSettingsUncheckedCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDelayEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDelayEventsInput, UserUncheckedCreateWithoutDelayEventsInput>
  }

  export type ClaimCreateWithoutDelayEventInput = {
    id?: string
    referenceNumber: string
    title: string
    description?: string | null
    submissionDate?: Date | string | null
    noticeDate?: Date | string | null
    claimAmount?: Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: number | null
    status?: $Enums.ClaimStatus
    responseDueDate?: Date | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutClaimsInput
    submittedBy?: UserCreateNestedOneWithoutClaimsInput
    evidence?: EvidenceCreateNestedManyWithoutClaimInput
  }

  export type ClaimUncheckedCreateWithoutDelayEventInput = {
    id?: string
    projectId: string
    referenceNumber: string
    title: string
    description?: string | null
    submissionDate?: Date | string | null
    noticeDate?: Date | string | null
    claimAmount?: Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: number | null
    status?: $Enums.ClaimStatus
    responseDueDate?: Date | string | null
    submittedById?: string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evidence?: EvidenceUncheckedCreateNestedManyWithoutClaimInput
  }

  export type ClaimCreateOrConnectWithoutDelayEventInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutDelayEventInput, ClaimUncheckedCreateWithoutDelayEventInput>
  }

  export type ClaimCreateManyDelayEventInputEnvelope = {
    data: ClaimCreateManyDelayEventInput | ClaimCreateManyDelayEventInput[]
    skipDuplicates?: boolean
  }

  export type EvidenceCreateWithoutDelayEventInput = {
    id?: string
    type: $Enums.EvidenceType
    title: string
    description?: string | null
    sourceSystem?: string | null
    filePath?: string | null
    relevanceScore?: number | null
    extractedText?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    claim?: ClaimCreateNestedOneWithoutEvidenceInput
    uploadedBy: UserCreateNestedOneWithoutEvidenceInput
    file?: FileMetadataCreateNestedOneWithoutEvidenceInput
  }

  export type EvidenceUncheckedCreateWithoutDelayEventInput = {
    id?: string
    claimId?: string | null
    type: $Enums.EvidenceType
    title: string
    description?: string | null
    sourceSystem?: string | null
    filePath?: string | null
    fileId?: string | null
    relevanceScore?: number | null
    extractedText?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploadedById: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvidenceCreateOrConnectWithoutDelayEventInput = {
    where: EvidenceWhereUniqueInput
    create: XOR<EvidenceCreateWithoutDelayEventInput, EvidenceUncheckedCreateWithoutDelayEventInput>
  }

  export type EvidenceCreateManyDelayEventInputEnvelope = {
    data: EvidenceCreateManyDelayEventInput | EvidenceCreateManyDelayEventInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutDelayEventsInput = {
    update: XOR<ProjectUpdateWithoutDelayEventsInput, ProjectUncheckedUpdateWithoutDelayEventsInput>
    create: XOR<ProjectCreateWithoutDelayEventsInput, ProjectUncheckedCreateWithoutDelayEventsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutDelayEventsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutDelayEventsInput, ProjectUncheckedUpdateWithoutDelayEventsInput>
  }

  export type ProjectUpdateWithoutDelayEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    contractValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractType?: NullableEnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    projectManager?: UserUpdateOneWithoutAssignedProjectsNestedInput
    claims?: ClaimUpdateManyWithoutProjectNestedInput
    actionItems?: ActionItemUpdateManyWithoutProjectNestedInput
    schedules?: ScheduleUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutDelayEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    contractValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractType?: NullableEnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: NullableIntFieldUpdateOperationsInput | number | null
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claims?: ClaimUncheckedUpdateManyWithoutProjectNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutProjectNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutDelayEventsInput = {
    update: XOR<UserUpdateWithoutDelayEventsInput, UserUncheckedUpdateWithoutDelayEventsInput>
    create: XOR<UserCreateWithoutDelayEventsInput, UserUncheckedCreateWithoutDelayEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDelayEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDelayEventsInput, UserUncheckedUpdateWithoutDelayEventsInput>
  }

  export type UserUpdateWithoutDelayEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    assignedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    claims?: ClaimUpdateManyWithoutSubmittedByNestedInput
    evidence?: EvidenceUpdateManyWithoutUploadedByNestedInput
    actionItems?: ActionItemUpdateManyWithoutAssignedToNestedInput
    filesUploaded?: FileMetadataUpdateManyWithoutUploadedByNestedInput
    sessions?: SessionDataUpdateManyWithoutUserNestedInput
    mfaSettings?: MfaSettingsUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDelayEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    organizationId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutSubmittedByNestedInput
    evidence?: EvidenceUncheckedUpdateManyWithoutUploadedByNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutAssignedToNestedInput
    filesUploaded?: FileMetadataUncheckedUpdateManyWithoutUploadedByNestedInput
    sessions?: SessionDataUncheckedUpdateManyWithoutUserNestedInput
    mfaSettings?: MfaSettingsUncheckedUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClaimUpsertWithWhereUniqueWithoutDelayEventInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutDelayEventInput, ClaimUncheckedUpdateWithoutDelayEventInput>
    create: XOR<ClaimCreateWithoutDelayEventInput, ClaimUncheckedCreateWithoutDelayEventInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutDelayEventInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutDelayEventInput, ClaimUncheckedUpdateWithoutDelayEventInput>
  }

  export type ClaimUpdateManyWithWhereWithoutDelayEventInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutDelayEventInput>
  }

  export type EvidenceUpsertWithWhereUniqueWithoutDelayEventInput = {
    where: EvidenceWhereUniqueInput
    update: XOR<EvidenceUpdateWithoutDelayEventInput, EvidenceUncheckedUpdateWithoutDelayEventInput>
    create: XOR<EvidenceCreateWithoutDelayEventInput, EvidenceUncheckedCreateWithoutDelayEventInput>
  }

  export type EvidenceUpdateWithWhereUniqueWithoutDelayEventInput = {
    where: EvidenceWhereUniqueInput
    data: XOR<EvidenceUpdateWithoutDelayEventInput, EvidenceUncheckedUpdateWithoutDelayEventInput>
  }

  export type EvidenceUpdateManyWithWhereWithoutDelayEventInput = {
    where: EvidenceScalarWhereInput
    data: XOR<EvidenceUpdateManyMutationInput, EvidenceUncheckedUpdateManyWithoutDelayEventInput>
  }

  export type ProjectCreateWithoutClaimsInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    status?: $Enums.ProjectStatus
    contractValue?: Decimal | DecimalJsLike | number | string | null
    contractType?: $Enums.ContractType | null
    startDate: Date | string
    plannedCompletion?: Date | string | null
    currentCompletion?: Date | string | null
    healthScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    projectManager?: UserCreateNestedOneWithoutAssignedProjectsInput
    delayEvents?: DelayEventCreateNestedManyWithoutProjectInput
    actionItems?: ActionItemCreateNestedManyWithoutProjectInput
    schedules?: ScheduleCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutClaimsInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    organizationId: string
    status?: $Enums.ProjectStatus
    contractValue?: Decimal | DecimalJsLike | number | string | null
    contractType?: $Enums.ContractType | null
    startDate: Date | string
    plannedCompletion?: Date | string | null
    currentCompletion?: Date | string | null
    healthScore?: number | null
    projectManagerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    delayEvents?: DelayEventUncheckedCreateNestedManyWithoutProjectInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutProjectInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutClaimsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutClaimsInput, ProjectUncheckedCreateWithoutClaimsInput>
  }

  export type DelayEventCreateWithoutClaimsInput = {
    id?: string
    activityId?: string | null
    activityName: string
    detectionDate: Date | string
    delayDays: number
    causeType: $Enums.DelayType
    probabilityScore?: number | null
    evidenceStrength?: number | null
    status?: $Enums.DelayStatus
    description?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    criticalPath?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDelayEventsInput
    detectedBy: UserCreateNestedOneWithoutDelayEventsInput
    evidence?: EvidenceCreateNestedManyWithoutDelayEventInput
  }

  export type DelayEventUncheckedCreateWithoutClaimsInput = {
    id?: string
    projectId: string
    activityId?: string | null
    activityName: string
    detectionDate: Date | string
    delayDays: number
    causeType: $Enums.DelayType
    probabilityScore?: number | null
    evidenceStrength?: number | null
    status?: $Enums.DelayStatus
    description?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    criticalPath?: boolean
    detectedById: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evidence?: EvidenceUncheckedCreateNestedManyWithoutDelayEventInput
  }

  export type DelayEventCreateOrConnectWithoutClaimsInput = {
    where: DelayEventWhereUniqueInput
    create: XOR<DelayEventCreateWithoutClaimsInput, DelayEventUncheckedCreateWithoutClaimsInput>
  }

  export type UserCreateWithoutClaimsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUsersInput
    assignedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    delayEvents?: DelayEventCreateNestedManyWithoutDetectedByInput
    evidence?: EvidenceCreateNestedManyWithoutUploadedByInput
    actionItems?: ActionItemCreateNestedManyWithoutAssignedToInput
    filesUploaded?: FileMetadataCreateNestedManyWithoutUploadedByInput
    sessions?: SessionDataCreateNestedManyWithoutUserInput
    mfaSettings?: MfaSettingsCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClaimsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    organizationId: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    delayEvents?: DelayEventUncheckedCreateNestedManyWithoutDetectedByInput
    evidence?: EvidenceUncheckedCreateNestedManyWithoutUploadedByInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutAssignedToInput
    filesUploaded?: FileMetadataUncheckedCreateNestedManyWithoutUploadedByInput
    sessions?: SessionDataUncheckedCreateNestedManyWithoutUserInput
    mfaSettings?: MfaSettingsUncheckedCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClaimsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClaimsInput, UserUncheckedCreateWithoutClaimsInput>
  }

  export type EvidenceCreateWithoutClaimInput = {
    id?: string
    type: $Enums.EvidenceType
    title: string
    description?: string | null
    sourceSystem?: string | null
    filePath?: string | null
    relevanceScore?: number | null
    extractedText?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    delayEvent?: DelayEventCreateNestedOneWithoutEvidenceInput
    uploadedBy: UserCreateNestedOneWithoutEvidenceInput
    file?: FileMetadataCreateNestedOneWithoutEvidenceInput
  }

  export type EvidenceUncheckedCreateWithoutClaimInput = {
    id?: string
    delayEventId?: string | null
    type: $Enums.EvidenceType
    title: string
    description?: string | null
    sourceSystem?: string | null
    filePath?: string | null
    fileId?: string | null
    relevanceScore?: number | null
    extractedText?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploadedById: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvidenceCreateOrConnectWithoutClaimInput = {
    where: EvidenceWhereUniqueInput
    create: XOR<EvidenceCreateWithoutClaimInput, EvidenceUncheckedCreateWithoutClaimInput>
  }

  export type EvidenceCreateManyClaimInputEnvelope = {
    data: EvidenceCreateManyClaimInput | EvidenceCreateManyClaimInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutClaimsInput = {
    update: XOR<ProjectUpdateWithoutClaimsInput, ProjectUncheckedUpdateWithoutClaimsInput>
    create: XOR<ProjectCreateWithoutClaimsInput, ProjectUncheckedCreateWithoutClaimsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutClaimsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutClaimsInput, ProjectUncheckedUpdateWithoutClaimsInput>
  }

  export type ProjectUpdateWithoutClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    contractValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractType?: NullableEnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    projectManager?: UserUpdateOneWithoutAssignedProjectsNestedInput
    delayEvents?: DelayEventUpdateManyWithoutProjectNestedInput
    actionItems?: ActionItemUpdateManyWithoutProjectNestedInput
    schedules?: ScheduleUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    contractValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractType?: NullableEnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: NullableIntFieldUpdateOperationsInput | number | null
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delayEvents?: DelayEventUncheckedUpdateManyWithoutProjectNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutProjectNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type DelayEventUpsertWithoutClaimsInput = {
    update: XOR<DelayEventUpdateWithoutClaimsInput, DelayEventUncheckedUpdateWithoutClaimsInput>
    create: XOR<DelayEventCreateWithoutClaimsInput, DelayEventUncheckedCreateWithoutClaimsInput>
    where?: DelayEventWhereInput
  }

  export type DelayEventUpdateToOneWithWhereWithoutClaimsInput = {
    where?: DelayEventWhereInput
    data: XOR<DelayEventUpdateWithoutClaimsInput, DelayEventUncheckedUpdateWithoutClaimsInput>
  }

  export type DelayEventUpdateWithoutClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: StringFieldUpdateOperationsInput | string
    detectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    delayDays?: IntFieldUpdateOperationsInput | number
    causeType?: EnumDelayTypeFieldUpdateOperationsInput | $Enums.DelayType
    probabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    evidenceStrength?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDelayStatusFieldUpdateOperationsInput | $Enums.DelayStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    criticalPath?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDelayEventsNestedInput
    detectedBy?: UserUpdateOneRequiredWithoutDelayEventsNestedInput
    evidence?: EvidenceUpdateManyWithoutDelayEventNestedInput
  }

  export type DelayEventUncheckedUpdateWithoutClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: StringFieldUpdateOperationsInput | string
    detectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    delayDays?: IntFieldUpdateOperationsInput | number
    causeType?: EnumDelayTypeFieldUpdateOperationsInput | $Enums.DelayType
    probabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    evidenceStrength?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDelayStatusFieldUpdateOperationsInput | $Enums.DelayStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    criticalPath?: BoolFieldUpdateOperationsInput | boolean
    detectedById?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evidence?: EvidenceUncheckedUpdateManyWithoutDelayEventNestedInput
  }

  export type UserUpsertWithoutClaimsInput = {
    update: XOR<UserUpdateWithoutClaimsInput, UserUncheckedUpdateWithoutClaimsInput>
    create: XOR<UserCreateWithoutClaimsInput, UserUncheckedCreateWithoutClaimsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClaimsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClaimsInput, UserUncheckedUpdateWithoutClaimsInput>
  }

  export type UserUpdateWithoutClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    assignedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    delayEvents?: DelayEventUpdateManyWithoutDetectedByNestedInput
    evidence?: EvidenceUpdateManyWithoutUploadedByNestedInput
    actionItems?: ActionItemUpdateManyWithoutAssignedToNestedInput
    filesUploaded?: FileMetadataUpdateManyWithoutUploadedByNestedInput
    sessions?: SessionDataUpdateManyWithoutUserNestedInput
    mfaSettings?: MfaSettingsUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    organizationId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    delayEvents?: DelayEventUncheckedUpdateManyWithoutDetectedByNestedInput
    evidence?: EvidenceUncheckedUpdateManyWithoutUploadedByNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutAssignedToNestedInput
    filesUploaded?: FileMetadataUncheckedUpdateManyWithoutUploadedByNestedInput
    sessions?: SessionDataUncheckedUpdateManyWithoutUserNestedInput
    mfaSettings?: MfaSettingsUncheckedUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EvidenceUpsertWithWhereUniqueWithoutClaimInput = {
    where: EvidenceWhereUniqueInput
    update: XOR<EvidenceUpdateWithoutClaimInput, EvidenceUncheckedUpdateWithoutClaimInput>
    create: XOR<EvidenceCreateWithoutClaimInput, EvidenceUncheckedCreateWithoutClaimInput>
  }

  export type EvidenceUpdateWithWhereUniqueWithoutClaimInput = {
    where: EvidenceWhereUniqueInput
    data: XOR<EvidenceUpdateWithoutClaimInput, EvidenceUncheckedUpdateWithoutClaimInput>
  }

  export type EvidenceUpdateManyWithWhereWithoutClaimInput = {
    where: EvidenceScalarWhereInput
    data: XOR<EvidenceUpdateManyMutationInput, EvidenceUncheckedUpdateManyWithoutClaimInput>
  }

  export type DelayEventCreateWithoutEvidenceInput = {
    id?: string
    activityId?: string | null
    activityName: string
    detectionDate: Date | string
    delayDays: number
    causeType: $Enums.DelayType
    probabilityScore?: number | null
    evidenceStrength?: number | null
    status?: $Enums.DelayStatus
    description?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    criticalPath?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutDelayEventsInput
    detectedBy: UserCreateNestedOneWithoutDelayEventsInput
    claims?: ClaimCreateNestedManyWithoutDelayEventInput
  }

  export type DelayEventUncheckedCreateWithoutEvidenceInput = {
    id?: string
    projectId: string
    activityId?: string | null
    activityName: string
    detectionDate: Date | string
    delayDays: number
    causeType: $Enums.DelayType
    probabilityScore?: number | null
    evidenceStrength?: number | null
    status?: $Enums.DelayStatus
    description?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    criticalPath?: boolean
    detectedById: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    claims?: ClaimUncheckedCreateNestedManyWithoutDelayEventInput
  }

  export type DelayEventCreateOrConnectWithoutEvidenceInput = {
    where: DelayEventWhereUniqueInput
    create: XOR<DelayEventCreateWithoutEvidenceInput, DelayEventUncheckedCreateWithoutEvidenceInput>
  }

  export type ClaimCreateWithoutEvidenceInput = {
    id?: string
    referenceNumber: string
    title: string
    description?: string | null
    submissionDate?: Date | string | null
    noticeDate?: Date | string | null
    claimAmount?: Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: number | null
    status?: $Enums.ClaimStatus
    responseDueDate?: Date | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutClaimsInput
    delayEvent?: DelayEventCreateNestedOneWithoutClaimsInput
    submittedBy?: UserCreateNestedOneWithoutClaimsInput
  }

  export type ClaimUncheckedCreateWithoutEvidenceInput = {
    id?: string
    projectId: string
    delayEventId?: string | null
    referenceNumber: string
    title: string
    description?: string | null
    submissionDate?: Date | string | null
    noticeDate?: Date | string | null
    claimAmount?: Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: number | null
    status?: $Enums.ClaimStatus
    responseDueDate?: Date | string | null
    submittedById?: string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClaimCreateOrConnectWithoutEvidenceInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutEvidenceInput, ClaimUncheckedCreateWithoutEvidenceInput>
  }

  export type UserCreateWithoutEvidenceInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUsersInput
    assignedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    delayEvents?: DelayEventCreateNestedManyWithoutDetectedByInput
    claims?: ClaimCreateNestedManyWithoutSubmittedByInput
    actionItems?: ActionItemCreateNestedManyWithoutAssignedToInput
    filesUploaded?: FileMetadataCreateNestedManyWithoutUploadedByInput
    sessions?: SessionDataCreateNestedManyWithoutUserInput
    mfaSettings?: MfaSettingsCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEvidenceInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    organizationId: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    delayEvents?: DelayEventUncheckedCreateNestedManyWithoutDetectedByInput
    claims?: ClaimUncheckedCreateNestedManyWithoutSubmittedByInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutAssignedToInput
    filesUploaded?: FileMetadataUncheckedCreateNestedManyWithoutUploadedByInput
    sessions?: SessionDataUncheckedCreateNestedManyWithoutUserInput
    mfaSettings?: MfaSettingsUncheckedCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEvidenceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEvidenceInput, UserUncheckedCreateWithoutEvidenceInput>
  }

  export type FileMetadataCreateWithoutEvidenceInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint | number
    checksum?: string | null
    path: string
    isPublic?: boolean
    tags?: FileMetadataCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutFilesInput
    uploadedBy: UserCreateNestedOneWithoutFilesUploadedInput
    schedules?: ScheduleCreateNestedManyWithoutFileInput
  }

  export type FileMetadataUncheckedCreateWithoutEvidenceInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint | number
    checksum?: string | null
    organizationId: string
    uploadedById: string
    path: string
    isPublic?: boolean
    tags?: FileMetadataCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    schedules?: ScheduleUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileMetadataCreateOrConnectWithoutEvidenceInput = {
    where: FileMetadataWhereUniqueInput
    create: XOR<FileMetadataCreateWithoutEvidenceInput, FileMetadataUncheckedCreateWithoutEvidenceInput>
  }

  export type DelayEventUpsertWithoutEvidenceInput = {
    update: XOR<DelayEventUpdateWithoutEvidenceInput, DelayEventUncheckedUpdateWithoutEvidenceInput>
    create: XOR<DelayEventCreateWithoutEvidenceInput, DelayEventUncheckedCreateWithoutEvidenceInput>
    where?: DelayEventWhereInput
  }

  export type DelayEventUpdateToOneWithWhereWithoutEvidenceInput = {
    where?: DelayEventWhereInput
    data: XOR<DelayEventUpdateWithoutEvidenceInput, DelayEventUncheckedUpdateWithoutEvidenceInput>
  }

  export type DelayEventUpdateWithoutEvidenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: StringFieldUpdateOperationsInput | string
    detectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    delayDays?: IntFieldUpdateOperationsInput | number
    causeType?: EnumDelayTypeFieldUpdateOperationsInput | $Enums.DelayType
    probabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    evidenceStrength?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDelayStatusFieldUpdateOperationsInput | $Enums.DelayStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    criticalPath?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDelayEventsNestedInput
    detectedBy?: UserUpdateOneRequiredWithoutDelayEventsNestedInput
    claims?: ClaimUpdateManyWithoutDelayEventNestedInput
  }

  export type DelayEventUncheckedUpdateWithoutEvidenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: StringFieldUpdateOperationsInput | string
    detectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    delayDays?: IntFieldUpdateOperationsInput | number
    causeType?: EnumDelayTypeFieldUpdateOperationsInput | $Enums.DelayType
    probabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    evidenceStrength?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDelayStatusFieldUpdateOperationsInput | $Enums.DelayStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    criticalPath?: BoolFieldUpdateOperationsInput | boolean
    detectedById?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claims?: ClaimUncheckedUpdateManyWithoutDelayEventNestedInput
  }

  export type ClaimUpsertWithoutEvidenceInput = {
    update: XOR<ClaimUpdateWithoutEvidenceInput, ClaimUncheckedUpdateWithoutEvidenceInput>
    create: XOR<ClaimCreateWithoutEvidenceInput, ClaimUncheckedCreateWithoutEvidenceInput>
    where?: ClaimWhereInput
  }

  export type ClaimUpdateToOneWithWhereWithoutEvidenceInput = {
    where?: ClaimWhereInput
    data: XOR<ClaimUpdateWithoutEvidenceInput, ClaimUncheckedUpdateWithoutEvidenceInput>
  }

  export type ClaimUpdateWithoutEvidenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noticeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    responseDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutClaimsNestedInput
    delayEvent?: DelayEventUpdateOneWithoutClaimsNestedInput
    submittedBy?: UserUpdateOneWithoutClaimsNestedInput
  }

  export type ClaimUncheckedUpdateWithoutEvidenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    delayEventId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noticeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    responseDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedById?: NullableStringFieldUpdateOperationsInput | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutEvidenceInput = {
    update: XOR<UserUpdateWithoutEvidenceInput, UserUncheckedUpdateWithoutEvidenceInput>
    create: XOR<UserCreateWithoutEvidenceInput, UserUncheckedCreateWithoutEvidenceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEvidenceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEvidenceInput, UserUncheckedUpdateWithoutEvidenceInput>
  }

  export type UserUpdateWithoutEvidenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    assignedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    delayEvents?: DelayEventUpdateManyWithoutDetectedByNestedInput
    claims?: ClaimUpdateManyWithoutSubmittedByNestedInput
    actionItems?: ActionItemUpdateManyWithoutAssignedToNestedInput
    filesUploaded?: FileMetadataUpdateManyWithoutUploadedByNestedInput
    sessions?: SessionDataUpdateManyWithoutUserNestedInput
    mfaSettings?: MfaSettingsUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEvidenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    organizationId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    delayEvents?: DelayEventUncheckedUpdateManyWithoutDetectedByNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutSubmittedByNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutAssignedToNestedInput
    filesUploaded?: FileMetadataUncheckedUpdateManyWithoutUploadedByNestedInput
    sessions?: SessionDataUncheckedUpdateManyWithoutUserNestedInput
    mfaSettings?: MfaSettingsUncheckedUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FileMetadataUpsertWithoutEvidenceInput = {
    update: XOR<FileMetadataUpdateWithoutEvidenceInput, FileMetadataUncheckedUpdateWithoutEvidenceInput>
    create: XOR<FileMetadataCreateWithoutEvidenceInput, FileMetadataUncheckedCreateWithoutEvidenceInput>
    where?: FileMetadataWhereInput
  }

  export type FileMetadataUpdateToOneWithWhereWithoutEvidenceInput = {
    where?: FileMetadataWhereInput
    data: XOR<FileMetadataUpdateWithoutEvidenceInput, FileMetadataUncheckedUpdateWithoutEvidenceInput>
  }

  export type FileMetadataUpdateWithoutEvidenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: FileMetadataUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutFilesNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutFilesUploadedNestedInput
    schedules?: ScheduleUpdateManyWithoutFileNestedInput
  }

  export type FileMetadataUncheckedUpdateWithoutEvidenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: FileMetadataUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedules?: ScheduleUncheckedUpdateManyWithoutFileNestedInput
  }

  export type ProjectCreateWithoutSchedulesInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    status?: $Enums.ProjectStatus
    contractValue?: Decimal | DecimalJsLike | number | string | null
    contractType?: $Enums.ContractType | null
    startDate: Date | string
    plannedCompletion?: Date | string | null
    currentCompletion?: Date | string | null
    healthScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    projectManager?: UserCreateNestedOneWithoutAssignedProjectsInput
    delayEvents?: DelayEventCreateNestedManyWithoutProjectInput
    claims?: ClaimCreateNestedManyWithoutProjectInput
    actionItems?: ActionItemCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSchedulesInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    organizationId: string
    status?: $Enums.ProjectStatus
    contractValue?: Decimal | DecimalJsLike | number | string | null
    contractType?: $Enums.ContractType | null
    startDate: Date | string
    plannedCompletion?: Date | string | null
    currentCompletion?: Date | string | null
    healthScore?: number | null
    projectManagerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    delayEvents?: DelayEventUncheckedCreateNestedManyWithoutProjectInput
    claims?: ClaimUncheckedCreateNestedManyWithoutProjectInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSchedulesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSchedulesInput, ProjectUncheckedCreateWithoutSchedulesInput>
  }

  export type FileMetadataCreateWithoutSchedulesInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint | number
    checksum?: string | null
    path: string
    isPublic?: boolean
    tags?: FileMetadataCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutFilesInput
    uploadedBy: UserCreateNestedOneWithoutFilesUploadedInput
    evidence?: EvidenceCreateNestedManyWithoutFileInput
  }

  export type FileMetadataUncheckedCreateWithoutSchedulesInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint | number
    checksum?: string | null
    organizationId: string
    uploadedById: string
    path: string
    isPublic?: boolean
    tags?: FileMetadataCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evidence?: EvidenceUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileMetadataCreateOrConnectWithoutSchedulesInput = {
    where: FileMetadataWhereUniqueInput
    create: XOR<FileMetadataCreateWithoutSchedulesInput, FileMetadataUncheckedCreateWithoutSchedulesInput>
  }

  export type ProjectUpsertWithoutSchedulesInput = {
    update: XOR<ProjectUpdateWithoutSchedulesInput, ProjectUncheckedUpdateWithoutSchedulesInput>
    create: XOR<ProjectCreateWithoutSchedulesInput, ProjectUncheckedCreateWithoutSchedulesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSchedulesInput, ProjectUncheckedUpdateWithoutSchedulesInput>
  }

  export type ProjectUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    contractValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractType?: NullableEnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    projectManager?: UserUpdateOneWithoutAssignedProjectsNestedInput
    delayEvents?: DelayEventUpdateManyWithoutProjectNestedInput
    claims?: ClaimUpdateManyWithoutProjectNestedInput
    actionItems?: ActionItemUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    contractValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractType?: NullableEnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: NullableIntFieldUpdateOperationsInput | number | null
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delayEvents?: DelayEventUncheckedUpdateManyWithoutProjectNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutProjectNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type FileMetadataUpsertWithoutSchedulesInput = {
    update: XOR<FileMetadataUpdateWithoutSchedulesInput, FileMetadataUncheckedUpdateWithoutSchedulesInput>
    create: XOR<FileMetadataCreateWithoutSchedulesInput, FileMetadataUncheckedCreateWithoutSchedulesInput>
    where?: FileMetadataWhereInput
  }

  export type FileMetadataUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: FileMetadataWhereInput
    data: XOR<FileMetadataUpdateWithoutSchedulesInput, FileMetadataUncheckedUpdateWithoutSchedulesInput>
  }

  export type FileMetadataUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: FileMetadataUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutFilesNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutFilesUploadedNestedInput
    evidence?: EvidenceUpdateManyWithoutFileNestedInput
  }

  export type FileMetadataUncheckedUpdateWithoutSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: FileMetadataUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evidence?: EvidenceUncheckedUpdateManyWithoutFileNestedInput
  }

  export type ProjectCreateWithoutActionItemsInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    status?: $Enums.ProjectStatus
    contractValue?: Decimal | DecimalJsLike | number | string | null
    contractType?: $Enums.ContractType | null
    startDate: Date | string
    plannedCompletion?: Date | string | null
    currentCompletion?: Date | string | null
    healthScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutProjectsInput
    projectManager?: UserCreateNestedOneWithoutAssignedProjectsInput
    delayEvents?: DelayEventCreateNestedManyWithoutProjectInput
    claims?: ClaimCreateNestedManyWithoutProjectInput
    schedules?: ScheduleCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutActionItemsInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    organizationId: string
    status?: $Enums.ProjectStatus
    contractValue?: Decimal | DecimalJsLike | number | string | null
    contractType?: $Enums.ContractType | null
    startDate: Date | string
    plannedCompletion?: Date | string | null
    currentCompletion?: Date | string | null
    healthScore?: number | null
    projectManagerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    delayEvents?: DelayEventUncheckedCreateNestedManyWithoutProjectInput
    claims?: ClaimUncheckedCreateNestedManyWithoutProjectInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutActionItemsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutActionItemsInput, ProjectUncheckedCreateWithoutActionItemsInput>
  }

  export type UserCreateWithoutActionItemsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUsersInput
    assignedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    delayEvents?: DelayEventCreateNestedManyWithoutDetectedByInput
    claims?: ClaimCreateNestedManyWithoutSubmittedByInput
    evidence?: EvidenceCreateNestedManyWithoutUploadedByInput
    filesUploaded?: FileMetadataCreateNestedManyWithoutUploadedByInput
    sessions?: SessionDataCreateNestedManyWithoutUserInput
    mfaSettings?: MfaSettingsCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActionItemsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    organizationId: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    delayEvents?: DelayEventUncheckedCreateNestedManyWithoutDetectedByInput
    claims?: ClaimUncheckedCreateNestedManyWithoutSubmittedByInput
    evidence?: EvidenceUncheckedCreateNestedManyWithoutUploadedByInput
    filesUploaded?: FileMetadataUncheckedCreateNestedManyWithoutUploadedByInput
    sessions?: SessionDataUncheckedCreateNestedManyWithoutUserInput
    mfaSettings?: MfaSettingsUncheckedCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActionItemsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActionItemsInput, UserUncheckedCreateWithoutActionItemsInput>
  }

  export type ProjectUpsertWithoutActionItemsInput = {
    update: XOR<ProjectUpdateWithoutActionItemsInput, ProjectUncheckedUpdateWithoutActionItemsInput>
    create: XOR<ProjectCreateWithoutActionItemsInput, ProjectUncheckedCreateWithoutActionItemsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutActionItemsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutActionItemsInput, ProjectUncheckedUpdateWithoutActionItemsInput>
  }

  export type ProjectUpdateWithoutActionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    contractValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractType?: NullableEnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    projectManager?: UserUpdateOneWithoutAssignedProjectsNestedInput
    delayEvents?: DelayEventUpdateManyWithoutProjectNestedInput
    claims?: ClaimUpdateManyWithoutProjectNestedInput
    schedules?: ScheduleUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutActionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    contractValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractType?: NullableEnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: NullableIntFieldUpdateOperationsInput | number | null
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delayEvents?: DelayEventUncheckedUpdateManyWithoutProjectNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutProjectNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutActionItemsInput = {
    update: XOR<UserUpdateWithoutActionItemsInput, UserUncheckedUpdateWithoutActionItemsInput>
    create: XOR<UserCreateWithoutActionItemsInput, UserUncheckedCreateWithoutActionItemsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActionItemsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActionItemsInput, UserUncheckedUpdateWithoutActionItemsInput>
  }

  export type UserUpdateWithoutActionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    assignedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    delayEvents?: DelayEventUpdateManyWithoutDetectedByNestedInput
    claims?: ClaimUpdateManyWithoutSubmittedByNestedInput
    evidence?: EvidenceUpdateManyWithoutUploadedByNestedInput
    filesUploaded?: FileMetadataUpdateManyWithoutUploadedByNestedInput
    sessions?: SessionDataUpdateManyWithoutUserNestedInput
    mfaSettings?: MfaSettingsUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    organizationId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    delayEvents?: DelayEventUncheckedUpdateManyWithoutDetectedByNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutSubmittedByNestedInput
    evidence?: EvidenceUncheckedUpdateManyWithoutUploadedByNestedInput
    filesUploaded?: FileMetadataUncheckedUpdateManyWithoutUploadedByNestedInput
    sessions?: SessionDataUncheckedUpdateManyWithoutUserNestedInput
    mfaSettings?: MfaSettingsUncheckedUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutFilesInput = {
    id?: string
    name: string
    domain: string
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput
    events?: AnalyticsEventCreateNestedManyWithoutOrganizationInput
    quotas?: StorageQuotaCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutFilesInput = {
    id?: string
    name: string
    domain: string
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput
    events?: AnalyticsEventUncheckedCreateNestedManyWithoutOrganizationInput
    quotas?: StorageQuotaUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutFilesInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutFilesInput, OrganizationUncheckedCreateWithoutFilesInput>
  }

  export type UserCreateWithoutFilesUploadedInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUsersInput
    assignedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    delayEvents?: DelayEventCreateNestedManyWithoutDetectedByInput
    claims?: ClaimCreateNestedManyWithoutSubmittedByInput
    evidence?: EvidenceCreateNestedManyWithoutUploadedByInput
    actionItems?: ActionItemCreateNestedManyWithoutAssignedToInput
    sessions?: SessionDataCreateNestedManyWithoutUserInput
    mfaSettings?: MfaSettingsCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFilesUploadedInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    organizationId: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    delayEvents?: DelayEventUncheckedCreateNestedManyWithoutDetectedByInput
    claims?: ClaimUncheckedCreateNestedManyWithoutSubmittedByInput
    evidence?: EvidenceUncheckedCreateNestedManyWithoutUploadedByInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutAssignedToInput
    sessions?: SessionDataUncheckedCreateNestedManyWithoutUserInput
    mfaSettings?: MfaSettingsUncheckedCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFilesUploadedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFilesUploadedInput, UserUncheckedCreateWithoutFilesUploadedInput>
  }

  export type EvidenceCreateWithoutFileInput = {
    id?: string
    type: $Enums.EvidenceType
    title: string
    description?: string | null
    sourceSystem?: string | null
    filePath?: string | null
    relevanceScore?: number | null
    extractedText?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    delayEvent?: DelayEventCreateNestedOneWithoutEvidenceInput
    claim?: ClaimCreateNestedOneWithoutEvidenceInput
    uploadedBy: UserCreateNestedOneWithoutEvidenceInput
  }

  export type EvidenceUncheckedCreateWithoutFileInput = {
    id?: string
    delayEventId?: string | null
    claimId?: string | null
    type: $Enums.EvidenceType
    title: string
    description?: string | null
    sourceSystem?: string | null
    filePath?: string | null
    relevanceScore?: number | null
    extractedText?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploadedById: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvidenceCreateOrConnectWithoutFileInput = {
    where: EvidenceWhereUniqueInput
    create: XOR<EvidenceCreateWithoutFileInput, EvidenceUncheckedCreateWithoutFileInput>
  }

  export type EvidenceCreateManyFileInputEnvelope = {
    data: EvidenceCreateManyFileInput | EvidenceCreateManyFileInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleCreateWithoutFileInput = {
    id?: string
    name: string
    description?: string | null
    format: $Enums.ScheduleFormat
    version?: string | null
    baselineDate?: Date | string | null
    statusDate?: Date | string | null
    filePath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isBaseline?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutSchedulesInput
  }

  export type ScheduleUncheckedCreateWithoutFileInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    format: $Enums.ScheduleFormat
    version?: string | null
    baselineDate?: Date | string | null
    statusDate?: Date | string | null
    filePath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isBaseline?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateOrConnectWithoutFileInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutFileInput, ScheduleUncheckedCreateWithoutFileInput>
  }

  export type ScheduleCreateManyFileInputEnvelope = {
    data: ScheduleCreateManyFileInput | ScheduleCreateManyFileInput[]
    skipDuplicates?: boolean
  }

  export type OrganizationUpsertWithoutFilesInput = {
    update: XOR<OrganizationUpdateWithoutFilesInput, OrganizationUncheckedUpdateWithoutFilesInput>
    create: XOR<OrganizationCreateWithoutFilesInput, OrganizationUncheckedCreateWithoutFilesInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutFilesInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutFilesInput, OrganizationUncheckedUpdateWithoutFilesInput>
  }

  export type OrganizationUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput
    events?: AnalyticsEventUpdateManyWithoutOrganizationNestedInput
    quotas?: StorageQuotaUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput
    events?: AnalyticsEventUncheckedUpdateManyWithoutOrganizationNestedInput
    quotas?: StorageQuotaUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutFilesUploadedInput = {
    update: XOR<UserUpdateWithoutFilesUploadedInput, UserUncheckedUpdateWithoutFilesUploadedInput>
    create: XOR<UserCreateWithoutFilesUploadedInput, UserUncheckedCreateWithoutFilesUploadedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFilesUploadedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFilesUploadedInput, UserUncheckedUpdateWithoutFilesUploadedInput>
  }

  export type UserUpdateWithoutFilesUploadedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    assignedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    delayEvents?: DelayEventUpdateManyWithoutDetectedByNestedInput
    claims?: ClaimUpdateManyWithoutSubmittedByNestedInput
    evidence?: EvidenceUpdateManyWithoutUploadedByNestedInput
    actionItems?: ActionItemUpdateManyWithoutAssignedToNestedInput
    sessions?: SessionDataUpdateManyWithoutUserNestedInput
    mfaSettings?: MfaSettingsUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFilesUploadedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    organizationId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    delayEvents?: DelayEventUncheckedUpdateManyWithoutDetectedByNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutSubmittedByNestedInput
    evidence?: EvidenceUncheckedUpdateManyWithoutUploadedByNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutAssignedToNestedInput
    sessions?: SessionDataUncheckedUpdateManyWithoutUserNestedInput
    mfaSettings?: MfaSettingsUncheckedUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EvidenceUpsertWithWhereUniqueWithoutFileInput = {
    where: EvidenceWhereUniqueInput
    update: XOR<EvidenceUpdateWithoutFileInput, EvidenceUncheckedUpdateWithoutFileInput>
    create: XOR<EvidenceCreateWithoutFileInput, EvidenceUncheckedCreateWithoutFileInput>
  }

  export type EvidenceUpdateWithWhereUniqueWithoutFileInput = {
    where: EvidenceWhereUniqueInput
    data: XOR<EvidenceUpdateWithoutFileInput, EvidenceUncheckedUpdateWithoutFileInput>
  }

  export type EvidenceUpdateManyWithWhereWithoutFileInput = {
    where: EvidenceScalarWhereInput
    data: XOR<EvidenceUpdateManyMutationInput, EvidenceUncheckedUpdateManyWithoutFileInput>
  }

  export type ScheduleUpsertWithWhereUniqueWithoutFileInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutFileInput, ScheduleUncheckedUpdateWithoutFileInput>
    create: XOR<ScheduleCreateWithoutFileInput, ScheduleUncheckedCreateWithoutFileInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutFileInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutFileInput, ScheduleUncheckedUpdateWithoutFileInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutFileInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutFileInput>
  }

  export type OrganizationCreateWithoutQuotasInput = {
    id?: string
    name: string
    domain: string
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    files?: FileMetadataCreateNestedManyWithoutOrganizationInput
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput
    events?: AnalyticsEventCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutQuotasInput = {
    id?: string
    name: string
    domain: string
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    files?: FileMetadataUncheckedCreateNestedManyWithoutOrganizationInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput
    events?: AnalyticsEventUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutQuotasInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutQuotasInput, OrganizationUncheckedCreateWithoutQuotasInput>
  }

  export type OrganizationUpsertWithoutQuotasInput = {
    update: XOR<OrganizationUpdateWithoutQuotasInput, OrganizationUncheckedUpdateWithoutQuotasInput>
    create: XOR<OrganizationCreateWithoutQuotasInput, OrganizationUncheckedCreateWithoutQuotasInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutQuotasInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutQuotasInput, OrganizationUncheckedUpdateWithoutQuotasInput>
  }

  export type OrganizationUpdateWithoutQuotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    files?: FileMetadataUpdateManyWithoutOrganizationNestedInput
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput
    events?: AnalyticsEventUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutQuotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    files?: FileMetadataUncheckedUpdateManyWithoutOrganizationNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput
    events?: AnalyticsEventUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUsersInput
    assignedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    delayEvents?: DelayEventCreateNestedManyWithoutDetectedByInput
    claims?: ClaimCreateNestedManyWithoutSubmittedByInput
    evidence?: EvidenceCreateNestedManyWithoutUploadedByInput
    actionItems?: ActionItemCreateNestedManyWithoutAssignedToInput
    filesUploaded?: FileMetadataCreateNestedManyWithoutUploadedByInput
    mfaSettings?: MfaSettingsCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    organizationId: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    delayEvents?: DelayEventUncheckedCreateNestedManyWithoutDetectedByInput
    claims?: ClaimUncheckedCreateNestedManyWithoutSubmittedByInput
    evidence?: EvidenceUncheckedCreateNestedManyWithoutUploadedByInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutAssignedToInput
    filesUploaded?: FileMetadataUncheckedCreateNestedManyWithoutUploadedByInput
    mfaSettings?: MfaSettingsUncheckedCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    assignedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    delayEvents?: DelayEventUpdateManyWithoutDetectedByNestedInput
    claims?: ClaimUpdateManyWithoutSubmittedByNestedInput
    evidence?: EvidenceUpdateManyWithoutUploadedByNestedInput
    actionItems?: ActionItemUpdateManyWithoutAssignedToNestedInput
    filesUploaded?: FileMetadataUpdateManyWithoutUploadedByNestedInput
    mfaSettings?: MfaSettingsUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    organizationId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    delayEvents?: DelayEventUncheckedUpdateManyWithoutDetectedByNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutSubmittedByNestedInput
    evidence?: EvidenceUncheckedUpdateManyWithoutUploadedByNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutAssignedToNestedInput
    filesUploaded?: FileMetadataUncheckedUpdateManyWithoutUploadedByNestedInput
    mfaSettings?: MfaSettingsUncheckedUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMfaSettingsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUsersInput
    assignedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    delayEvents?: DelayEventCreateNestedManyWithoutDetectedByInput
    claims?: ClaimCreateNestedManyWithoutSubmittedByInput
    evidence?: EvidenceCreateNestedManyWithoutUploadedByInput
    actionItems?: ActionItemCreateNestedManyWithoutAssignedToInput
    filesUploaded?: FileMetadataCreateNestedManyWithoutUploadedByInput
    sessions?: SessionDataCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMfaSettingsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    organizationId: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    delayEvents?: DelayEventUncheckedCreateNestedManyWithoutDetectedByInput
    claims?: ClaimUncheckedCreateNestedManyWithoutSubmittedByInput
    evidence?: EvidenceUncheckedCreateNestedManyWithoutUploadedByInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutAssignedToInput
    filesUploaded?: FileMetadataUncheckedCreateNestedManyWithoutUploadedByInput
    sessions?: SessionDataUncheckedCreateNestedManyWithoutUserInput
    passwordResets?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMfaSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMfaSettingsInput, UserUncheckedCreateWithoutMfaSettingsInput>
  }

  export type UserUpsertWithoutMfaSettingsInput = {
    update: XOR<UserUpdateWithoutMfaSettingsInput, UserUncheckedUpdateWithoutMfaSettingsInput>
    create: XOR<UserCreateWithoutMfaSettingsInput, UserUncheckedCreateWithoutMfaSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMfaSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMfaSettingsInput, UserUncheckedUpdateWithoutMfaSettingsInput>
  }

  export type UserUpdateWithoutMfaSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    assignedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    delayEvents?: DelayEventUpdateManyWithoutDetectedByNestedInput
    claims?: ClaimUpdateManyWithoutSubmittedByNestedInput
    evidence?: EvidenceUpdateManyWithoutUploadedByNestedInput
    actionItems?: ActionItemUpdateManyWithoutAssignedToNestedInput
    filesUploaded?: FileMetadataUpdateManyWithoutUploadedByNestedInput
    sessions?: SessionDataUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMfaSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    organizationId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    delayEvents?: DelayEventUncheckedUpdateManyWithoutDetectedByNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutSubmittedByNestedInput
    evidence?: EvidenceUncheckedUpdateManyWithoutUploadedByNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutAssignedToNestedInput
    filesUploaded?: FileMetadataUncheckedUpdateManyWithoutUploadedByNestedInput
    sessions?: SessionDataUncheckedUpdateManyWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutPasswordResetsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUsersInput
    assignedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    delayEvents?: DelayEventCreateNestedManyWithoutDetectedByInput
    claims?: ClaimCreateNestedManyWithoutSubmittedByInput
    evidence?: EvidenceCreateNestedManyWithoutUploadedByInput
    actionItems?: ActionItemCreateNestedManyWithoutAssignedToInput
    filesUploaded?: FileMetadataCreateNestedManyWithoutUploadedByInput
    sessions?: SessionDataCreateNestedManyWithoutUserInput
    mfaSettings?: MfaSettingsCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordResetsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    organizationId: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    delayEvents?: DelayEventUncheckedCreateNestedManyWithoutDetectedByInput
    claims?: ClaimUncheckedCreateNestedManyWithoutSubmittedByInput
    evidence?: EvidenceUncheckedCreateNestedManyWithoutUploadedByInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutAssignedToInput
    filesUploaded?: FileMetadataUncheckedCreateNestedManyWithoutUploadedByInput
    sessions?: SessionDataUncheckedCreateNestedManyWithoutUserInput
    mfaSettings?: MfaSettingsUncheckedCreateNestedOneWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordResetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
  }

  export type UserUpsertWithoutPasswordResetsInput = {
    update: XOR<UserUpdateWithoutPasswordResetsInput, UserUncheckedUpdateWithoutPasswordResetsInput>
    create: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetsInput, UserUncheckedUpdateWithoutPasswordResetsInput>
  }

  export type UserUpdateWithoutPasswordResetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    assignedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    delayEvents?: DelayEventUpdateManyWithoutDetectedByNestedInput
    claims?: ClaimUpdateManyWithoutSubmittedByNestedInput
    evidence?: EvidenceUpdateManyWithoutUploadedByNestedInput
    actionItems?: ActionItemUpdateManyWithoutAssignedToNestedInput
    filesUploaded?: FileMetadataUpdateManyWithoutUploadedByNestedInput
    sessions?: SessionDataUpdateManyWithoutUserNestedInput
    mfaSettings?: MfaSettingsUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    organizationId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    delayEvents?: DelayEventUncheckedUpdateManyWithoutDetectedByNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutSubmittedByNestedInput
    evidence?: EvidenceUncheckedUpdateManyWithoutUploadedByNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutAssignedToNestedInput
    filesUploaded?: FileMetadataUncheckedUpdateManyWithoutUploadedByNestedInput
    sessions?: SessionDataUncheckedUpdateManyWithoutUserNestedInput
    mfaSettings?: MfaSettingsUncheckedUpdateOneWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutEventsInput = {
    id?: string
    name: string
    domain: string
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    files?: FileMetadataCreateNestedManyWithoutOrganizationInput
    auditLogs?: AuditLogCreateNestedManyWithoutOrganizationInput
    quotas?: StorageQuotaCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutEventsInput = {
    id?: string
    name: string
    domain: string
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    files?: FileMetadataUncheckedCreateNestedManyWithoutOrganizationInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutOrganizationInput
    quotas?: StorageQuotaUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutEventsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutEventsInput, OrganizationUncheckedCreateWithoutEventsInput>
  }

  export type OrganizationUpsertWithoutEventsInput = {
    update: XOR<OrganizationUpdateWithoutEventsInput, OrganizationUncheckedUpdateWithoutEventsInput>
    create: XOR<OrganizationCreateWithoutEventsInput, OrganizationUncheckedCreateWithoutEventsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutEventsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutEventsInput, OrganizationUncheckedUpdateWithoutEventsInput>
  }

  export type OrganizationUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    files?: FileMetadataUpdateManyWithoutOrganizationNestedInput
    auditLogs?: AuditLogUpdateManyWithoutOrganizationNestedInput
    quotas?: StorageQuotaUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    files?: FileMetadataUncheckedUpdateManyWithoutOrganizationNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutOrganizationNestedInput
    quotas?: StorageQuotaUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutUsersInput
    assignedProjects?: ProjectCreateNestedManyWithoutProjectManagerInput
    delayEvents?: DelayEventCreateNestedManyWithoutDetectedByInput
    claims?: ClaimCreateNestedManyWithoutSubmittedByInput
    evidence?: EvidenceCreateNestedManyWithoutUploadedByInput
    actionItems?: ActionItemCreateNestedManyWithoutAssignedToInput
    filesUploaded?: FileMetadataCreateNestedManyWithoutUploadedByInput
    sessions?: SessionDataCreateNestedManyWithoutUserInput
    mfaSettings?: MfaSettingsCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetTokenCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    organizationId: string
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedProjects?: ProjectUncheckedCreateNestedManyWithoutProjectManagerInput
    delayEvents?: DelayEventUncheckedCreateNestedManyWithoutDetectedByInput
    claims?: ClaimUncheckedCreateNestedManyWithoutSubmittedByInput
    evidence?: EvidenceUncheckedCreateNestedManyWithoutUploadedByInput
    actionItems?: ActionItemUncheckedCreateNestedManyWithoutAssignedToInput
    filesUploaded?: FileMetadataUncheckedCreateNestedManyWithoutUploadedByInput
    sessions?: SessionDataUncheckedCreateNestedManyWithoutUserInput
    mfaSettings?: MfaSettingsUncheckedCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type OrganizationCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    domain: string
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutOrganizationInput
    projects?: ProjectCreateNestedManyWithoutOrganizationInput
    files?: FileMetadataCreateNestedManyWithoutOrganizationInput
    events?: AnalyticsEventCreateNestedManyWithoutOrganizationInput
    quotas?: StorageQuotaCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    domain: string
    isActive?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    projects?: ProjectUncheckedCreateNestedManyWithoutOrganizationInput
    files?: FileMetadataUncheckedCreateNestedManyWithoutOrganizationInput
    events?: AnalyticsEventUncheckedCreateNestedManyWithoutOrganizationInput
    quotas?: StorageQuotaUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutAuditLogsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutAuditLogsInput, OrganizationUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    assignedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    delayEvents?: DelayEventUpdateManyWithoutDetectedByNestedInput
    claims?: ClaimUpdateManyWithoutSubmittedByNestedInput
    evidence?: EvidenceUpdateManyWithoutUploadedByNestedInput
    actionItems?: ActionItemUpdateManyWithoutAssignedToNestedInput
    filesUploaded?: FileMetadataUpdateManyWithoutUploadedByNestedInput
    sessions?: SessionDataUpdateManyWithoutUserNestedInput
    mfaSettings?: MfaSettingsUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    organizationId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    delayEvents?: DelayEventUncheckedUpdateManyWithoutDetectedByNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutSubmittedByNestedInput
    evidence?: EvidenceUncheckedUpdateManyWithoutUploadedByNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutAssignedToNestedInput
    filesUploaded?: FileMetadataUncheckedUpdateManyWithoutUploadedByNestedInput
    sessions?: SessionDataUncheckedUpdateManyWithoutUserNestedInput
    mfaSettings?: MfaSettingsUncheckedUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationUpsertWithoutAuditLogsInput = {
    update: XOR<OrganizationUpdateWithoutAuditLogsInput, OrganizationUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<OrganizationCreateWithoutAuditLogsInput, OrganizationUncheckedCreateWithoutAuditLogsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutAuditLogsInput, OrganizationUncheckedUpdateWithoutAuditLogsInput>
  }

  export type OrganizationUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUpdateManyWithoutOrganizationNestedInput
    files?: FileMetadataUpdateManyWithoutOrganizationNestedInput
    events?: AnalyticsEventUpdateManyWithoutOrganizationNestedInput
    quotas?: StorageQuotaUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutOrganizationNestedInput
    files?: FileMetadataUncheckedUpdateManyWithoutOrganizationNestedInput
    events?: AnalyticsEventUncheckedUpdateManyWithoutOrganizationNestedInput
    quotas?: StorageQuotaUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserCreateManyOrganizationInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLoginAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateManyOrganizationInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    status?: $Enums.ProjectStatus
    contractValue?: Decimal | DecimalJsLike | number | string | null
    contractType?: $Enums.ContractType | null
    startDate: Date | string
    plannedCompletion?: Date | string | null
    currentCompletion?: Date | string | null
    healthScore?: number | null
    projectManagerId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileMetadataCreateManyOrganizationInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint | number
    checksum?: string | null
    uploadedById: string
    path: string
    isPublic?: boolean
    tags?: FileMetadataCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyOrganizationInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    userId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsEventCreateManyOrganizationInput = {
    id?: string
    eventType: string
    userId?: string | null
    properties?: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type StorageQuotaCreateManyOrganizationInput = {
    id?: string
    usedBytes?: bigint | number
    limitBytes: bigint | number
    fileCount?: number
    maxFileCount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedProjects?: ProjectUpdateManyWithoutProjectManagerNestedInput
    delayEvents?: DelayEventUpdateManyWithoutDetectedByNestedInput
    claims?: ClaimUpdateManyWithoutSubmittedByNestedInput
    evidence?: EvidenceUpdateManyWithoutUploadedByNestedInput
    actionItems?: ActionItemUpdateManyWithoutAssignedToNestedInput
    filesUploaded?: FileMetadataUpdateManyWithoutUploadedByNestedInput
    sessions?: SessionDataUpdateManyWithoutUserNestedInput
    mfaSettings?: MfaSettingsUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedProjects?: ProjectUncheckedUpdateManyWithoutProjectManagerNestedInput
    delayEvents?: DelayEventUncheckedUpdateManyWithoutDetectedByNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutSubmittedByNestedInput
    evidence?: EvidenceUncheckedUpdateManyWithoutUploadedByNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutAssignedToNestedInput
    filesUploaded?: FileMetadataUncheckedUpdateManyWithoutUploadedByNestedInput
    sessions?: SessionDataUncheckedUpdateManyWithoutUserNestedInput
    mfaSettings?: MfaSettingsUncheckedUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    contractValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractType?: NullableEnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectManager?: UserUpdateOneWithoutAssignedProjectsNestedInput
    delayEvents?: DelayEventUpdateManyWithoutProjectNestedInput
    claims?: ClaimUpdateManyWithoutProjectNestedInput
    actionItems?: ActionItemUpdateManyWithoutProjectNestedInput
    schedules?: ScheduleUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    contractValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractType?: NullableEnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: NullableIntFieldUpdateOperationsInput | number | null
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delayEvents?: DelayEventUncheckedUpdateManyWithoutProjectNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutProjectNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutProjectNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    contractValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractType?: NullableEnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: NullableIntFieldUpdateOperationsInput | number | null
    projectManagerId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileMetadataUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: FileMetadataUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedBy?: UserUpdateOneRequiredWithoutFilesUploadedNestedInput
    evidence?: EvidenceUpdateManyWithoutFileNestedInput
    schedules?: ScheduleUpdateManyWithoutFileNestedInput
  }

  export type FileMetadataUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: FileMetadataUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evidence?: EvidenceUncheckedUpdateManyWithoutFileNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutFileNestedInput
  }

  export type FileMetadataUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedById?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: FileMetadataUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsEventUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageQuotaUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    limitBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    fileCount?: IntFieldUpdateOperationsInput | number
    maxFileCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageQuotaUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    limitBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    fileCount?: IntFieldUpdateOperationsInput | number
    maxFileCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StorageQuotaUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usedBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    limitBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    fileCount?: IntFieldUpdateOperationsInput | number
    maxFileCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateManyProjectManagerInput = {
    id?: string
    name: string
    description?: string | null
    location?: string | null
    organizationId: string
    status?: $Enums.ProjectStatus
    contractValue?: Decimal | DecimalJsLike | number | string | null
    contractType?: $Enums.ContractType | null
    startDate: Date | string
    plannedCompletion?: Date | string | null
    currentCompletion?: Date | string | null
    healthScore?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DelayEventCreateManyDetectedByInput = {
    id?: string
    projectId: string
    activityId?: string | null
    activityName: string
    detectionDate: Date | string
    delayDays: number
    causeType: $Enums.DelayType
    probabilityScore?: number | null
    evidenceStrength?: number | null
    status?: $Enums.DelayStatus
    description?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    criticalPath?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClaimCreateManySubmittedByInput = {
    id?: string
    projectId: string
    delayEventId?: string | null
    referenceNumber: string
    title: string
    description?: string | null
    submissionDate?: Date | string | null
    noticeDate?: Date | string | null
    claimAmount?: Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: number | null
    status?: $Enums.ClaimStatus
    responseDueDate?: Date | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvidenceCreateManyUploadedByInput = {
    id?: string
    delayEventId?: string | null
    claimId?: string | null
    type: $Enums.EvidenceType
    title: string
    description?: string | null
    sourceSystem?: string | null
    filePath?: string | null
    fileId?: string | null
    relevanceScore?: number | null
    extractedText?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionItemCreateManyAssignedToInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    dueDate: Date | string
    projectId: string
    status?: $Enums.ActionItemStatus
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileMetadataCreateManyUploadedByInput = {
    id?: string
    filename: string
    originalName: string
    mimeType: string
    size: bigint | number
    checksum?: string | null
    organizationId: string
    path: string
    isPublic?: boolean
    tags?: FileMetadataCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SessionDataCreateManyUserInput = {
    id?: string
    deviceInfo: JsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    lastActivityAt?: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PasswordResetTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    isUsed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    organizationId: string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ProjectUpdateWithoutProjectManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    contractValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractType?: NullableEnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutProjectsNestedInput
    delayEvents?: DelayEventUpdateManyWithoutProjectNestedInput
    claims?: ClaimUpdateManyWithoutProjectNestedInput
    actionItems?: ActionItemUpdateManyWithoutProjectNestedInput
    schedules?: ScheduleUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    contractValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractType?: NullableEnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delayEvents?: DelayEventUncheckedUpdateManyWithoutProjectNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutProjectNestedInput
    actionItems?: ActionItemUncheckedUpdateManyWithoutProjectNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutProjectManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    contractValue?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    contractType?: NullableEnumContractTypeFieldUpdateOperationsInput | $Enums.ContractType | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    plannedCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentCompletion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    healthScore?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DelayEventUpdateWithoutDetectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: StringFieldUpdateOperationsInput | string
    detectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    delayDays?: IntFieldUpdateOperationsInput | number
    causeType?: EnumDelayTypeFieldUpdateOperationsInput | $Enums.DelayType
    probabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    evidenceStrength?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDelayStatusFieldUpdateOperationsInput | $Enums.DelayStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    criticalPath?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutDelayEventsNestedInput
    claims?: ClaimUpdateManyWithoutDelayEventNestedInput
    evidence?: EvidenceUpdateManyWithoutDelayEventNestedInput
  }

  export type DelayEventUncheckedUpdateWithoutDetectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: StringFieldUpdateOperationsInput | string
    detectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    delayDays?: IntFieldUpdateOperationsInput | number
    causeType?: EnumDelayTypeFieldUpdateOperationsInput | $Enums.DelayType
    probabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    evidenceStrength?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDelayStatusFieldUpdateOperationsInput | $Enums.DelayStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    criticalPath?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claims?: ClaimUncheckedUpdateManyWithoutDelayEventNestedInput
    evidence?: EvidenceUncheckedUpdateManyWithoutDelayEventNestedInput
  }

  export type DelayEventUncheckedUpdateManyWithoutDetectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: StringFieldUpdateOperationsInput | string
    detectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    delayDays?: IntFieldUpdateOperationsInput | number
    causeType?: EnumDelayTypeFieldUpdateOperationsInput | $Enums.DelayType
    probabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    evidenceStrength?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDelayStatusFieldUpdateOperationsInput | $Enums.DelayStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    criticalPath?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimUpdateWithoutSubmittedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noticeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    responseDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutClaimsNestedInput
    delayEvent?: DelayEventUpdateOneWithoutClaimsNestedInput
    evidence?: EvidenceUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutSubmittedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    delayEventId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noticeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    responseDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evidence?: EvidenceUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateManyWithoutSubmittedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    delayEventId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noticeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    responseDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSystem?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delayEvent?: DelayEventUpdateOneWithoutEvidenceNestedInput
    claim?: ClaimUpdateOneWithoutEvidenceNestedInput
    file?: FileMetadataUpdateOneWithoutEvidenceNestedInput
  }

  export type EvidenceUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    delayEventId?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSystem?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    delayEventId?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSystem?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionItemUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumActionItemStatusFieldUpdateOperationsInput | $Enums.ActionItemStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutActionItemsNestedInput
  }

  export type ActionItemUncheckedUpdateWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    status?: EnumActionItemStatusFieldUpdateOperationsInput | $Enums.ActionItemStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionItemUncheckedUpdateManyWithoutAssignedToInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: StringFieldUpdateOperationsInput | string
    status?: EnumActionItemStatusFieldUpdateOperationsInput | $Enums.ActionItemStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileMetadataUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    path?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: FileMetadataUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutFilesNestedInput
    evidence?: EvidenceUpdateManyWithoutFileNestedInput
    schedules?: ScheduleUpdateManyWithoutFileNestedInput
  }

  export type FileMetadataUncheckedUpdateWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: FileMetadataUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evidence?: EvidenceUncheckedUpdateManyWithoutFileNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutFileNestedInput
  }

  export type FileMetadataUncheckedUpdateManyWithoutUploadedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: BigIntFieldUpdateOperationsInput | bigint | number
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    tags?: FileMetadataUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionDataUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceInfo?: JsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionDataUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceInfo?: JsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionDataUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceInfo?: JsonNullValueInput | InputJsonValue
    location?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivityAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isUsed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    organizationId?: StringFieldUpdateOperationsInput | string
    changes?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DelayEventCreateManyProjectInput = {
    id?: string
    activityId?: string | null
    activityName: string
    detectionDate: Date | string
    delayDays: number
    causeType: $Enums.DelayType
    probabilityScore?: number | null
    evidenceStrength?: number | null
    status?: $Enums.DelayStatus
    description?: string | null
    estimatedCost?: Decimal | DecimalJsLike | number | string | null
    criticalPath?: boolean
    detectedById: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClaimCreateManyProjectInput = {
    id?: string
    delayEventId?: string | null
    referenceNumber: string
    title: string
    description?: string | null
    submissionDate?: Date | string | null
    noticeDate?: Date | string | null
    claimAmount?: Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: number | null
    status?: $Enums.ClaimStatus
    responseDueDate?: Date | string | null
    submittedById?: string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ActionItemCreateManyProjectInput = {
    id?: string
    title: string
    description?: string | null
    priority?: $Enums.Priority
    dueDate: Date | string
    assignedToId: string
    status?: $Enums.ActionItemStatus
    completedAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateManyProjectInput = {
    id?: string
    name: string
    description?: string | null
    format: $Enums.ScheduleFormat
    version?: string | null
    baselineDate?: Date | string | null
    statusDate?: Date | string | null
    filePath?: string | null
    fileId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isBaseline?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DelayEventUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: StringFieldUpdateOperationsInput | string
    detectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    delayDays?: IntFieldUpdateOperationsInput | number
    causeType?: EnumDelayTypeFieldUpdateOperationsInput | $Enums.DelayType
    probabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    evidenceStrength?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDelayStatusFieldUpdateOperationsInput | $Enums.DelayStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    criticalPath?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    detectedBy?: UserUpdateOneRequiredWithoutDelayEventsNestedInput
    claims?: ClaimUpdateManyWithoutDelayEventNestedInput
    evidence?: EvidenceUpdateManyWithoutDelayEventNestedInput
  }

  export type DelayEventUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: StringFieldUpdateOperationsInput | string
    detectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    delayDays?: IntFieldUpdateOperationsInput | number
    causeType?: EnumDelayTypeFieldUpdateOperationsInput | $Enums.DelayType
    probabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    evidenceStrength?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDelayStatusFieldUpdateOperationsInput | $Enums.DelayStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    criticalPath?: BoolFieldUpdateOperationsInput | boolean
    detectedById?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claims?: ClaimUncheckedUpdateManyWithoutDelayEventNestedInput
    evidence?: EvidenceUncheckedUpdateManyWithoutDelayEventNestedInput
  }

  export type DelayEventUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    activityId?: NullableStringFieldUpdateOperationsInput | string | null
    activityName?: StringFieldUpdateOperationsInput | string
    detectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    delayDays?: IntFieldUpdateOperationsInput | number
    causeType?: EnumDelayTypeFieldUpdateOperationsInput | $Enums.DelayType
    probabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    evidenceStrength?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumDelayStatusFieldUpdateOperationsInput | $Enums.DelayStatus
    description?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    criticalPath?: BoolFieldUpdateOperationsInput | boolean
    detectedById?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noticeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    responseDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delayEvent?: DelayEventUpdateOneWithoutClaimsNestedInput
    submittedBy?: UserUpdateOneWithoutClaimsNestedInput
    evidence?: EvidenceUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    delayEventId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noticeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    responseDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedById?: NullableStringFieldUpdateOperationsInput | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evidence?: EvidenceUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    delayEventId?: NullableStringFieldUpdateOperationsInput | string | null
    referenceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noticeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    responseDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedById?: NullableStringFieldUpdateOperationsInput | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionItemUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumActionItemStatusFieldUpdateOperationsInput | $Enums.ActionItemStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedTo?: UserUpdateOneRequiredWithoutActionItemsNestedInput
  }

  export type ActionItemUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    status?: EnumActionItemStatusFieldUpdateOperationsInput | $Enums.ActionItemStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActionItemUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToId?: StringFieldUpdateOperationsInput | string
    status?: EnumActionItemStatusFieldUpdateOperationsInput | $Enums.ActionItemStatus
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumScheduleFormatFieldUpdateOperationsInput | $Enums.ScheduleFormat
    version?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isBaseline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: FileMetadataUpdateOneWithoutSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumScheduleFormatFieldUpdateOperationsInput | $Enums.ScheduleFormat
    version?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isBaseline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumScheduleFormatFieldUpdateOperationsInput | $Enums.ScheduleFormat
    version?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isBaseline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimCreateManyDelayEventInput = {
    id?: string
    projectId: string
    referenceNumber: string
    title: string
    description?: string | null
    submissionDate?: Date | string | null
    noticeDate?: Date | string | null
    claimAmount?: Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: number | null
    status?: $Enums.ClaimStatus
    responseDueDate?: Date | string | null
    submittedById?: string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvidenceCreateManyDelayEventInput = {
    id?: string
    claimId?: string | null
    type: $Enums.EvidenceType
    title: string
    description?: string | null
    sourceSystem?: string | null
    filePath?: string | null
    fileId?: string | null
    relevanceScore?: number | null
    extractedText?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploadedById: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClaimUpdateWithoutDelayEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noticeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    responseDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutClaimsNestedInput
    submittedBy?: UserUpdateOneWithoutClaimsNestedInput
    evidence?: EvidenceUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateWithoutDelayEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noticeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    responseDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedById?: NullableStringFieldUpdateOperationsInput | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evidence?: EvidenceUncheckedUpdateManyWithoutClaimNestedInput
  }

  export type ClaimUncheckedUpdateManyWithoutDelayEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    referenceNumber?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    submissionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    noticeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    timeImpactDays?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    responseDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submittedById?: NullableStringFieldUpdateOperationsInput | string | null
    workflow?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceUpdateWithoutDelayEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSystem?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claim?: ClaimUpdateOneWithoutEvidenceNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutEvidenceNestedInput
    file?: FileMetadataUpdateOneWithoutEvidenceNestedInput
  }

  export type EvidenceUncheckedUpdateWithoutDelayEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSystem?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploadedById?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceUncheckedUpdateManyWithoutDelayEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSystem?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploadedById?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceCreateManyClaimInput = {
    id?: string
    delayEventId?: string | null
    type: $Enums.EvidenceType
    title: string
    description?: string | null
    sourceSystem?: string | null
    filePath?: string | null
    fileId?: string | null
    relevanceScore?: number | null
    extractedText?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploadedById: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvidenceUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSystem?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delayEvent?: DelayEventUpdateOneWithoutEvidenceNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutEvidenceNestedInput
    file?: FileMetadataUpdateOneWithoutEvidenceNestedInput
  }

  export type EvidenceUncheckedUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    delayEventId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSystem?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploadedById?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceUncheckedUpdateManyWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    delayEventId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSystem?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploadedById?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceCreateManyFileInput = {
    id?: string
    delayEventId?: string | null
    claimId?: string | null
    type: $Enums.EvidenceType
    title: string
    description?: string | null
    sourceSystem?: string | null
    filePath?: string | null
    relevanceScore?: number | null
    extractedText?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploadedById: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleCreateManyFileInput = {
    id?: string
    projectId: string
    name: string
    description?: string | null
    format: $Enums.ScheduleFormat
    version?: string | null
    baselineDate?: Date | string | null
    statusDate?: Date | string | null
    filePath?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isBaseline?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EvidenceUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSystem?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    delayEvent?: DelayEventUpdateOneWithoutEvidenceNestedInput
    claim?: ClaimUpdateOneWithoutEvidenceNestedInput
    uploadedBy?: UserUpdateOneRequiredWithoutEvidenceNestedInput
  }

  export type EvidenceUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    delayEventId?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSystem?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploadedById?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceUncheckedUpdateManyWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    delayEventId?: NullableStringFieldUpdateOperationsInput | string | null
    claimId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumEvidenceTypeFieldUpdateOperationsInput | $Enums.EvidenceType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sourceSystem?: NullableStringFieldUpdateOperationsInput | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    relevanceScore?: NullableIntFieldUpdateOperationsInput | number | null
    extractedText?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    uploadedById?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumScheduleFormatFieldUpdateOperationsInput | $Enums.ScheduleFormat
    version?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isBaseline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumScheduleFormatFieldUpdateOperationsInput | $Enums.ScheduleFormat
    version?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isBaseline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    format?: EnumScheduleFormatFieldUpdateOperationsInput | $Enums.ScheduleFormat
    version?: NullableStringFieldUpdateOperationsInput | string | null
    baselineDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    statusDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    filePath?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isBaseline?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}